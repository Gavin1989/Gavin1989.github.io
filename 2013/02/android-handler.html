<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Android之Handler</title>
  
    <meta name="author" content="Gao Xu">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">
 

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Gavin Droider</a>
          <ul class="nav">
            
              


  <li><a href="/archive">Archive</a></li>


            
              


  <li><a href="/tags">Tags</a></li>


            
              


  <li><a href="/categories">Categories</a></li>


            
              


  <li><a href="/pages">Pages</a></li>


            
              


  <li><a href="/about">About Me</a></li>


            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        <div class="page-header">
  <h1>Android之Handler </h1>
</div>

<div class="row">
  <div class="span8">
    <p>Handler：Handler允许你发送并且处理和线程消息队列相关的消息（Message）和可运行对象。每个Handler实例都有一个单独的相关线程和这个线程的消息队列。当你创建一个新的Handler时候，它将和创建者所在线程以及此线程的消息队列绑定。从这一刻起，它将传递消息和可运行对象到消息队列，并在消息和可运行对象被传出消息队列时执行它们。<br />
Handler主要有两种用途：</p>

<ol>
<li>把要被执行的消息和可运行对象添加到将要执行的任务清单里。</li>
<li>把要在另外一条线程上执行的动作列入自己的队列。</li>
</ol>

<p>安排消息到任务清单，可以使用以下几种方法：post，postAtTime(Runnable,long)，postDelayed，sendEmptyMessage，sendMessage，sendMessageAtTime以及sendMessageDelayed方法。post版本的方法允许你安排Runnable对象到任务清单，这些Runnable对象将在消息队列接收到后调用它们。sendMessage版本的方法允许你安排一个Message对象到任务清单，这个Message对象包含一个将被Hanlder的handleMessage方法处理的数据包（需要在你的子类中实现handleMessage方法）。<br />
你在posting或者sending时，既可以允许消息循环在准备完成后立即处理任务，也可以在执行任务之前指定一个延迟时间。上述post和send系列的最后两个方法可以设置超时、空转和定时行为。<br />
当你的应用程序创建一个进程的时候，这个进程的主线程就专门运行一个负责管理顶级程序对象（activities，broadcast receivers等等）和所有由这些对象创建的窗口的消息循环。你可以创建自己的线程，并且通过一个Handler和应用的主线程沟通。这样做跟之前调用post或者sendMessage一样，只不过是在你的子线程中调用的。给定的Runnable对象或者Message将被添加到Hanlder的消息队列，并且在适当的时候处理它们。<br />
Hanlder默认的构造方法，将这个Handler跟当前线程中的队列关联了起来：
<pre>Handler() {
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw newRuntimeException(&ldquo;Can&rsquo;t create handler inside thread that has not called Looper.prepare()&rdquo;);
    }
    mQueue = mLooper.mQueue;
    mCallback = null;
}</pre>
Handler必须要有一个消息队列，不然它没法接受消息。在线程初始化Handler之前，必须调用Looper.prepare()，详细内容请参考<a href="http://my.oschina.net/u/272863/blog/93721">《Android之Looper》。 </a><br />
初始化Handler时，还可以指定Looper和Callback，前者可以使消息循环在Looper相关的线程中运行，后者可以使你避免重写Handler。<br />
Handler的obtainMessage系列方法都是从全局的消息池中拿Message，如果池中没有，就new一个返回。<br />
post系列方法，都是封装的对应的send系列方法（将Runnable对象（msg.callback）和一个Object对象（即msg.object，如果有的话）通过getPostMessage方法拿到一个Message，然后send）。<br />
<pre>private final Message getPostMessage(Runnable r, Object token) {
    Message m = Message.obtain();
    m.obj = token;
    m.callback = r;
    return m;
}</pre>
send系列方法，包装的都是sendMessageAtTime方法（sendMessageAtFrontOfQueue方法也是它的一个变种）。在sendMessageAtTime方法中，第一个参数是将被传递的Message对象，第二个是传递时的时间（可以猜想delayed系列方法都是当前时间加上延迟时间，事实证明这种猜想是正确的）。<br />
<pre>public boolean sendMessageAtTime(Message msg, long uptimeMillis){
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    } else {
        RuntimeException e = new RuntimeException(
                this + &ldquo; sendMessageAtTime() called with no mQueue&rdquo;);
        Log.w(&ldquo;Looper&rdquo;, e.getMessage(), e);
    }
    return sent;
}</pre>
在这个方法中，将Message排入消息队列（队列中按照uptimeMillis排序，而sendMessageAtFrontOfQueue方法中将它设为0，所以sendMessageAtFrontOfQueue方法传递的Message将在Looper的loop方法循环的下一次循环中立即执行）。enqueueMessage方法的排序部分如下：
<pre>synchronized (this) {
    if (mQuiting) {
        RuntimeException e = new RuntimeException(
                msg.target + &ldquo; sending message to a Handler on a dead thread&rdquo;);
        Log.w(&ldquo;MessageQueue&rdquo;, e.getMessage(), e);
        return false;
    } else if (msg.target == null) {
        mQuiting = true;
    }
    msg.when = when;
    //Log.d(&ldquo;MessageQueue&rdquo;, &ldquo;Enqueing: &ldquo; + msg);
    Message p = mMessages;
    if (p == null || when == 0 || when &lt; p.when) {
        msg.next = p;
        mMessages = msg;
        this.notify();
    } else {
        Message prev = null;
        while (p != null &amp;&amp; p.when &lt;= when) {
        prev = p;
        p = p.next;
    }
    msg.next = prev.next;
    prev.next = msg;
    this.notify();
}</pre>
将Message排入消息队列后的事情，是由Looper来完成的，详见<a href="http://my.oschina.net/u/272863/blog/93721">《Android之Looper》</a>中的loop方法。在Looper的loop方法中，调用了msg.target（即Handler，见sendMessageAtTime方法）的dispatchMessage方法。
<pre>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}</pre>
第一个判断，msg.callback即为post系列方法传递到的Runnable对象。
<pre>private final void handleCallback(Message message) {
    message.callback.run();
}</pre>
第二个mCallback.handleMessage方法，可以让你避免在自己的Handler子类中重写handleMessage方法。<br />
还有remove系列方法，就是根据条件从消息队列中移除相关的Message。</p>

    <hr>
    <div class="pagination">
      <ul>
        <ul>
          
            <li class="prev"><a href="/2013/02/android-intentservice.html" title="android之intentservice">&larr; Previous</a></li>
          
          

            <li><a href="/archive">Archive</a></li>

          
            <li class="next"><a href="/2013/02/how-are-android-touch-events-delivered.html" title="Android中view的Touch事件传递顺序">Next &rarr;</a></li>
          
          
        </ul>
      </ul>
    </div>
    <hr>
    
<div id="disqus_thread"></div>
<script>
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>2013-02-28</span></div>
    <br>
    <h4>Categories</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/categories/#Android-ref">Android <span>3</span></a>
</li>
    
      <li>
  <a href="/categories/#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ref">源码分析 <span>3</span></a>
</li>
    
    </ul>
    <br>
    <h4>Tags</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/tags/#Android-ref">Android <span>3</span></a>
</li>
    
      <li>
  <a href="/tags/#Handler-ref">Handler <span>1</span></a>
</li>
    
      <li>
  <a href="/tags/#Looper-ref">Looper <span>1</span></a>
</li>
    
      <li>
  <a href="/tags/#Message-ref">Message <span>1</span></a>
</li>
    
    </ul>
  </div>
</div>

      </div>

      <footer>
        <p>&copy; Gao Xu 2013 
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
		  and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

    
<script>
    var _gaq=[['_setAccount','UA-123-12'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
  </body>
</html>
