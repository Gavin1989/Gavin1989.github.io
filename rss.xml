<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Gavin Droider</title>
    <link>http://gavin1989.github.io</link>
    <pubDate>2013-05-11 11:58:59 +0800</pubDate>
    <item>
      <title>Android中view的Touch事件传递顺序</title>
      <link>http://gavin1989.github.io/2013/how-are-android-touch-events-delivered.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看一下ViewGroup的dispatchTouchEvent的关键源码：&#xA;&lt;pre&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {&#xA;        &amp;hellip;&#xA;        if (action == MotionEvent.ACTION_DOWN) {&#xA;            &amp;hellip;&#xA;            if (disallowIntercept || !onInterceptTouchEvent(ev)) {&#xA;                final View[] children = mChildren;&#xA;                final int count = mChildrenCount;&#xA;                for (int i = count - 1; i &amp;gt;= 0; i&amp;ndash;) {&#xA;                    final View child = children[i];&#xA;                    if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE&#xA;                            || child.getAnimation() != null) {&#xA;                        &amp;hellip;&#xA;                        if (child.dispatchTouchEvent(ev))  {&#xA;                            // Event handled, we have a target now.&#xA;                            mMotionTarget = child;&#xA;                            return true;&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;        &amp;hellip;&#xA;        final View target = mMotionTarget;&#xA;        if (target == null) {&#xA;            &amp;hellip;&#xA;            return super.dispatchTouchEvent(ev);&#xA;        }&#xA;        if (!disallowIntercept &amp;amp;&amp;amp; onInterceptTouchEvent(ev)) {&#xA;            &amp;hellip;&#xA;            if (!target.dispatchTouchEvent(ev)) {&#xA;                // target didn&amp;rsquo;t handle ACTION_CANCEL. not much we can do&#xA;                // but they should have.&#xA;            }&#xA;            // clear the target&#xA;            mMotionTarget = null;&#xA;            // Don&amp;rsquo;t dispatch this event to our own view, because we already&#xA;            // saw it when intercepting; we just want to give the following&#xA;            // event to the normal onTouchEvent().&#xA;            return true;&#xA;        }&#xA;        &amp;hellip;&#xA;        return target.dispatchTouchEvent(ev);&#xA;    }&lt;/pre&gt;&#xA;根据以上代码可知，如果onInterceptTouchEvent方法返回true，会直接调用当前ViewGroup的onTouch方法，否则则会依次调用其内包含的子控件的dispatchTouchEvent方法。我写了一个测试用例，ViewGroup的onInterceptTouchEvent方法与所有View的onTouch方法都打了Log：&#xA;&lt;pre&gt;    &amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;utf-8&amp;rdquo;?&amp;gt;&#xA;    &amp;lt;org.gavin.test.view.MyScrollView xmlns:android=&amp;ldquo;http://schemas.android.com/apk/res/android&amp;rdquo;&#xA;        android:layout_width=&amp;ldquo;fill_parent&amp;rdquo;&#xA;        android:layout_height=&amp;ldquo;fill_parent&amp;rdquo; &amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    &amp;amp;lt;org.gavin.test.view.MyLinearLayout&#xA;        android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;        android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;        android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;        &amp;amp;lt;org.gavin.test.view.MyImageView&#xA;            android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;            android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;            android:src=&amp;quot;@drawable/ic_launcher&amp;quot;&amp;gt;&#xA;        &amp;amp;lt;/org.gavin.test.view.MyImageView&amp;gt;&#xA;    &amp;amp;lt;/org.gavin.test.view.MyLinearLayout&amp;gt;&#xA;&amp;amp;lt;/org.gavin.test.view.MyScrollView&amp;gt;&amp;lt;/pre&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Log信息：&#xA;&lt;pre&gt;    I/MyScrollView(26001)::onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyLinearLayout(26001): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyImageView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyLinearLayout(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyScrollView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;如果MyLinearLayout的onInterceptTouchEvent方法返回true：&#xA;&lt;pre&gt;    11-04 14:05:08.389: I/MyScrollView(26297): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    11-04 14:05:08.389: I/MyLinearLayout(26297):onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    11-04 14:05:08.397: I/MyLinearLayout(26297): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;    11-04 14:05:08.397: I/MyScrollView(26297): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;OK，再看这段代码：&#xA;&lt;pre&gt;    if (child.dispatchTouchEvent(ev))  {&#xA;        // Event handled, we have a target now.&#xA;        mMotionTarget = child;&#xA;        return true;&#xA;    }&lt;/pre&gt;&#xA;从这段代码可以看出，如果某个子控件的dispatchTouchEvent方法返回true，则中断以后的消息传递。并在下一个非ACTION_DOWN事件直接调用此子控件的dispatchTouchEvent方法。一个View的dispatchTouchEvent返回true，主要可能是onTouch方法返回true。如果我们把MyImageView的onTouchEvent返回值改为true：&#xA;&lt;pre&gt;    I/MyScrollView(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyLinearLayout(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;    I/MyImageView(26393): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>