<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Gavin Droider</title>
    <link>http://gavin1989.github.io</link>
    <pubDate>2013-05-12 03:37:12 +0800</pubDate>
    <item>
      <title>新篇章——NDK</title>
      <link>http://gavin1989.github.io/2013/04/gavin-s-ndk.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://developer.android.com/tools/sdk/ndk/index.html&#34;&gt;NDK&lt;/a&gt;是从Android 1.5开始支持的，它是一系列工具的集合。它集成了交叉编译器，开发者只需要创建一个mk文件即可生成.so文件，而不用考虑如CPU、ABI、platform等。总而言之，NDK简化了JNI开发的过程。&lt;br /&gt;&#xA;开发环境：Windows64+eclipse4.2+ADT21+CDT+NDKr8e+Cygwin&lt;br /&gt;&#xA;首先，NDK使用起来还是挺方便的。首先，Java类中定义public native方法：&#xA;&lt;pre&gt;&lt;code&gt;public native String stringFromJNI&lt;/code&gt;&lt;/pre&gt;&#xA;在使用这个本地方法之前，还需要加载库：&#xA;&lt;pre&gt;&lt;code&gt;static {&#xA;    System.loadLibrary(&amp;ldquo;hellojni&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;这样，Java部分就已经定义好了。&lt;br /&gt;&#xA;要开始着手写c部分，首先要了解c中函数与Java方法的对应关系。例如上面的stringFromJNI方法，它在org.gaoxu.example.ndkdemo包下的MainActivity类，它对应的c函数名就应该为：&#xA;&lt;pre&gt;&lt;code&gt;Java_org_gaoxu_example_ndkdemo_MainActivity_stringFromJNI(JNIEnv* env, jobject thiz)&lt;/code&gt;&lt;/pre&gt;&#xA;这个函数的第二个参数先不管，第一个参数为JNIEnv指针类型，它指向了一个可执行的函数表，即可以使用它调用某个函数。实现这个方法的代码（这个文件放在工程根目录的jni目录下，记得必须声明jni.h头文件）：&#xA;&lt;pre&gt;&lt;code&gt;#include &lt;string.h&gt;&#xA;#include &lt;jni.h&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;jstring Java_org_gaoxu_example_ndkdemo_MainActivity_stringFromJNI(JNIEnv* env, jobject thiz) {&#xA;    return (*env)-&amp;gt;NewStringUTF(env, &amp;ldquo;Hello Gavin!&amp;rdquo;);&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;文件名为hellojni.c。&lt;br /&gt;&#xA;现在，还需要写一个Makefile，命名为Android.mk:&#xA;&lt;pre&gt;&lt;code&gt;LOCAL_PATH := $(call my-dir)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;include $(CLEAR_VARS)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;LOCAL_MODULE    := hellojni&#xA;LOCAL_SRC_FILES := hellojni.c&lt;/p&gt;&#xA;&#xA;&lt;p&gt;include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;&lt;/pre&gt;&#xA;Android.mk必须在文件的开头定义LOCAL_PATH变量，它被用来定位源文件。在这里我们使用“my-dir”，也就是当前文件夹（包含Android.mk文件的文件夹）。&lt;br /&gt;&#xA;第二句中，CLEAR_VARS变量会清除一些LOCAL开头的变量，比如LOCAL_MODULE、LOCAL_SRC_FILES等。&lt;br /&gt;&#xA;第三句定义了编译完成后库的名称，这个名称必须是独一无二的，编译系统会自动添加前缀和后缀。在这，LOCAL_MODULE的值为hellojni，生成的文件名就是libhellojni.so。&lt;br /&gt;&#xA;第四句定义了需要编译的源文件，很简单。&lt;br /&gt;&#xA;第五句，声明需要编译为共享库。&lt;br /&gt;&#xA;以上做完，打开Cygwin，进入工程目录，执行&#xA;&lt;pre&gt;&lt;code&gt;$NDK_ROOT/ndk-build&lt;/code&gt;&lt;/pre&gt;&#xA;如果以上步骤没有发生意外，即可完成编译。&lt;br /&gt;&#xA;好了，其实整个过程的第二步，即定义c源文件那一步，方法名可以通过javah命令自动生成，这样也能省不少时间。写完java源文件后，eclipse会自动编译工程，并将class文件放入bin/classes文件夹下。执行&#xA;&lt;pre&gt;&lt;code&gt;javah -classpath bin/classes -d jni org.gaoxu.example.ndkdemo.MainActivity&lt;/code&gt;&lt;/pre&gt;&#xA;如果报错，可能是引导类的问题，可以加上-bootclasspath参数：&#xA;&lt;pre&gt;&lt;code&gt;javah -classpath bin/classes -bootclasspath D:\android\android-sdk-windows\platforms\android-10\android.jar -d jni org.gaoxu.example.ndkdemo.MainActivity&lt;/code&gt;&lt;/pre&gt;&#xA;还有个更简单的办法：&#xA;&lt;pre&gt;&lt;code&gt;cd src&#xA;javah -d jni org.gaoxu.example.ndkdemo.MainActivity&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——基本概念</title>
      <link>http://gavin1989.github.io/2013/04/revel-concepts.html</link>
      <pubDate>2013-05-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##概念&#xA;Revel依赖于约定，即在应用中规定一个明确的架构，这使你用MVC模式构建web应用变得简单。作为回报，它的结构非常轻量级，并且开发周期非常快。&#xA;##MVC&#xA;快速总结：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Model是描述应用域的重要数据对象，它也封装了指定域查询和更新数据的逻辑。&lt;/li&gt;&#xA;&lt;li&gt;View描述了数据怎么呈现以及操作。在revel中，使用模板（template）来呈现数据以及引导用户。&lt;/li&gt;&#xA;&lt;li&gt;Controller处理请求。它们执行用户期待的动作，并决定要显示哪个view，以及准备和提供view渲染必需的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;网上有很多优秀的MVC架构的概述，尤其是Play！Framework，revel的思路完全来源于Play!Framework。&#xA;##Goroutine每一个请求&#xA;Revel构建于Go HTTP Server之上，它为每一个到来的请求都创建一个goroutine（轻量级的线程）来进行处理。它的含义是你的代码可以自由地阻塞，但是必须能够处理并发的请求进程。&#xA;##Controllers和Actions&#xA;一个HTTP请求调用一个action，action处理请求并且将结果写入到响应中。相关的action组成了controllers。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Controller可以是嵌入*revel.Controller为第一个字段的任意类型。&lt;br /&gt;&#xA;例如：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;type AppController struct {&#xA;    *revel.Controller&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;revel.Controller是请求的上下文（Context）。它包含了请求和响应的数据。下面是它及其辅助类型的定义，详情请参阅&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/controller.html#Controller&#34;&gt;godoc&lt;/a&gt;：&#xA;&lt;pre&gt;&lt;code&gt;type Controller struct {&#xA;    Name          string          // controller的名字, 例如：&amp;rdquo;Application&amp;rdquo;&#xA;    Type          *ControllerType // controller类型的描述&#xA;    MethodType    *MethodType     // 调用的action类型的描述&#xA;    AppController interface{}     // 实例化的controller&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Request  *Request&#xA;Response *Response&#xA;Result   Result&#xA;&#xA;Flash      Flash                  // 用户的cookie, 每个请求后都会清除&#xA;Session    Session                // Session, 存储在cookie, 已签名.&#xA;Params     Params                 // 来自Url和表格的参数 (包含多个).&#xA;Args       map[string]interface{} // 每个请求暂存的空间.&#xA;RenderArgs map[string]interface{} // 传递给template的参数.&#xA;Validation *Validation            // 数据验证助手&#xA;Txn        *sql.Tx                // 默认为Nil, 但可用于app / 插件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Flash表示一个每次请求都会被覆盖的cookie.&#xA;// 它允许跨页面存储数据.&#xA;// 它通常用于实现成功或失败信息.&#xA;// 例如Post/Redirect/Get模式: &lt;a href=&#34;http://en.wikipedia.org/wiki/Post/Redirect/Get&#34;&gt;http://en.wikipedia.org/wiki/Post/Redirect/Get&lt;/a&gt;&#xA;type Flash struct {&#xA;    Data, Out map[string]string&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// 它提供一个关于请求参数的统一视图.&#xA;// 包括:&#xA;// - URL查询字符串&#xA;// - 表格值&#xA;// - 文件上传&#xA;type Params struct {&#xA;    url.Values&#xA;    Files map[string][]*multipart.FileHeader&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// 一个已签名的cookie(从而大小被限制为4kb).&#xA;// 约束: Key中不能有冒号(:).&#xA;type Session map[string]string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Request struct {&#xA;    *http.Request&#xA;    ContentType string&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Response struct {&#xA;    Status      int&#xA;    ContentType string&#xA;    Headers     http.Header&#xA;    Cookies     []*http.Cookie&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Out http.ResponseWriter&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;作为处理HTTP请求的一部分，Revel实例化一个你Controller的实例，并且为嵌入的revel.Controller设置所有的属性。Revel不在请求间共享Controller实例。&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;Action可以是满足下列条件的任意Controller上的方法：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是可输出的&lt;/li&gt;&#xA;&lt;li&gt;返回一个revel.Result&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;例如：&#xA;&lt;pre&gt;&lt;code&gt;func (c AppController) ShowLogin(username string) revel.Result {&#xA;    &amp;hellip;&#xA;    return c.Render(username)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;上例中调用revel.Controller.Render来执行一个template，并将username作为参数传递给它。revel.Controller上有很多生产revel.Result的方法，但是应用也可以自由创建自己的方法。&#xA;##Result&#xA;Result可以是任意符合下面接口的类型：&#xA;&lt;pre&gt;&lt;code&gt;type Result interface {&#xA;    Apply(req *Request, resp *Response)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;通常情况下，在action返回一个Result之前不会将数据写入到响应中。接收到Result时，Revel先写入响应头和cookies（例如设置会话cookie），然后调用Result.Apply来写入真正的响应内容。&lt;br /&gt;&#xA;（action可以选择直接写入到响应，但这估计只能用于特殊情况。例如，在这些情况下，需要自己处理保存会话和Flash数据。）&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言之旅——并发</title>
      <link>http://gavin1989.github.io/2013/04/golang-tour-concurrent.html</link>
      <pubDate>2013-05-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;##Goroutine&#xA;goroutine是由Go运行时管理的轻量级线程。表达式&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;go f(x, y, z)&lt;/code&gt;&lt;/pre&gt;&#xA;会在一个新的goroutine中执行&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;f(x, y, z)&lt;/code&gt;&lt;/pre&gt;&#xA;其中f、x、y、z是在当前goroutine中赋值的，并且f的执行是在新的goroutine中进行的。&lt;br /&gt;&#xA;goroutine在同一个地址空间中运行，因此访问共享内存时必须同步。sync包提供了这种功能，但是在Go中这种方法并不常用（接下来会看到）&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;time&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func say(s string) {&#xA;    for i := 0; i &amp;lt; 5; i++ {&#xA;        time.Sleep(100 * time.Millisecond)&#xA;        fmt.Println(s)&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    go say(&amp;ldquo;world&amp;rdquo;)&#xA;    say(&amp;ldquo;hello&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Channel&#xA;Channel是一种通过Channel操作符&amp;lt;-发送和接收值的有类型的渠道：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;ch &amp;lt;- v // Send v to channel ch.&#xA;v := &amp;lt;-ch // Receive from ch, and assign value to v.&lt;/code&gt;&lt;/pre&gt;&#xA;箭头的方向就是数据流动的方向。与map和slice一样，channel必须在使用前就创建：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;ch := make(chan int)&lt;/code&gt;&lt;/pre&gt;&#xA;默认情况下，在另一端准备好前发送和接收都将阻塞。这将允许goroutine在没有明确的锁和条件变量时可以同步。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func sum(a []int, c chan int) {&#xA;    sum := 0&#xA;    for _, v := range a {&#xA;        sum += v&#xA;    }&#xA;    c &amp;lt;- sum // Send sum to c&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    a := []int{7, 2, 8, -9, 4, 0}&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;c := make(chan int)&#xA;go sum(a[:len(a)/2], c)&#xA;go sum(a[len(a)/2:], c)&#xA;x, y := &amp;lt;-c, &amp;lt;-c // receive from c&#xA;&#xA;fmt.Println(x, y, x+y)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;Channel也可以是带缓冲的，在初始化Channel时，为make函数第二参数的位置上提供一个缓冲区长度。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;ch := make(chan int, 100)&lt;/code&gt;&lt;/pre&gt;&#xA;只有在缓冲区满时发送数据才会阻塞，缓冲区为空时接收数据会阻塞。修改下面的例子，使缓冲区被填满，然后看看会发生什么。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    c := make(chan int, 2)&#xA;    c &amp;lt;- 1&#xA;    c &amp;lt;- 2&#xA;    fmt.Println(&amp;lt;-c)&#xA;    fmt.Println(&amp;lt;-c)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;发送者可以close一个Channel来表明它将不会发送更多的值。接收者也可以提供赋值语句的第二个参数来测试Channel是否被关闭。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;v, ok := &amp;lt;-ch&lt;/code&gt;&lt;/pre&gt;&#xA;如果接收不到更多值并且Channel已被关闭，ok的值就是false。表达式&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;for i := range c&lt;/code&gt;&lt;/pre&gt;&#xA;循环从Channel接收值，直到Channel被关闭。&#xA;注意：只有发送者才应该关闭Channel，而不是接收者。在一个已关闭的Channel上发送数据将会触发一个panic。&#xA;另外需要注意的是：Channel不同于文件，通常不需要关闭它们。只有在接收者不需要更多的值时才有必要关闭Channel，比如停止一个range循环。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func fibonacci (n int, c chan int) {&#xA;    x, y := 0, 1&#xA;    for i := 0; i &amp;lt; n; i++ {&#xA;        c &amp;lt;- x&#xA;        x, y = y, x+y&#xA;    }&#xA;    close&amp;copy;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    c := make(chan int, 10)&#xA;    go fibonacci(cap&amp;copy;, c)&#xA;    for i := range c {&#xA;        fmt.Println(i)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Select&#xA;select语句可以让goroutine等待多个通讯操作。select会阻塞，直到某个case可以运行，随即执行这个case。当多个case都准备好时，它会随机选择一个。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func fibonacci(c, quit chan int) {&#xA;    x, y := 0, 1&#xA;    for {&#xA;        select {&#xA;        case c &amp;lt;- x:&#xA;            x, y = y, x+y&#xA;        case &amp;lt;-quit:&#xA;            fmt.Println(&amp;ldquo;quit&amp;rdquo;)&#xA;            return&#xA;        }&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    c := make(chan int)&#xA;    quit := make(chan int)&#xA;    go func() {&#xA;        for i := 0; i &amp;lt; 10; i++ {&#xA;            fmt.Println(&amp;lt;-c)&#xA;        }&#xA;        quit &amp;lt;- 0&#xA;    }()&#xA;    fibonacci(c, quit)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果其它case都没有准备好，select就会执行default case。尝试在default情况下不阻塞地发送和接收。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;select {&#xA;case i := &amp;lt;-c:&#xA;    // use i&#xA;default:&#xA;    // receiving from c would block.&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;示例代码：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;time&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    tick := time.Tick(1e8)&#xA;    boom := time.After(5e8)&#xA;    for {&#xA;        select {&#xA;        case &amp;lt;-tick:&#xA;            fmt.Println(&amp;ldquo;tick.&amp;rdquo;)&#xA;        case &amp;lt;-boom:&#xA;            fmt.Println(&amp;ldquo;BOOM!&amp;rdquo;)&#xA;            return&#xA;        default:&#xA;            fmt.Println(&amp;rdquo;   .&amp;ldquo;)&#xA;            time.Sleep(5e7)&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>android工具之lint检测列表(一)</title>
      <link>http://gavin1989.github.io/2013/03/android-lint-list-1.html</link>
      <pubDate>2013-05-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;#Available issues:&#xA;##Correctness&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###AdapterViewChildren&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that AdapterViews do not define their children in XML&lt;br /&gt;&#xA;Priority: 10 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;AdapterViews such as ListViews must be configured with data from Java code,such as a ListAdapter.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/reference/android/widget/AdapterView.html&#34;&gt;http://developer.android.com/reference/android/widget/AdapterView.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检测AdapterView不能在XML中定义子项。AdapterView必须在Java代码中设置数据，比如ListView需要一个ListAdapter。在XML中定义AdapterView的子元素是无效的。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###OnClick&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that onClick attribute values refer to real methods&lt;br /&gt;&#xA;Priority: 10 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The onClick attribute value should be the name of a method in this View&amp;rsquo;s context to invoke when the view is clicked. This name must correspond to a public method that takes exactly one parameter of type View.&lt;br /&gt;&#xA;Must be a string value, using &amp;lsquo;\;&amp;rsquo; to escape characters such as &amp;lsquo;\n&amp;rsquo; or &amp;lsquo;\uxxxx&amp;rsquo; for a unicode character.&lt;br /&gt;&#xA;&lt;strong&gt;确保XML中onClick属性的值是真正的方法。onClick属性的值必须是存在于这个View的Context中的方法名，当点击这个View时，这个方法就会被调用。另外，这个方法必须是public的，而且需要一个View类型的参数。&lt;br /&gt;&#xA;onClick属性的值必须是一个String，使用“\”转义特殊字符，或者使用“\uxxxx”格式的Unicode字符。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###StopShip&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for comment markers of the form &amp;ldquo;STOPSHIP&amp;rdquo; which indicates that code should not be released yet.&lt;br /&gt;&#xA;Priority: 10 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;NOTE: This issue is disabled by default!You can enable it by adding &amp;ndash;enable StopShip&lt;br /&gt;&#xA;Using the comment // STOPSHIP can be used to flag code that is incomplete but checked in. This comment marker can be used to indicate that the code should not be shipped until the issue is addressed, and lint will look for these.&lt;br /&gt;&#xA;&lt;strong&gt;检测到代码注释中有“STOPSHIP”，这个注释的意思是代码不完整，还不能发布。默认是不检查这个Issue的，要检查它的话，可以加上&amp;ndash;adding StopShip。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###SuspiciousImport&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for &amp;lsquo;import android.R&amp;rsquo; statements, which are usually accidental&lt;br /&gt;&#xA;Priority: 9 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Importing android.R is usually not intentional; it sometimes happens when you use an IDE and ask it to automatically add imports at a time when your project&amp;rsquo;s R class it not present.&lt;br /&gt;&#xA;Once the import is there you might get a lot of &amp;ldquo;confusing&amp;rdquo; error messages because of course the fields available on android.R are not the ones you&amp;rsquo;d expect from just looking at your own R class.&lt;br /&gt;&#xA;&lt;strong&gt;检测到“import android.R”语句。android.R通常不是故意导入的，这个问题可能是在当前工程的R文件不存在时使用了IDE的自动补全功能导致的。&lt;br /&gt;&#xA;一旦导入android.R类，你可能会得到许多“混乱”的错误信息，因为android.R类中可能并不包含用到的属于自己R类中的字段。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###UsesMinSdkAttributes&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that the minimum SDK and target SDK attributes are defined&lt;br /&gt;&#xA;Priority: 9 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The manifest should contain a &amp;lt;uses-sdk&amp;gt; element which defines the minimum API Level required for the application to run, as well as the target version (the highest API level you have tested the version for.)&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html&#34;&gt;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检测是否定义最低SDK版本和目标SDK版本。manifest文件中必须包含一个&amp;lt;uses-sdk&amp;gt;元素，这个元素定义了当前应用运行时所需的最低API Level和目标API Level（后者通常是你测试过的最高API Level）。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###WrongViewCast&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for incorrect casts to views that according to the XML are of a different type&lt;br /&gt;&#xA;Priority: 9 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Keeps track of the view types associated with ids and if it finds a usage of the id in the Java code it ensures that it is treated as the same type.&lt;br /&gt;&#xA;&lt;strong&gt;根据View在XML中定义的类型，检测到代码中进行了不正确的类型转换。使用id跟踪View的类型，如果发现在Java代码中用到了这个id，就要确保进行了正确的类型转换。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###IllegalResourceRef&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for resource references where only literals are allowed&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;For the versionCode attribute, you have to specify an actual integer literal;you cannot use an indirection with a @dimen/name resource. Similarly, the versionName attribute should be an actual string, not a string resource url.&lt;br /&gt;&#xA;&lt;strong&gt;检测到在只允许文字的地方引用了资源。对于versionCode属性，只能使用一段特定的数字型文字，不能间接地使用一个@dimen/name资源代替。同样，versionName只能是一段真正的字符串，不能是一个字符串资源的引用。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MissingRegistered&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that classes referenced in the manifest are present in the project or libraries&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;If a class is referenced in the manifest, it must also exist in the project (or in one of the libraries included by the project. This check helps uncover typos in registration names, or attempts to rename or move classes without updating the manifest file properly.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/manifest/manifest-intro.html&#34;&gt;http://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;确保manifest文件中引用的类存在于工程或使用到的库中。这项检查有助于发现拼写错误的注册名称和重命名或者移动类之后没有正确地更新manifest文件的问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###NamespaceTypo&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for misspellings in namespace declarations&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Accidental misspellings in namespace declarations can lead to some very obscure error messages. This check looks for potential misspellings to help track these down.&lt;br /&gt;&#xA;&lt;strong&gt;检测到命名空间声明中的拼写错误。命名空间声明中偶然的拼写错误会带来一些非常模糊的错误信息，检测这种潜在的拼写错误有助于追查这些错误信息。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Proguard&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for problems in proguard config files&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Using -keepclasseswithmembernames in a proguard config file is not correct; it can cause some symbols to be renamed which should not be. Earlier versions of ADT used to create proguard.cfg files with the wrong format. Instead of -keepclasseswithmembernames use -keepclasseswithmembers,since the old flags also implies &amp;ldquo;allow shrinking&amp;rdquo; which means symbols only referred to from XML and not Java (such as possibly CustomViews) can get deleted.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://http://code.google.com/p/android/issues/detail?id=16384&#34;&gt;http://http://code.google.com/p/android/issues/detail?id=16384&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检测混淆配置文件中的问题。在混淆配置文件中使用=keepclasseswithmembernames是不正确的,因为它会导致一些符号被重命名，而实际上这些符号不应该被重命名。此前版本的ADT（21）使用一种错误的格式来创建proguard.cfg文件，现在应该用-keepclasseswithmembers来代替-keepclasseswithmembernames，因为旧标记也意味着“allow shrinking”，意思是只有从XML引用的符号才能被删除，而不包括Java代码（比如自定义View）。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ScrollViewCount&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that ScrollViews have exactly one child widget&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;ScrollViews can only have one child widget. If you want more children, wrap them in a container layout.&lt;br /&gt;&#xA;&lt;strong&gt;检测ScrollView是否只有一个子控件。ScrollView只能有一个子控件，如果想要更多的子控件，可以将这些子控件使用一个容器layout包装起来。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###StyleCycle&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for cycles in style definitions&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;There should be no cycles in style definitions as this can lead to runtime exceptions.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/ui/themes.html#Inheritance&#34;&gt;http://developer.android.com/guide/topics/ui/themes.html#Inheritance&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检测风格定义中的循环。风格定义中不应该有循环，因为它会带来运行时异常。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###UnknownId&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for id references in RelativeLayouts that are not defined elsewhere&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The @+id/ syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand. This check catches errors where you have renamed an id without updating all of the references to it.&lt;br /&gt;&#xA;&lt;strong&gt;检测到RelativeLayout中有别处没有定义的id引用。使用@+id/语法引用一个已存在的id，如果别处没有定义则创建一个新的id。不过，这也意味着就算你使用一个错误的引用，或者引用的view已经不存在，你也不会得到警告，因为这个id已经根据需要被创建出来了。这项检测可以捕获重命名id后没有更新所有引用它的地方的错误。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###WrongCase&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that the correct case is used for special layout tags such as &amp;lt;fragment&amp;gt;&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Most layout tags, such as &amp;lt;Button&amp;gt;, refer to actual view classes and are therefore capitalized. However, there are exceptions such as &amp;lt;fragment&amp;gt; and &amp;lt;include&amp;gt;. This lint check looks for incorrect capitalizations.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/components/fragments.html&#34;&gt;http://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;确保正确地使用特殊的layout标签，比如&amp;lt;fragment&amp;gt;。大多数layout标签，比如&amp;lt;Button&amp;gt;，这些标签引用实际的view类并因此首字母大写。然而，也有例外，比如&amp;lt;fragment&amp;gt;和&amp;lt;include&amp;gt;。lint会检测不正确的大写字母。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###WrongFolder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds resource files that are placed in the wrong folders&lt;br /&gt;&#xA;Priority: 8 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Resource files are sometimes placed in the wrong folder, and it can lead to subtle bugs that are hard to understand. This check looks for problems in this area, such as attempting to place a layout &amp;ldquo;alias&amp;rdquo; file in a layout/ folder rather than the values/ folder where it belongs.&lt;br /&gt;&#xA;&lt;strong&gt;检测到资源文件放在了错误的目录下。将资源文件放到错误的目录下会带来很难理解的bug，比如试图将一个布局别名文件放到layout目录而不是values目录。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###CommitTransaction&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for missing commit() calls on FragmentTransactions&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;After creating a FragmentTransaction, you typically need to commit it as well&lt;br /&gt;&#xA;&lt;strong&gt;检测到在FragmentTransaction上没有调用commit()。在创建一个FragmentTransaction后，通常需要commit它。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DalvikOverride&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for methods treated as overrides by Dalvik&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The Android virtual machine will treat a package private method in one class as overriding a package private method in its super class, even if they are in separate packages. This may be surprising, but for compatibility reasons the behavior has not been changed (yet).&lt;br /&gt;&#xA;If you really did intend for this method to override the other, make the method protected instead.&lt;br /&gt;&#xA;If you did not intend the override, consider making the method private, or changing its name or signature.&lt;br /&gt;&#xA;&lt;strong&gt;查找被认为通过Dalvik覆盖的方法。android虚拟机会将类中的包私有方法认为重写自它的父类中的包私有方法，即使它们在不同的包中。这可能比较奇怪，但是出于兼容性的考虑，这种行为不会改变。&lt;br /&gt;&#xA;如果确实打算要这个方法重写别的方法，方法的修饰符就应该是protected。&lt;br /&gt;&#xA;如果不打算重写，可以考虑将这个方法私有，或改变它的名字或签名。&lt;br /&gt;&#xA;mark：我试了一下，lint没检查出来，但是运行时会抛出java.lang.VirtualMachineError。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DuplicateIds&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for duplicate ids within a single layout&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Within a layout, id&amp;rsquo;s should be unique since otherwise findViewById() can return an unexpected view.&lt;br /&gt;&#xA;&lt;strong&gt;检查单个Layout中的重复id。在Layout中，id应该是唯一的，否则findViewById()会返回一个意想不到的view。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###InconsistentArrays&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for inconsistencies in the number of elements in arrays&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;When an array is translated in a different locale, it should normally have the same number of elements as the original array. When adding or removing elements to an array, it is easy to forget to update all the locales, and this lint warning finds inconsistencies like these.&lt;br /&gt;&#xA;Note however that there may be cases where you really want to declare a different number of array items in each configuration (for example where the array represents available options, and those options differ for different layout orientations and so on), so use your own judgement to decide if this is really an error.&lt;br /&gt;&#xA;You can suppress this error type if it finds false errors in your project.&lt;br /&gt;&#xA;&lt;strong&gt;检测数组元素数量的不一致性。当数组在不同的区域翻译时，按理应该跟原始数组有相同的元素数量。当对一个数组进行增删改动时，很容易忘记更新所有的区域设置，这项检测会在发现不一致时提出警告。&lt;br /&gt;&#xA;注意：有时候确实需要在每个配置中声明不同数量的数组元素（比如代表可用选项的数组在不同的布局方向时有所不同等等），因此你需要自己判断这到底是不是一个错误。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###NestedScrolling&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks whether a scrolling widget has any nested scrolling widgets within&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;A scrolling widget such as a ScrollView should not contain any nested scrolling widgets since this has various usability issues&lt;br /&gt;&#xA;&lt;strong&gt;检测是否在一个滚动组件中嵌套了其它的滚动组件。滚动组件比如ScrollView不应该包含任何嵌套的滚动组件，因为这可能会导致一些可用性的问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ResourceAsColor&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for calls to setColor where a resource id is passed instead of a resolved color&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Methods that take a color in the form of an integer should be passed an RGB triple, not the actual color resource id. You must call getResources().getColor(resource) to resolve the actual color value first.&lt;br /&gt;&#xA;&lt;strong&gt;检测所有调用setColor()的地方看是否传递了一个资源id而不是被解析的颜色值。setColor()方法需要的是一个RGB格式的值，而不是确切的颜色资源ID。必须先调用getResources().getColor(resource)将资源解析成真正的颜色值。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ScrollViewSize&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that ScrollViews use wrap_content in scrolling dimension&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;ScrollView children must set their layout_width or layout_height attributes to wrap_content rather than fill_parent or match_parent in the scrolling dimension&lt;br /&gt;&#xA;&lt;strong&gt;检测ScrollView的滚动尺寸使用wrap_content。ScrollView的子控件必须将它们的layout_width或layout_height属性（这个取决于ScrollView的滚动方向__）设置为wrap_content而不是fill_parent或match_parent。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###TextViewEdits&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for TextViews being used for input&lt;br /&gt;&#xA;Priority: 7 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Using a &amp;lt;TextView&amp;gt; to input text is generally an error, you should be using &amp;lt;EditText&amp;gt; instead.  EditText is a subclass of TextView, and some of the editing support is provided by TextView, so it&amp;rsquo;s possible to set some input-related properties on a TextView. However, using a TextView along with input attributes is usually a cut &amp;amp; paste error. To input text you should be using &amp;lt;EditText&amp;gt;.&lt;br /&gt;&#xA;This check also checks subclasses of TextView, such as Button and CheckBox,since these have the same issue: they should not be used with editable attributes.&lt;br /&gt;&#xA;&lt;strong&gt;检测到TextView被用来输入。输入文本的时候使用&amp;lt;TextView&amp;gt;通常是个错误，应该使用&amp;lt;EditText&amp;gt;代替。EditText是TextView的子类，它的一些编辑支持也是通过TextView提供的，因此它可以设置一些TextView上的输入相关的属性。不过，使用一个有输入属性的TextView通常是在剪切/复制时发生的错误。要输入文本应该使用&amp;lt;EditText&amp;gt;。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;这项检测同时也会检查TextView的其它子类，比如Button和CheckBox，因此它们会有相同的问题：它们不应该使用可编辑的属性。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###CommitPrefEdits&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for code editing a SharedPreference but forgetting to call commit() on it&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;After calling edit() on a SharedPreference, you must call commit() or apply() on the editor to save the results.&lt;br /&gt;&#xA;&lt;strong&gt;检测到代码中修改了一个SharedPreference但是忘记调用了commit()方法。在SharedPreference上调用了edit()之后，必须在editor上调用commit()或apply()以保存结果。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###CutPasteId&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for code cut &amp;amp; paste mistakes in findViewById() calls&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;This lint check looks for cases where you have cut &amp;amp; pasted calls to findViewById but have forgotten to update the R.id field. It&amp;rsquo;s possible that your code is simply (redundantly) looking up the field repeatedly, but lint cannot distinguish that from a case where you for example want to initialize fields prev and next and you cut &amp;amp; pasted findViewById(R.id.prev) and forgot to update the second initialization to R.id.next.&lt;br /&gt;&#xA;&lt;strong&gt;检测剪切&amp;amp;粘贴findViewById()方法时的错误。当剪切&amp;amp;粘贴findViewById()时，可能忘记修改R.id字段，这项检测会检查这种错误。有可能你的代码只是简单地反复查找字段（冗余），但是lint不会区分这种情况与普通忘记修改字段的情况。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DefaultLocale&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds calls to locale-ambiguous String manipulation methods&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Calling String#toLowerCase() or #toUpperCase() without specifying an explicit locale is a common source of bugs. The reason for that is that those methods will use the current locale on the user&amp;rsquo;s device, and even though the code appears to work correctly when you are developing the app, it will fail in some locales. For example, in the Turkish locale, the uppercase replacement for i is not I.&lt;br /&gt;&#xA;If you want the methods to just perform ASCII replacement, for example to convert an enum name, call String#toUpperCase(Locale.US) instead. If you really want to use the current locale, call String#toUpperCase(Locale.getDefault()) instead.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/reference/java/util/Locale.html#default_locale&#34;&gt;http://developer.android.com/reference/java/util/Locale.html#default_locale&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;发现调用了区域模糊的字符串操作方法。这个bug通常是在调用String的toLowerCase()或者toUpperCase()时没有指定明确的区域导致的。原因是如果不指定区域的话，这些方法就会使用用户设备上当前的语言环境，即使该代码在你开发app时是正常工作的，它也会在某些环境下失败。比如，在土耳其的语言环境下，i的大写字母不是I。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你想让这些方法仅仅执行ASCII转换，比如转换一个枚举名，就调用String的toUpperCase(Locale.US)。如果你确实要使用当前的语言环境，就调用String的toUpperCase(Locale.getDefault())。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DuplicateDefinition&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Discovers duplicate definitions of resources&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;You can define a resource multiple times in different resource folders; that&amp;rsquo;s how string translations are done, for example. However, defining the same resource more than once in the same resource folder is likely an error, for example attempting to add a new resource without realizing that the name is already used, and so on.&lt;br /&gt;&#xA;&lt;strong&gt;发现重复定义的资源。可以在不同的资源目录中多次定义一个资源，比如，需要翻译的字符串就是这么做的。然而，在同一个目录下多次定义同样的资源很可能就是一个错误，例如，在没意识到的情况下试图将名称已经被使用的新资源添加到目录下。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DuplicateIncludedIds&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for duplicate ids across layouts that are combined with include tags&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;It&amp;rsquo;s okay for two independent layouts to use the same ids. However, if layouts are combined with include tags, then the id&amp;rsquo;s need to be unique within any chain of included layouts, or Activity#findViewById() can return an unexpected view.&lt;br /&gt;&#xA;&lt;strong&gt;检查layout中使用include标签时的重复ID。可以在两个独立的布局中使用同一个ID，但是，如果该layout是使用include标签合并的，那么所有被合并的layout中的ID就应该是独一无二的，否则Activity的findViewById()可能返回一个意想不到的view。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###InlinedApi&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds inlined fields that may or may not work on older platforms&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;This check scans through all the Android API field references in the application and flags certain constants, such as static final integers and Strings, which were introduced in later versions. These will actually be copied into the class files rather than being referenced, which means that the value is available even when running on older devices. In some cases that&amp;rsquo;s fine, and in other cases it can result in a runtime crash or incorrect behavior. It depends on the context, so consider the code carefully and device whether it&amp;rsquo;s safe and can be suppressed or whether the code needs tbe guarded.&lt;br /&gt;&#xA;If you really want to use this API and don&amp;rsquo;t need to support older devices just set the minSdkVersion in your AndroidManifest.xml file.&lt;br /&gt;&#xA;If your code is deliberately accessing newer APIs, and you have ensured (e.g.with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the @TargetApi annotation specifying the local minimum SDK to apply, such as @TargetApi(11), such that this check considers 11 rather than your manifest file&amp;rsquo;s minimum SDK as the required API level.&lt;br /&gt;&#xA;&lt;strong&gt;检测到内联字段可能无法在旧平台上工作。这项检查扫描应用中引用的所有在更高平台上引入的Android API字段和一定的常量标记，比如static final的数字和字符串。实际上这些值会被复制到类文件而不是直接引用，这也意味着在旧平台上这些值也是可用的。在某些情况下这很好，但是在其它情况下它会返回一个运行时异常或者不正确的行为。其结果取决于上下文，因此应该仔细地研究代码和设备是否安全并且可以避免这个问题，或者代码需要tbe guarded。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你确实想要使用这个API并且不需要支持旧平台，只在AndroidManifest.xml文件中设置minSdkVersion即可。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你是故意在代码中访问新的API，并且可以保证（有条件的执行），这段代码就只会在支持它的平台上被调用，然后你就可以使用@TargetApi注释你的类或者方法来指定应用环境的最小SDK，比如对于@TargetApi(11)，这项检查只考虑API 11而不是你的manifest文件中最低SDK的API级别。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Instantiatable&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that classes registered in the manifest file are instantiatable&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Activities, services, broadcast receivers etc. registered in the manifest file must be &amp;ldquo;instantiatable&amp;rdquo; by the system, which means that the class must be public, it must have an empty public constructor, and if it&amp;rsquo;s an inner class,it must be a static inner class.&lt;br /&gt;&#xA;&lt;strong&gt;确保在manifest文件中注册的类可以实例化。在manifest文件中注册的Activity、Service、BroadcastReceiver等等必须是可以被系统实例化的，这也意味着这些类必须是public的，并且必须有一个空的public的构造方法，如果它是一个内部类，那它必须是静态内部类。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###InvalidPackage&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds API accesses to APIs that are not supported in Android&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;This check scans through libraries looking for calls to APIs that are not included in Android.&lt;br /&gt;&#xA;When you create Android projects, the classpath is set up such that you can only access classes in the API packages that are included in Android. However, if you add other projects to your libs/ folder, there is no guarantee that those .jar files were built with an Android specific classpath, and in particular, they could be accessing unsupported APIs such as java.applet.&lt;br /&gt;&#xA;This check scans through library jars and looks for references to API packages that are not included in Android and flags these. This is only an error if your code calls one of the library classes which wind up referencing the unsupported package.&lt;br /&gt;&#xA;&lt;strong&gt;发现API访问了Android不支持的API。这项检查通过扫描库文件查找对Android中不包含的API的调用。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;当创建Android工程的时候，通过设置__classpath，你只能访问Android中包含的包里面的类。然而，如果你在工程的libs/目录下添加了其它工程，你就无法保证这些jar文件是通过Android指定的classpath编译的，尤其是，它们可以访问不支持的API比如java.applet。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;这项检查通过扫描jar文件来查找对Android不支持的api的访问。如果你的代码调用的库中的类引用不支持的软件包，这就只是一个错误。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###LibraryCustomView&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Flags custom attributes in libraries, which must use the res-auto-namespace instead&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;When using a custom view with custom attributes in a library project, the layout must use the special namespace &lt;a href=&#34;http://schemas.android.com/apk/res-auto&#34;&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt; instead of a URI which includes the library project&amp;rsquo;s own package. This will be used to automatically adjust the namespace of the attributes when the library resources are merged into the application project.&lt;br /&gt;&#xA;&lt;strong&gt;标记库中的自定义属性，必须使用res-auto命名空间代替。当使用库工程中有自定义属性的自定义控件时，布局中必须使用指定的命名空间http://schemas.android.com/apk/res-auto代替库工程包中的URI。当库资源合并到应用工程时，它将被用于属性命名空间的自动适配。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MissingPrefix&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Detect XML attributes not using the Android namespace&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Most Android views have attributes in the Android namespace. When referencing these attributes you must include the namespace prefix, or your attribute will be interpreted by aapt as just a custom attribute.&lt;br /&gt;&#xA;Similarly, in manifest files, nearly all attributes should be in the android:namespace.&lt;br /&gt;&#xA;&lt;strong&gt;检测到XML属性未使用Android命名空间。Android命名空间中有大多数Android视图的属性。引用这些属性的时候，必须包含一个命名空间前缀，或者你的属性是被aapt解释过的自定义属性。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;同样地，在manifest文件中，几乎全部属性都包含在android:namespace中。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MultipleUsesSdk&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that the &amp;lt;uses-sdk&amp;gt; element appears at most once&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The &amp;lt;uses-sdk&amp;gt; element should appear just once; the tools will not merge the contents of all the elements so if you split up the attributes across multiple elements, only one of them will take effect. To fix this, just merge all the attributes from the various elements into a single &amp;lt;uses-sdk&amp;gt; element.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html&#34;&gt;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检查&amp;lt;uses-sdk&amp;gt;元素最多出现一次。&amp;lt;uses-sdk&amp;gt;元素应该只出现一次，工具不会合并所有元素中的内容，因此如果通过多个元素将属性分开，那么它们中只有一个有效。要修复这个问题，只需要将各个元素中的所有属性合并到一个单独的&amp;lt;uses-sdk&amp;gt;元素中。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###NewApi&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds API accesses to APIs that are not supported in all targeted API versions&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;This check scans through all the Android API calls in the application and warns about any calls that are not available on all versions targeted by this application (according to its minimum SDK attribute in the manifest).&lt;br /&gt;&#xA;If you really want to use this API and don&amp;rsquo;t need to support older devices just set the minSdkVersion in your AndroidManifest.xml file.&lt;br /&gt;&#xA;If your code is deliberately accessing newer APIs, and you have ensured (e.g.with conditional execution) that this code will only ever be called on a supported platform, then you can annotate your class or method with the @TargetApi annotation specifying the local minimum SDK to apply, such as @TargetApi(11), such that this check considers 11 rather than your manifest file&amp;rsquo;s minimum SDK as the required API level.&lt;br /&gt;&#xA;If you are deliberately setting android: attributes in style definitions, make sure you place this in a values-v11 folder in order to avoid running into runtime conflicts on certain devices where manufacturers have added custom attributes whose ids conflict with the new ones on later platforms.&lt;br /&gt;&#xA;Similarly, you can use tools:targetApi=&amp;ldquo;11&amp;rdquo; in an XML file to indicate that the element will only be inflated in an adequate context.&lt;br /&gt;&#xA;&lt;strong&gt;发现API访问了所有针对的系统版本都不支持的API。这项检查扫描应用中所有调用了Android API的地方，并且对应用不可用的调用提出警告（根据manifest文件中的最小SDK属性）。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你确实想使用这个API并不需要支持旧的设备，只需要在AndroidManifest.xml文件中设置minSdkVersion属性即可。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你的代码是故意访问了更新的API，并且你可以确保（有条件地执行）代码只在支持的平台上调用，可以使用@TargetApi注释来注释你的类或方法以指定应用环境的最低SDK，例如@TargetApi(11)，这项检查就会考虑API 11而不是你的manifest文件中需要的最低SDK级别。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;如果你在风格定义中故意设置了android:attributes，就要确保你把它放到了values-v11目录下以避免在新的平台上运行时与某些设备制造商增加的自定义属性冲突。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;同样地，可以在XML中使用tools:targetApi=”11&amp;rdquo;来让元素只在适当的上下文中加载。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###OldTargetApi&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that the manifest specifies a targetSdkVersion that is recent&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;When your application runs on a version of Android that is more recent than your targetSdkVersion specifies that it has been tested with, various compatibility modes kick in. This ensures that your application continues to work, but it may look out of place. For example, if the targetSdkVersion is less than 14, your app may get an option button in the UI.&lt;br /&gt;&#xA;To fix this issue, set the targetSdkVersion to the highest available value.Then test your app to make sure everything works correctly. You may want to consult the compatibility notes to see what changes apply to each version you are adding support for:http://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/reference/android/os/Build.VERSION_CODES.html&#34;&gt;http://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;/a&gt;&lt;br /&gt;&#xA;&lt;strong&gt;检查manifest指定的targetSdkVersion是最新的。当你的应用运行在一个比你指定的targetSdkVersion更新的Android版本上时，需要使用各种兼容性模式启动测试。这样可以保证你的应用继续工作，但是也许会显得某些地方格格不入。例如，如果targetSdkVersion小于14，你的应用的UI中也许就会出现一个选项按钮。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;要解决这个问题，将targetSdkVersion的值设置为可用的最大值即可。然后测试你的应用以保证一切工作正常。有关兼容性的详情，请参阅：http://developer.android.com/reference/android/os/Build.VERSION_CODES.html&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Override&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds method declarations that will accidentally override methods in later versions&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Suppose you are building against Android API 8, and you&amp;rsquo;ve subclassed Activity. In your subclass you add a new method called isDestroyed(). At somelater point, a method of the same name and signature is added to Android. Your method will now override the Android method, and possibly break its contract.Your method is not calling super.isDestroyed(), since your compilation target doesn&amp;rsquo;t know about the method.&lt;br /&gt;&#xA;The above scenario is what this lint detector looks for. The above example is real, since isDestroyed() was added in API 17, but it will be true for any method you have added to a subclass of an Android class where your build target is lower than the version the method was introduced in.&lt;br /&gt;&#xA;To fix this, either rename your method, or if you are really trying to augment the builtin method if available, switch to a higher build target where you can deliberately add @Override on your overriding method, and call super if appropriate etc.&lt;br /&gt;&#xA;&lt;strong&gt;查找方法声明偶然地覆盖了更高版本的方法。假设你针对Android API 8编译，并且有一个Activity的子类。在你的子类中添加了一个新名为isDestroyed()的方法。在后面的一些版本中，方法名以及签名相同的方法被加入到了Android中。现在你的方法就覆盖了Android的方法，并且可能打破契约。你的方法没有调用super.isDestroyed()，因此编译时不知道这个方法的目标。&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;上面说的就是lint检测的情况。上面的例子也是真实的，因为isDestroyed()是API 17中加入的，但是对于你添加到这个子类中的任何方法，在编译目标低于引入这个方法的版本时，这个方法都返回true。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;##Registered&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that Activities, Services and Content Providers are registered in the manifest&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Activities, services and content providers should be registered in the AndroidManifest.xml file using &lt;activity&gt;, &lt;service&gt; and &lt;provider&gt; tags.&lt;br /&gt;&#xA;If your activity is simply a parent class intended to be subclassed by other &amp;ldquo;real&amp;rdquo; activities, make it an abstract class.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/manifest/manifest-intro.html&#34;&gt;http://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###SdCardPath&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for hardcoded references to /sdcard&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Your code should not reference the /sdcard path directly; instead use Environment.getExternalStorageDirectory().getPath().&lt;br /&gt;&#xA;Similarly, do not reference the /data/data/ path directly; it can vary in multi-user scenarios. Instead, use Context.getFilesDir().getPath().&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/data/data-storage.html#filesExternal&#34;&gt;http://developer.android.com/guide/topics/data/data-storage.html#filesExternal&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ShowToast&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for code creating a Toast but forgetting to call show() on it&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Toast.makeText() creates a Toast but does not show it. You must call show() on the resulting object to actually make the Toast appear.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###SimpleDateFormat&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Using SimpleDateFormat directly without an explicit locale&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Almost all callers should use getDateInstance(), getDateTimeInstance(), or getTimeInstance() to get a ready-made instance of SimpleDateFormat suitable for the user&amp;rsquo;s locale. The main reason you&amp;rsquo;d create an instance this class directly is because you need to format/parse a specific machine-readable format, in which case you almost certainly want to explicitly ask for US to ensure that you get ASCII digits (rather than, say, Arabic digits).&lt;br /&gt;&#xA;Therefore, you should either use the form of the SimpleDateFormat constructor where you pass in an explicit locale, such as Locale.US, or use one of the get instance methods, or suppress this error if really know what you are doing.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/reference/java/text/SimpleDateFormat.html&#34;&gt;http://developer.android.com/reference/java/text/SimpleDateFormat.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Suspicious0dp&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for 0dp as the width in a vertical LinearLayout or as the height in a horizontal&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Using 0dp as the width in a horizontal LinearLayout with weights is a useful trick to ensure that only the weights (and not the intrinsic sizes) are used when sizing the children.&lt;br /&gt;&#xA;However, if you use 0dp for the opposite dimension, the view will be invisible. This can happen if you change the orientation of a layout without also flipping the 0dp dimension in all the children.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###UniquePermission&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that permission names are unique&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The unqualified names or your permissions must be unique. The reason for this is that at build time, the aapt tool will generate a class named Manifest which contains a field for each of your permissions. These fields are named using your permission unqualified names (i.e. the name portion after the last dot).&lt;br /&gt;&#xA;If more than one permission maps to the same field name, that field will arbitrarily name just one of them.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ValidFragment&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that Fragment subclasses can be instantiated&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;From the Fragment documentation:&lt;br /&gt;&#xA;Every fragment must have an empty constructor, so it can be instantiated when restoring its activity&amp;rsquo;s state. It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated; instead, arguments can be supplied by the caller with setArguments(Bundle) and later retrieved by the Fragment with getArguments().&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/reference/android/app/Fragment.html#Fragment(&#34;&gt;http://developer.android.com/reference/android/app/Fragment.html#Fragment(&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###WrongCall&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Finds cases where the wrong call is made, such as calling onMeasure instead of measure&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Custom views typically need to call measure() on their children, not onMeasure. Ditto for onDraw, onLayout, etc.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###WrongManifestParent&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that various manifest elements are declared in the right place&lt;br /&gt;&#xA;Priority: 6 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The &amp;lt;uses-library&amp;gt; element should be defined as a direct child of the &amp;lt;application&amp;gt; tag, not the &amp;lt;manifest&amp;gt; tag or an &amp;lt;activity&amp;gt; tag. Similarly, a &amp;lt;uses-sdk&amp;gt; tag much be declared at the root level, and so on. This check looks for incorrect declaration locations in the manifest, and complains if an element is found in the wrong place.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/topics/manifest/manifest-intro.html&#34;&gt;http://developer.android.com/guide/topics/manifest/manifest-intro.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###DuplicateActivity&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that an activity is registered only once in the manifest&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;An activity should only be registered once in the manifest. If it is accidentally registered more than once, then subtle errors can occur, since attribute declarations from the two elements are not merged, so you may accidentally remove previous declarations.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ManifestOrder&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for manifest problems like &amp;lt;uses-sdk&amp;gt; after the &amp;lt;application&amp;gt; tag&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The &amp;lt;application&amp;gt; tag should appear after the elements which declare which version you need, which features you need, which libraries you need, and so on. In the past there have been subtle bugs (such as themes not getting applied correctly) when the &amp;lt;application&amp;gt; tag appears before some of these other elements, so it&amp;rsquo;s best to order your manifest in the logical dependency order.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MissingId&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that XML tags like &amp;lt;fragment&amp;gt; specify an id or tag attribute&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;If you do not specify an android:id or an android:tag attribute on a &amp;lt;fragment&amp;gt; element, then if the activity is restarted (for example for an orientation rotation) you may lose state. From the fragment documentation:&lt;br /&gt;&#xA;&amp;ldquo;Each fragment requires a unique identifier that the system can use to restorethe fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it). * Supply the android:id attribute with a unique ID.&lt;br /&gt;&#xA;* Supply the android:tag attribute with a unique string.&lt;br /&gt;&#xA;If you provide neither of the previous two, the system uses the ID of the container view.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/components/fragments.html&#34;&gt;http://developer.android.com/guide/components/fragments.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ProtectedPermissions&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for permissions that are only granted to system apps&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Permissions with the protection level signature or signatureOrSystem are only granted to system apps. If an app is a regular non-system app, it will never be able to use these permissions.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###StateListReachable&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for unreachable states in a &amp;lt;selector&amp;gt;&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;In a selector, only the last child in the state list should omit a state qualifier. If not, all subsequent items in the list will be ignored since the given item will match all.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###UnknownIdInLayout&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Makes sure that @+id references refer to views in the same layout&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The @+id/ syntax refers to an existing id, or creates a new one if it has not already been defined elsewhere. However, this means that if you have a typo in your reference, or if the referred view no longer exists, you do not get a warning since the id will be created on demand.&lt;br /&gt;&#xA;This is sometimes intentional, for example where you are referring to a view which is provided in a different layout via an include. However, it is usually an accident where you have a typo or you have renamed a view without updating all the references to it.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###UnlocalizedSms&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for code sending text messages to unlocalized phone numbers&lt;br /&gt;&#xA;Priority: 5 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;SMS destination numbers must start with a country code or the application code must ensure that the SMS is only sent when the user is in the same country as the receiver.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###GridLayout&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for potential GridLayout errors like declaring rows and columns outside the declared grid dimensions&lt;br /&gt;&#xA;Priority: 4 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Declaring a layout_row or layout_column that falls outside the declared size of a GridLayout&amp;rsquo;s rowCount or columnCount is usually an unintentional error.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###InOrMmUsage&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for use of the &amp;ldquo;mm&amp;rdquo; or &amp;ldquo;in&amp;rdquo; dimensions&lt;br /&gt;&#xA;Priority: 4 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Avoid using mm (millimeters) or in (inches) as the unit for dimensions.&lt;br /&gt;&#xA;While it should work in principle, unfortunately many devices do not report the correct true physical density, which means that the dimension calculations won&amp;rsquo;t work correctly. You are better off using dp (and for font sizes, sp.)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###RequiredSize&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that the layout_width and layout_height are specified for all views&lt;br /&gt;&#xA;Priority: 4 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;All views must specify an explicit layout_width and layout_height attribute.There is a runtime check for this, so if you fail to specify a size, an exception is thrown at runtime.&lt;br /&gt;&#xA;It&amp;rsquo;s possible to specify these widths via styles as well. GridLayout, as a special case, does not require you to specify a size.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ExtraText&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for extraneous text in layout files&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Layout resource files should only contain elements and attributes. Any XML text content found in the file is likely accidental (and potentially dangerous if the text resembles XML and the developer believes the text to be functional)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###InnerclassSeparator&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Ensures that inner classes are referenced using &amp;lsquo;$&amp;rsquo; instead of &amp;lsquo;.&amp;rsquo; in class names&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;When you reference an inner class in a manifest file, you must use &amp;lsquo;$&amp;rsquo; instead of &amp;lsquo;.&amp;rsquo; as the separator character, i.e. Outer$Inner instead of Outer.Inner.&lt;br /&gt;&#xA;(If you get this warning for a class which is not actually an inner class,it&amp;rsquo;s because you are using uppercase characters in your package name, which is not conventional.)&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###LocalSuppress&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for @SuppressLint annotations in locations where it doesn&amp;rsquo;t work for class based checks&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The @SuppressAnnotation is used to suppress Lint warnings in Java files.&lt;br /&gt;&#xA;However, while many lint checks analyzes the Java source code, where they can find annotations on (for example) local variables, some checks are analyzing the .class files. And in class files, annotations only appear on classes,fields and methods. Annotations placed on local variables disappear. If you attempt to suppress a lint error for a class-file based lint check, the suppress annotation not work. You must move the annotation out to the surrounding method.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###PrivateResource&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for references to private resources&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Fatal&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Private resources should not be referenced; the may not be present everywhere,and even where they are they may disappear without notice.&lt;br /&gt;&#xA;To fix this, copy the resource into your own project. You can find the platform resources under $ANDROID_SK/platforms/android-$VERSION/data/res/.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###ProguardSplit&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks for old proguard.cfg files that contain generic Android rules&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Earlier versions of the Android tools bundled a single proguard.cfg file containing a ProGuard configuration file suitable for Android shrinking and obfuscation. However, that version was copied into new projects, which means that it does not continue to get updated as we improve the default ProGuard rules for Android.&lt;br /&gt;&#xA;In the new version of the tools, we have split the ProGuard configuration into two halves:&lt;br /&gt;&#xA;* A simple configuration file containing only project-specific flags, in yourproject&lt;br /&gt;&#xA;* A generic configuration file containing the recommended set of ProGuard options for Android projects. This generic file lives in the SDK install directory which means that it gets updated along with the tools.&lt;br /&gt;&#xA;In order for this to work, the proguard.config property in the project.properties file now refers to a path, so you can reference both the generic file as well as your own (and any additional files too).&lt;br /&gt;&#xA;To migrate your project to the new setup, create a new proguard-project.txt file in your project containing any project specific ProGuard flags as well as any customizations you have made, then update your project.properties file to contain:&lt;br /&gt;&#xA;proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-projec.txt&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;##SpUsage&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for uses of &amp;ldquo;dp&amp;rdquo; instead of &amp;ldquo;sp&amp;rdquo; dimensions for text sizes&lt;br /&gt;&#xA;Priority: 3 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;When setting text sizes, you should normally use sp, or &amp;ldquo;scale-independent pixels&amp;rdquo;. This is like the dp unit, but it is also scaled by the user&amp;rsquo;s font size preference. It is recommend you use this unit when specifying font sizes,so they will be adjusted for both the screen density and the user&amp;rsquo;s preference.&lt;br /&gt;&#xA;There are cases where you might need to use dp; typically this happens when the text is in a container with a specific dp-size. This will prevent the text from spilling outside the container. Note however that this means that the user&amp;rsquo;s font size settings are not respected, so consider adjusting the layout itself to be more flexible.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/training/multiscreen/screendensities.html&#34;&gt;http://developer.android.com/training/multiscreen/screendensities.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Deprecated&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for usages of deprecated layouts, attributes, and so on.&lt;br /&gt;&#xA;Priority: 2 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;Deprecated views, attributes and so on are deprecated because there is a better way to do something. Do it that new way. You&amp;rsquo;ve been warned.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MangledCRLF&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that files with DOS line endings are consistent&lt;br /&gt;&#xA;Priority: 2 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;On Windows, line endings are typically recorded as carriage return plus newline: \r\n.&lt;br /&gt;&#xA;This detector looks for invalid line endings with repeated carriage return characters (without newlines). Previous versions of the ADT plugin could accidentally introduce these into the file, and when editing the file, the editor could produce confusing visual artifacts.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421&#34;&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=375421&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###MissingVersion&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that the application name and version are set&lt;br /&gt;&#xA;Priority: 2 / 10&lt;br /&gt;&#xA;Severity: WarningCategory: Correctness&lt;br /&gt;&#xA;You should define the version information for your application.&lt;br /&gt;&#xA;android:versionCode: An integer value that represents the version of the application code, relative to other versions.&lt;br /&gt;&#xA;android:versionName: A string value that represents the release version of the application code, as it should be shown to users.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/tools/publishing/versioning.html#appversioning&#34;&gt;http://developer.android.com/tools/publishing/versioning.html#appversioning&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###Orientation&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Checks that LinearLayouts with multiple children set the orientation&lt;br /&gt;&#xA;Priority: 2 / 10&lt;br /&gt;&#xA;Severity: Error&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;The default orientation of a LinearLayout is horizontal. It&amp;rsquo;s pretty easy to believe that the layout is vertical, add multiple children to it, and wonder why only the first child is visible (when the subsequent children are off screen to the right). This lint rule helps pinpoint this issue by warning whenever a LinearLayout is used with an implicit orientation and multiple children.&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;###PxUsage&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Summary: Looks for use of the &amp;ldquo;px&amp;rdquo; dimension&lt;br /&gt;&#xA;Priority: 2 / 10&lt;br /&gt;&#xA;Severity: Warning&lt;br /&gt;&#xA;Category: Correctness&lt;br /&gt;&#xA;For performance reasons and to keep the code simpler, the Android system uses pixels as the standard unit for expressing dimension or coordinate values.That means that the dimensions of a view are always expressed in the code using pixels, but always based on the current screen density. For instance, if myView.getWidth() returns 10, the view is 10 pixels wide on the current screen, but on a device with a higher density screen, the value returned might be 15. If you use pixel values in your application code to work with bitmaps that are not pre-scaled for the current screen density, you might need to scale the pixel values that you use in your code to match the un-scaled bitmap source.&lt;br /&gt;&#xA;More information: &lt;a href=&#34;http://developer.android.com/guide/practices/screens_support.html#screen-independence&#34;&gt;http://developer.android.com/guide/practices/screens_support.html#screen-independence&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架之拦截器</title>
      <link>http://gavin1989.github.io/2013/05/revel-interceptors.html</link>
      <pubDate>2013-05-08 03:16:51 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;拦截器&#34; href=&#34;#拦截器&#34;&gt;&lt;/a&gt;拦截器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;拦截器是在一个Action实施之前或之后由框架调用的一个函数。它允许一种面向方面编程的形式，这对一些常见的问题非常有用：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;请求记录&lt;/li&gt;&#xA;&lt;li&gt;错误处理&lt;/li&gt;&#xA;&lt;li&gt;状态保持&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;在Revel中，一个拦截器可以有下面两种形式之一：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;功能拦截器：一个匹配InterceptorFunc接口的函数。&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无法访问特殊的应用Controller调用。&lt;/li&gt;&#xA;&lt;li&gt;可以施加到应用中任意/所有的Controller。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;方法拦截器：不接受参数的Controller方法，并且返回一个revel.Result。&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只能拦截绑定的Controller的调用。&lt;/li&gt;&#xA;&lt;li&gt;可以随意修改调用的Controller。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;拦截器以被添加的顺序调用。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;拦截时间&#34; href=&#34;#拦截时间&#34;&gt;&lt;/a&gt;拦截时间&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个拦截器可以在请求生命周期的四个时间点上注册并运行：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BEFORE：请求被路由，Session、Flash和参数被解码后，Action运行前。&lt;/li&gt;&#xA;&lt;li&gt;AFTER：请求返回一个Result之后，返回的Result被应用前。如果Action得到一个panic，这些拦截器就不会运行。&lt;/li&gt;&#xA;&lt;li&gt;PANIC：一个panic退出Action或返回Result之后。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;FINALLY：一个Action完成并且返回的Result被应用后。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;results&#34; href=&#34;#results&#34;&gt;&lt;/a&gt;Results&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;拦截器通常返回nil，在这种情况下请求会被继续处理，而不中断。&lt;br /&gt;&#xA;返回一个非空的revel.Result的结果依赖于拦截器运行的时间。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;BEFORE:没有进一步的拦截器被调用。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;AFTER：所有的拦截器仍然会运行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;PANIC：所有的拦截器仍然会运行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;FINALLY：所有的拦截器仍然会运行。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在所有情况下，所有返回的Result会替换现有的Result。&lt;br /&gt;&#xA;然而，在BEFORE情况下，返回的Result肯定是最终的。而在AFTER情况下，有一种可能是进一步的拦截器可以发出自己的Result。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;示例&#34; href=&#34;#示例&#34;&gt;&lt;/a&gt;示例&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;功能拦截器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;下面是一个定义和注册功能拦截器的简单例子：&#xA;&lt;pre&gt;&lt;code&gt;func checkUser(c *revel.Controller) revel.Result {&#xA;    if user := connected&amp;copy;; user == nil {&#xA;        c.Flash.Error(&amp;ldquo;Please log in first&amp;rdquo;)&#xA;        return c.Redirect(Application.Index)&#xA;    }&#xA;    return nil&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func init() {&#xA;    revel.InterceptFunc(checkUser, revel.BEFORE, &amp;Hotels;{})&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;方法拦截器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;方法拦截器的签名可以是下列两项之一：&#xA;&lt;pre&gt;&lt;code&gt;func (c AppController) example() revel.Result&#xA;func (c *AppController) example() revel.Result&lt;/code&gt;&lt;/pre&gt;&#xA;下面是只能在应用Controller上运作的例子：&#xA;&lt;pre&gt;&lt;code&gt;func (c Hotels) checkUser() revel.Result {&#xA;    if user := connected&amp;copy;; user == nil {&#xA;        c.Flash.Error(&amp;ldquo;Please log in first&amp;rdquo;)&#xA;        return c.Redirect(Application.Index)&#xA;    }&#xA;    return nil&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func init() {&#xA;    revel.InterceptMethod(checkUser, revel.BEFORE)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架之模版（Template）</title>
      <link>http://gavin1989.github.io/2013/05/revel-templates.html</link>
      <pubDate>2013-05-08 02:28:13 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;模版&#34; href=&#34;#模版&#34;&gt;&lt;/a&gt;模版&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Revel使用&lt;a href=&#34;http://www.golang.org/pkg/text/template/&#34;&gt;Go模版&lt;/a&gt;，它从两个目录搜索模版：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用的views目录（以及所有的子文件夹）。&lt;/li&gt;&#xA;&lt;li&gt;Revel自己的templates目录。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Revel提供了错误页面的模版（在开发模式下显示友好的编译错误），不过应用需要创建一个同名的模版来重写它们，比如app/views/errors/500.html。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;render-context&#34; href=&#34;#render-context&#34;&gt;&lt;/a&gt;Render Context&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Revel使用RenderArgs数据映射表来执行模版。除应用提供的数据以外，Revel还提供以下两项：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;“errors”——通过&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/validation.html#Validation.ErrorMap&#34;&gt;Validation.ErrorMap&lt;/a&gt;返回的map。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;“flash”——通过之前的请求闪存的数据。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;模版函数&#34; href=&#34;#模版函数&#34;&gt;&lt;/a&gt;模版函数&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Go提供&lt;a href=&#34;http://www.golang.org/pkg/text/template/#Functions&#34;&gt;一些在你的模版中使用的函数&lt;/a&gt;。Revel增加了一些。阅读下面的文档，或者&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/template.html#variables&#34;&gt;查看它们的源代码&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;eq&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;简单地测试“a == b”。&lt;br /&gt;&#xA;示例：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;ldquo;message you&amp;rdquo;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;set&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在给定的Context中设置一个变量。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;&#xA;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;append&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在给定的Context中，向一个数组中添加一个元素，或者创建一个数组。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;link rel=&amp;ldquo;stylesheet&amp;rdquo; type=&amp;ldquo;text/css&amp;rdquo; href=&amp;ldquo;/public/map[site:map[title:Gavin Droider tagline:Gavin&amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] data:map[title:Gavin Droider tagline:Gavin&amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] layouts:map[default:map[_content:0xc2000e3870] page:map[layout:default _content:0xc2000e3930] post:map[layout:default _content:0xc2000e39f0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;lt;nil&amp;gt; _content:0xc2000e3f00 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;lt;nil&amp;gt; _content:0xc2000e3f60 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;lt;nil&amp;gt; _content:0xc2000e3fc0 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:&amp;lt;nil&amp;gt; _content:0xc20011a060 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;lt;nil&amp;gt; _content:0xc20011a0c0 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;lt;nil&amp;gt; _content:0xc20011a120 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\android-bound-service.md:map[title:Android之Bound Service date:2013-03-10 00:35:09 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc20011a5d0 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-bound-service.html tags:[Android Bound Service] id:posts\android-bound-service.md _date:2013-03-10 00:35:09 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-bound-service.html] posts\android-lint-list-1.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-lint-list-1.html tags:[Android lint] id:posts\android-lint-list-1.md _date:2013-05-11 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-lint-list-1.html title:android工具之lint检测列表(一) date:2013-05-11 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc2000e3e10 layout:post] posts\golang-tour-2.md:map[title:Go语言之旅——基本概念（二） date:2013-04-17 14:24:37 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2390 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-2.html tags:[golang] id:posts\golang-tour-2.md _date:2013-04-17 14:24:37 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-2.html] posts\interrupt-thread.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/interrupt-thread.html tags:[Java 中断线程] id:posts\interrupt-thread.md _date:2013-02-28 10:26:32 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/interrupt-thread.html title:中断线程 date:2013-02-28 10:26:32 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc2001a2ab0 layout:post] posts\java-lang-thread.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/java-lang-thread.html tags:[Java Thread] id:posts\java-lang-thread.md _date:2013-02-28 10:14:07 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/java-lang-thread.html title:java.lang.Thread date:2013-02-28 10:14:07 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc20011a330 layout:post] posts\revel-concepts.md:map[title:Revel框架——基本概念 date:2013-05-12 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc20011af60 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-concepts.html tags:[Go revel] id:posts\revel-concepts.md _date:2013-05-12 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-concepts.html] posts\thread-sync.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/thread-sync.html tags:[Java 线程同步] id:posts\thread-sync.md _date:2013-02-28 11:05:44 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/thread-sync.html title:线程同步 date:2013-02-28 11:05:44 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc2001b42d0 layout:post] posts\revel-manual.md:map[title:Revel开发手册 date:2013-04-23 22:57:15 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2000e3660 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-manual.html tags:[Go revel] id:posts\revel-manual.md _date:2013-04-23 22:57:15 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-manual.html] posts\how-are-android-touch-events-delivered.md:map[permalink:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/how-are-android-touch-events-delivered.html tags:[Android onTouch事件 view] id:posts\how-are-android-touch-events-delivered.md _date:2013-02-27 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/how-are-android-touch-events-delivered.html date:2013-02-27 description:&amp;lt;nil&amp;gt; title:Android中view的Touch事件传递顺序 categories:[Android 源码分析] _content:0xc2001a2900 layout:post] posts\java-lang-void.md:map[title:java.lang.Void类 date:2013-02-28 10:06:39 description:&amp;lt;nil&amp;gt; categories:[Java] _content:0xc20011a690 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/java-lang-void.html tags:[Java Void] id:posts\java-lang-void.md _date:2013-02-28 10:06:39 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/java-lang-void.html] posts\android-lint.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-lint.html tags:[Android lint] id:posts\android-lint.md _date:2013-03-14 22:49:13 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-lint.html title:android之lint date:2013-03-14 22:49:13 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc2000b5e70 layout:post] posts\android-processes-and_threads.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-processes-and_threads.html tags:[Android Process Thread] id:posts\android-processes-and_threads.md _date:2013-03-11 17:40:19 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-processes-and_threads.html title:Android之进程和线程 date:2013-03-11 17:40:19 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc20011a570 layout:post] posts\golang-tour-1.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-1.html tags:[Go tour] id:posts\golang-tour-1.md _date:2013-04-16 22:52:51 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-1.html title:Go语言之旅——基本概念（一） date:2013-04-16 22:52:51 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a21b0 layout:post] posts\ubuntu-golang-emacs-configuration.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/ubuntu-golang-emacs-configuration.html tags:[emacs Go] id:posts\ubuntu-golang-emacs-configuration.md _date:2013-04-19 23:10:58 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/ubuntu-golang-emacs-configuration.html title:Ubuntu下golang的emacs配置 date:2013-04-19 23:10:58 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001b44b0 layout:post] posts\state-of-thread.md:map[title:线程的状态 date:2013-02-28 10:29:17 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc2001b4060 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/state-of-thread.html tags:[Java 线程状态] id:posts\state-of-thread.md _date:2013-02-28 10:29:17 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/state-of-thread.html] posts\thoughtworks-developer-reading-radar.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/thoughtworks-developer-reading-radar.html id:posts\thoughtworks-developer-reading-radar.md _date:2013-04-22 13:43:19 +0000 UTC tags:[] url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/thoughtworks-developer-reading-radar.html title:[转载 ]] date:2013-04-22 13:43:19 description:&amp;lt;nil&amp;gt; categories:[读书] _content:0xc2001b4120 layout:post] posts\android-intentservice.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-intentservice.html tags:[Android HandlerThread IntentService] id:posts\android-intentservice.md _date:2013-02-28 14:10:33 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-intentservice.html title:android之intentservice date:2013-02-28 14:10:33 description:&amp;lt;nil&amp;gt; categories:[Android 源码分析] _content:0xc2000e3480 layout:post] posts\blocking-queue.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/blocking-queue.html tags:[Java 线程 阻塞队列] id:posts\blocking-queue.md _date:2013-02-28 13:59:39 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/blocking-queue.html title:阻塞队列 date:2013-02-28 13:59:39 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc20011a900 layout:post] posts\gavin-s-ndk.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/gavin-s-ndk.html tags:[ndk] id:posts\gavin-s-ndk.md _date:2013-05-12 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/gavin-s-ndk.html title:新篇章——NDK date:2013-05-12 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc20011aab0 layout:post] posts\golang-stein-gcd.md:map[title:Go——Stein算法求最大公约数 date:2013-04-17 23:28:07 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc20011afc0 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-stein-gcd.html tags:[Go stein] id:posts\golang-stein-gcd.md _date:2013-04-17 23:28:07 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-stein-gcd.html] posts\golang-tour-method-and-interface.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-method-and-interface.html tags:[Go] id:posts\golang-tour-method-and-interface.md _date:2013-04-17 16:51:51 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-method-and-interface.html title:Go语言之旅——方法与接口 date:2013-04-17 16:51:51 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2780 layout:post] posts\revel-results.md:map[title:Revel框架——Result date:2013-04-27 16:00:20 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2150 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-results.html tags:[Go revel] id:posts\revel-results.md _date:2013-04-27 16:00:20 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-results.html] posts\revel-routing.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-routing.html tags:[Go revel] id:posts\revel-routing.md _date:2013-04-24 16:47:50 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-routing.html title:Revel框架——路由 date:2013-04-24 16:47:50 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a23c0 layout:post] posts\revel-sharing-functionality.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-sharing-functionality.html tags:[Go revel] id:posts\revel-sharing-functionality.md _date:2013-04-23 22:37:40 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-sharing-functionality.html title:Revel框架——共享功能 date:2013-04-23 22:37:40 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2c00 layout:post] posts\android-aidl.md:map[title:Android之AIDL date:2013-03-10 19:57:28 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc20011a420 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-aidl.html tags:[AIDL Android] id:posts\android-aidl.md _date:2013-03-10 19:57:28 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/android-aidl.html] posts\android-handler.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-handler.html tags:[Android Handler Looper Message] id:posts\android-handler.md _date:2013-02-28 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-handler.html title:Android之Handler date:2013-02-28 description:&amp;lt;nil&amp;gt; categories:[Android 源码分析] _content:0xc2000e32a0 layout:post] posts\property-of-thread.md:map[title:线程的属性（优先级、守护线程、未捕获异常处理器） date:2013-02-28 10:45:48 description:&amp;lt;nil&amp;gt; categories:[Java 多线程] _content:0xc20011a930 layout:post permalink:property-of-thread.html tags:[Java 守护线程 未捕获异常处理器 线程优先级] id:posts\property-of-thread.md _date:2013-02-28 10:45:48 +0000 UTC url:/property-of-thread.html] posts\revel-organization.md:map[title:Revel框架——结构布局 date:2013-04-23 17:57:39 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2000b5f60 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-organization.html tags:[Go revel] id:posts\revel-organization.md _date:2013-04-23 17:57:39 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-organization.html] posts\revel-session-and-flash.md:map[title:Revel框架——Session域和Flash域 date:2013-04-27 13:47:00 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a26c0 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-session-and-flash.html tags:[Go revel] id:posts\revel-session-and-flash.md _date:2013-04-27 13:47:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-session-and-flash.html] posts\revel-templates.md:map[title:Revel框架之模版（Template） date:2013-05-08 14:28:13 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2ea0 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/revel-templates.html tags:[Go revel] id:posts\revel-templates.md _date:2013-05-08 14:28:13 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/revel-templates.html] posts\android-looper.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-looper.html tags:[Android Handler Looper Message] id:posts\android-looper.md _date:2013-02-28 14:18:11 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-looper.html title:Android之Looper date:2013-02-28 14:18:11 description:&amp;lt;nil&amp;gt; categories:[Android 源码分析] _content:0xc20011a2a0 layout:post] posts\android-service.md:map[title:Android之Service date:2013-03-07 13:02:03 description:&amp;lt;nil&amp;gt; categories:[Android] _content:0xc20011a750 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-service.html tags:[Android Service] id:posts\android-service.md _date:2013-03-07 13:02:03 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;/android-service.html] posts\golang-fibonacci.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-fibonacci.html tags:[fibonacci Go] id:posts\golang-fibonacci.md _date:2013-04-17 22:34:41 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-fibonacci.html title:Go——斐波那契数列 date:2013-04-17 22:34:41 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc20011ad20 layout:post] posts\golang-tour-concurrent.md:map[title:Go语言之旅——并发 date:2013-05-11 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2001a2570 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-concurrent.html tags:[Go goroutine] id:posts\golang-tour-concurrent.md _date:2013-05-11 00:00:00 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/golang-tour-concurrent.html] posts\revel-binding-parameters.md:map[permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-binding-parameters.html tags:[Go revel] id:posts\revel-binding-parameters.md _date:2013-04-24 23:56:25 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/revel-binding-parameters.html title:Revel框架——绑定参数 date:2013-04-24 23:56:25 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc20011aba0 layout:post] posts\revel-interceptors.md:map[title:Revel框架之拦截器 date:2013-05-08 15:16:51 description:&amp;lt;nil&amp;gt; categories:[Go] _content:0xc2000e3330 layout:post permalink:&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/revel-interceptors.html tags:[Go revel] id:posts\revel-interceptors.md _date:2013-05-08 15:16:51 +0000 UTC url:/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/revel-interceptors.html]] tags:map[Looper:0xc200091240 未捕获异常处理器:0xc200091440 IntentService:0xc200150140 goroutine:0xc200091980 golang:0xc200091ac0 Void:0xc200091d80 tour:0xc200091e80 线程:0xc200150180 阻塞队列:0xc200150200 Android:0xc200091140 Message:0xc200091280 Service:0xc2000918c0 线程同步:0xc200091c40 emacs:0xc200091f00 ndk:0xc200150240 Java:0xc2000913c0 中断线程:0xc200091b00 onTouch事件:0xc200091c80 HandlerThread:0xc200150100 守护线程:0xc200091400 lint:0xc200091a80 view:0xc200091cc0 Process:0xc200091e40 stein:0xc200150280 AIDL:0xc2000ebfc0 线程优先级:0xc200091480 Go:0xc200091640 Bound Service:0xc200091a00 Handler:0xc200091200 revel:0xc200091680 fibonacci:0xc200091900 Thread:0xc200091b80 线程状态:0xc200091fc0] categories:map[Android:0xc2000911c0 源码分析:0xc2000912c0 Java:0xc200091500 多线程:0xc200091600 Go:0xc200091700 读书:0xc200150080] chronological:[posts\gavin-s-ndk.md posts\revel-concepts.md posts\golang-tour-concurrent.md posts\android-lint-list-1.md posts\revel-interceptors.md posts\revel-templates.md posts\revel-results.md posts\revel-session-and-flash.md posts\revel-binding-parameters.md posts\revel-routing.md posts\revel-manual.md posts\revel-sharing-functionality.md posts\revel-organization.md posts\thoughtworks-developer-reading-radar.md posts\ubuntu-golang-emacs-configuration.md posts\golang-stein-gcd.md posts\golang-fibonacci.md posts\golang-tour-method-and-interface.md posts\golang-tour-2.md posts\golang-tour-1.md posts\android-lint.md posts\android-processes-and_threads.md posts\android-aidl.md posts\android-bound-service.md posts\android-service.md posts\android-looper.md posts\android-intentservice.md posts\blocking-queue.md posts\thread-sync.md posts\property-of-thread.md posts\state-of-thread.md posts\interrupt-thread.md posts\java-lang-thread.md posts\java-lang-void.md posts\android-handler.md posts\how-are-android-touch-events-delivered.md] collated:[0xc2001b45a0]]]]&amp;ldquo;&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;field&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;输入字段的一个辅助函数：&lt;br /&gt;&#xA;给定一个字段名，它返回一个包含下列成员的结构体：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Id：字段名，转换为适当的HTML元素ID。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Name：字段名。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Value：该字段在当前RenderArgs中的值。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Flash：闪存中该字段的值。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Error：所有与该字段有关的错误信息。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;ErrorClass：如果有错误，则为&amp;rdquo;hasError&amp;rdquo;，否则为&amp;rdquo;&amp;ldquo;；&#xA;&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/field.html&#34;&gt;查看文档&lt;/a&gt;。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;&#xA;&amp;lt;p class=&amp;ldquo;&amp;rdquo;&amp;gt;&#xA;    &amp;lt;strong&amp;gt;Check In Date:&amp;lt;/strong&amp;gt;&#xA;    &amp;lt;input type=&amp;ldquo;text&amp;rdquo; size=&amp;ldquo;10&amp;rdquo; name=&amp;ldquo;&amp;rdquo; class=&amp;ldquo;datepicker&amp;rdquo; value=&amp;ldquo;&amp;rdquo; &amp;gt;&#xA;    * &amp;lt;span class=&amp;ldquo;error&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&#xA;&amp;lt;/p&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;option&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;结合字段助手，协助构建HTML option元素。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;&#xA;&amp;lt;select name=&amp;ldquo;&amp;rdquo;&amp;gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;/select&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;radio&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;结合字段助手，协助构建HTML单选输入元素。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;&#xA;     Smoking&#xA;     Non smoking&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;nl2br&#34; href=&#34;#nl2br&#34;&gt;&lt;/a&gt;nl2br&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;换行转换为HTML断行。&lt;br /&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;You said:&#xA;&amp;lt;div class=&amp;ldquo;comment&amp;rdquo;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;pluralize&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;辅助输入正确的单词复数。&lt;br /&gt;&#xA;示例：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;There are  comment&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;including&#34; href=&#34;#including&#34;&gt;&lt;/a&gt;Including&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Go模版允许包含模版，例如：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&#xA;这里需要注意两点：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;路径相对于app/views。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;所有被包含的模版必须放在根目录下（app/views），这是一个（希望是暂时的）限制。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;提示&#34; href=&#34;#提示&#34;&gt;&lt;/a&gt;提示&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;示例应用包括Revel都试图示范有效地利用Go模版。详情请参考：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;revel/samples/booking/app/views/header.html&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;revel/samples/booking/app/views/Hotels/Book.html&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;模版自身可以利用辅助函数设置title和外部的样式。&lt;br /&gt;&#xA;例如，header可以像下面这样：&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xA;    &amp;lt;head&amp;gt;&#xA;        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&#xA;        &amp;lt;meta http-equiv=&amp;ldquo;Content-Type&amp;rdquo; content=&amp;ldquo;text/html; charset=utf-8&amp;rdquo;&amp;gt;&#xA;        &amp;lt;link rel=&amp;ldquo;stylesheet&amp;rdquo; type=&amp;ldquo;text/css&amp;rdquo; media=&amp;ldquo;screen&amp;rdquo; href=&amp;ldquo;/public/css/main.css&amp;rdquo;&amp;gt;&#xA;        &amp;lt;link rel=&amp;ldquo;shortcut icon&amp;rdquo; type=&amp;ldquo;image/png&amp;rdquo; href=&amp;ldquo;/public/img/favicon.png&amp;rdquo;&amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        &amp;amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;/public/map[site:map[title:Gavin Droider tagline:Gavin&amp;amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] data:map[title:Gavin Droider tagline:Gavin&amp;amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] layouts:map[default:map[_content:0xc2000e3870] page:map[layout:default _content:0xc2000e3930] post:map[layout:default _content:0xc2000e39f0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3f00 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3f60 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3fc0 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a060 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a0c0 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a120 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\android-bound-service.md:map[title:Android之Bound Service date:2013-03-10 00:35:09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a5d0 layout:post permalink:2013/03/android-bound-service.html tags:[Android Bound Service] id:posts\android-bound-service.md _date:2013-03-10 00:35:09 +0000 UTC url:/2013/03/android-bound-service.html] posts\android-lint-list-1.md:map[permalink:2013/03/android-lint-list-1.html tags:[Android lint] id:posts\android-lint-list-1.md _date:2013-05-11 00:00:00 +0000 UTC url:/2013/03/android-lint-list-1.html title:android工具之lint检测列表(一) date:2013-05-11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc2000e3e10 layout:post] posts\golang-tour-2.md:map[permalink:2013/04/golang-tour-2.html tags:[golang] id:posts\golang-tour-2.md _date:2013-04-17 14:24:37 +0000 UTC url:/2013/04/golang-tour-2.html title:Go语言之旅——基本概念（二） date:2013-04-17 14:24:37 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2390 layout:post] posts\interrupt-thread.md:map[title:中断线程 date:2013-02-28 10:26:32 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001a2ab0 layout:post permalink:2013/02/interrupt-thread.html tags:[Java 中断线程] id:posts\interrupt-thread.md _date:2013-02-28 10:26:32 +0000 UTC url:/2013/02/interrupt-thread.html] posts\java-lang-thread.md:map[permalink:2013/02/java-lang-thread.html tags:[Java Thread] id:posts\java-lang-thread.md _date:2013-02-28 10:14:07 +0000 UTC url:/2013/02/java-lang-thread.html title:java.lang.Thread date:2013-02-28 10:14:07 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a330 layout:post] posts\revel-concepts.md:map[permalink:2013/04/revel-concepts.html tags:[Go revel] id:posts\revel-concepts.md _date:2013-05-12 00:00:00 +0000 UTC url:/2013/04/revel-concepts.html title:Revel框架——基本概念 date:2013-05-12 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011af60 layout:post] posts\thread-sync.md:map[title:线程同步 date:2013-02-28 11:05:44 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001b42d0 layout:post permalink:2013/02/thread-sync.html tags:[Java 线程同步] id:posts\thread-sync.md _date:2013-02-28 11:05:44 +0000 UTC url:/2013/02/thread-sync.html] posts\revel-manual.md:map[permalink:2013/04/revel-manual.html tags:[Go revel] id:posts\revel-manual.md _date:2013-04-23 22:57:15 +0000 UTC url:/2013/04/revel-manual.html title:Revel开发手册 date:2013-04-23 22:57:15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000e3660 layout:post] posts\how-are-android-touch-events-delivered.md:map[date:2013-02-27 description:&amp;amp;lt;nil&amp;amp;gt; title:Android中view的Touch事件传递顺序 categories:[Android 源码分析] _content:0xc2001a2900 layout:post permalink:/2013/02/how-are-android-touch-events-delivered.html tags:[Android onTouch事件 view] id:posts\how-are-android-touch-events-delivered.md _date:2013-02-27 00:00:00 +0000 UTC url:/2013/02/how-are-android-touch-events-delivered.html] posts\java-lang-void.md:map[title:java.lang.Void类 date:2013-02-28 10:06:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java] _content:0xc20011a690 layout:post permalink:2013/02/java-lang-void.html tags:[Java Void] id:posts\java-lang-void.md _date:2013-02-28 10:06:39 +0000 UTC url:/2013/02/java-lang-void.html] posts\android-lint.md:map[title:android之lint date:2013-03-14 22:49:13 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc2000b5e70 layout:post permalink:2013/03/android-lint.html tags:[Android lint] id:posts\android-lint.md _date:2013-03-14 22:49:13 +0000 UTC url:/2013/03/android-lint.html] posts\android-processes-and_threads.md:map[title:Android之进程和线程 date:2013-03-11 17:40:19 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a570 layout:post permalink:2013/03/android-processes-and_threads.html tags:[Android Process Thread] id:posts\android-processes-and_threads.md _date:2013-03-11 17:40:19 +0000 UTC url:/2013/03/android-processes-and_threads.html] posts\golang-tour-1.md:map[permalink:2013/04/golang-tour-1.html tags:[Go tour] id:posts\golang-tour-1.md _date:2013-04-16 22:52:51 +0000 UTC url:/2013/04/golang-tour-1.html title:Go语言之旅——基本概念（一） date:2013-04-16 22:52:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a21b0 layout:post] posts\ubuntu-golang-emacs-configuration.md:map[permalink:2013/04/ubuntu-golang-emacs-configuration.html tags:[emacs Go] id:posts\ubuntu-golang-emacs-configuration.md _date:2013-04-19 23:10:58 +0000 UTC url:/2013/04/ubuntu-golang-emacs-configuration.html title:Ubuntu下golang的emacs配置 date:2013-04-19 23:10:58 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001b44b0 layout:post] posts\state-of-thread.md:map[title:线程的状态 date:2013-02-28 10:29:17 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001b4060 layout:post permalink:2013/02/state-of-thread.html tags:[Java 线程状态] id:posts\state-of-thread.md _date:2013-02-28 10:29:17 +0000 UTC url:/2013/02/state-of-thread.html] posts\thoughtworks-developer-reading-radar.md:map[permalink:2013/04/thoughtworks-developer-reading-radar.html id:posts\thoughtworks-developer-reading-radar.md _date:2013-04-22 13:43:19 +0000 UTC tags:[] url:/2013/04/thoughtworks-developer-reading-radar.html title:[转载 ]] date:2013-04-22 13:43:19 description:&amp;amp;lt;nil&amp;amp;gt; categories:[读书] _content:0xc2001b4120 layout:post] posts\android-intentservice.md:map[permalink:2013/02/android-intentservice.html tags:[Android HandlerThread IntentService] id:posts\android-intentservice.md _date:2013-02-28 14:10:33 +0000 UTC url:/2013/02/android-intentservice.html title:android之intentservice date:2013-02-28 14:10:33 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc2000e3480 layout:post] posts\blocking-queue.md:map[permalink:2013/02/blocking-queue.html tags:[Java 线程 阻塞队列] id:posts\blocking-queue.md _date:2013-02-28 13:59:39 +0000 UTC url:/2013/02/blocking-queue.html title:阻塞队列 date:2013-02-28 13:59:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a900 layout:post] posts\gavin-s-ndk.md:map[title:新篇章——NDK date:2013-05-12 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011aab0 layout:post permalink:2013/04/gavin-s-ndk.html tags:[ndk] id:posts\gavin-s-ndk.md _date:2013-05-12 00:00:00 +0000 UTC url:/2013/04/gavin-s-ndk.html] posts\golang-stein-gcd.md:map[permalink:2013/04/golang-stein-gcd.html tags:[Go stein] id:posts\golang-stein-gcd.md _date:2013-04-17 23:28:07 +0000 UTC url:/2013/04/golang-stein-gcd.html title:Go——Stein算法求最大公约数 date:2013-04-17 23:28:07 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011afc0 layout:post] posts\golang-tour-method-and-interface.md:map[title:Go语言之旅——方法与接口 date:2013-04-17 16:51:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2780 layout:post permalink:2013/04/golang-tour-method-and-interface.html tags:[Go] id:posts\golang-tour-method-and-interface.md _date:2013-04-17 16:51:51 +0000 UTC url:/2013/04/golang-tour-method-and-interface.html] posts\revel-results.md:map[title:Revel框架——Result date:2013-04-27 16:00:20 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2150 layout:post permalink:2013/04/revel-results.html tags:[Go revel] id:posts\revel-results.md _date:2013-04-27 16:00:20 +0000 UTC url:/2013/04/revel-results.html] posts\revel-routing.md:map[permalink:2013/04/revel-routing.html tags:[Go revel] id:posts\revel-routing.md _date:2013-04-24 16:47:50 +0000 UTC url:/2013/04/revel-routing.html title:Revel框架——路由 date:2013-04-24 16:47:50 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a23c0 layout:post] posts\revel-sharing-functionality.md:map[title:Revel框架——共享功能 date:2013-04-23 22:37:40 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2c00 layout:post permalink:2013/04/revel-sharing-functionality.html tags:[Go revel] id:posts\revel-sharing-functionality.md _date:2013-04-23 22:37:40 +0000 UTC url:/2013/04/revel-sharing-functionality.html] posts\android-aidl.md:map[permalink:2013/03/android-aidl.html tags:[AIDL Android] id:posts\android-aidl.md _date:2013-03-10 19:57:28 +0000 UTC url:/2013/03/android-aidl.html title:Android之AIDL date:2013-03-10 19:57:28 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a420 layout:post] posts\android-handler.md:map[permalink:2013/02/android-handler.html tags:[Android Handler Looper Message] id:posts\android-handler.md _date:2013-02-28 00:00:00 +0000 UTC url:/2013/02/android-handler.html title:Android之Handler date:2013-02-28 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc2000e32a0 layout:post] posts\property-of-thread.md:map[title:线程的属性（优先级、守护线程、未捕获异常处理器） date:2013-02-28 10:45:48 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a930 layout:post permalink:property-of-thread.html tags:[Java 守护线程 未捕获异常处理器 线程优先级] id:posts\property-of-thread.md _date:2013-02-28 10:45:48 +0000 UTC url:/property-of-thread.html] posts\revel-organization.md:map[permalink:2013/04/revel-organization.html tags:[Go revel] id:posts\revel-organization.md _date:2013-04-23 17:57:39 +0000 UTC url:/2013/04/revel-organization.html title:Revel框架——结构布局 date:2013-04-23 17:57:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000b5f60 layout:post] posts\revel-session-and-flash.md:map[permalink:2013/04/revel-session-and-flash.html tags:[Go revel] id:posts\revel-session-and-flash.md _date:2013-04-27 13:47:00 +0000 UTC url:/2013/04/revel-session-and-flash.html title:Revel框架——Session域和Flash域 date:2013-04-27 13:47:00 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a26c0 layout:post] posts\revel-templates.md:map[title:Revel框架之模版（Template） date:2013-05-08 14:28:13 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2ea0 layout:post permalink:2013/05/revel-templates.html tags:[Go revel] id:posts\revel-templates.md _date:2013-05-08 14:28:13 +0000 UTC url:/2013/05/revel-templates.html] posts\android-looper.md:map[permalink:2013/02/android-looper.html tags:[Android Handler Looper Message] id:posts\android-looper.md _date:2013-02-28 14:18:11 +0000 UTC url:/2013/02/android-looper.html title:Android之Looper date:2013-02-28 14:18:11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc20011a2a0 layout:post] posts\android-service.md:map[title:Android之Service date:2013-03-07 13:02:03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a750 layout:post permalink:2013/02/android-service.html tags:[Android Service] id:posts\android-service.md _date:2013-03-07 13:02:03 +0000 UTC url:/2013/02/android-service.html] posts\golang-fibonacci.md:map[permalink:2013/04/golang-fibonacci.html tags:[fibonacci Go] id:posts\golang-fibonacci.md _date:2013-04-17 22:34:41 +0000 UTC url:/2013/04/golang-fibonacci.html title:Go——斐波那契数列 date:2013-04-17 22:34:41 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011ad20 layout:post] posts\golang-tour-concurrent.md:map[title:Go语言之旅——并发 date:2013-05-11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2570 layout:post permalink:2013/04/golang-tour-concurrent.html tags:[Go goroutine] id:posts\golang-tour-concurrent.md _date:2013-05-11 00:00:00 +0000 UTC url:/2013/04/golang-tour-concurrent.html] posts\revel-binding-parameters.md:map[permalink:2013/04/revel-binding-parameters.html tags:[Go revel] id:posts\revel-binding-parameters.md _date:2013-04-24 23:56:25 +0000 UTC url:/2013/04/revel-binding-parameters.html title:Revel框架——绑定参数 date:2013-04-24 23:56:25 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011aba0 layout:post] posts\revel-interceptors.md:map[title:Revel框架之拦截器 date:2013-05-08 15:16:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000e3330 layout:post permalink:2013/05/revel-interceptors.html tags:[Go revel] id:posts\revel-interceptors.md _date:2013-05-08 15:16:51 +0000 UTC url:/2013/05/revel-interceptors.html]] tags:map[AIDL:0xc2000ebfc0 线程优先级:0xc200091480 Go:0xc200091640 Bound Service:0xc200091a00 Handler:0xc200091200 revel:0xc200091680 fibonacci:0xc200091900 Thread:0xc200091b80 线程状态:0xc200091fc0 Looper:0xc200091240 未捕获异常处理器:0xc200091440 IntentService:0xc200150140 goroutine:0xc200091980 golang:0xc200091ac0 Void:0xc200091d80 tour:0xc200091e80 线程:0xc200150180 阻塞队列:0xc200150200 Android:0xc200091140 Message:0xc200091280 Service:0xc2000918c0 线程同步:0xc200091c40 emacs:0xc200091f00 ndk:0xc200150240 Java:0xc2000913c0 中断线程:0xc200091b00 onTouch事件:0xc200091c80 HandlerThread:0xc200150100 守护线程:0xc200091400 lint:0xc200091a80 view:0xc200091cc0 Process:0xc200091e40 stein:0xc200150280] categories:map[Android:0xc2000911c0 源码分析:0xc2000912c0 Java:0xc200091500 多线程:0xc200091600 Go:0xc200091700 读书:0xc200150080] chronological:[posts\gavin-s-ndk.md posts\revel-concepts.md posts\golang-tour-concurrent.md posts\android-lint-list-1.md posts\revel-interceptors.md posts\revel-templates.md posts\revel-results.md posts\revel-session-and-flash.md posts\revel-binding-parameters.md posts\revel-routing.md posts\revel-manual.md posts\revel-sharing-functionality.md posts\revel-organization.md posts\thoughtworks-developer-reading-radar.md posts\ubuntu-golang-emacs-configuration.md posts\golang-stein-gcd.md posts\golang-fibonacci.md posts\golang-tour-method-and-interface.md posts\golang-tour-2.md posts\golang-tour-1.md posts\android-lint.md posts\android-processes-and_threads.md posts\android-aidl.md posts\android-bound-service.md posts\android-service.md posts\android-looper.md posts\android-intentservice.md posts\blocking-queue.md posts\thread-sync.md posts\property-of-thread.md posts\state-of-thread.md posts\interrupt-thread.md posts\java-lang-thread.md posts\java-lang-void.md posts\android-handler.md posts\how-are-android-touch-events-delivered.md] collated:[0xc2001b45a0]]]]&amp;quot;&amp;gt;&#xA;&#xA;    &amp;amp;lt;script src=&amp;quot;/public/js/jquery-1.3.2.min.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;amp;lt;/script&amp;gt;&#xA;    &amp;amp;lt;script src=&amp;quot;/public/js/sessvars.js&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;amp;lt;/script&amp;gt;&#xA;&#xA;        &amp;amp;lt;script src=&amp;quot;/public/map[site:map[title:Gavin Droider tagline:Gavin&amp;amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] data:map[title:Gavin Droider tagline:Gavin&amp;amp;#39;s Blog author:map[name:Gao Xu email:blackdoor@yeah.net github:gavin1989 twitter:LaotouIChouchou feedburner:gavin.fleischer@gmail.com] navigation:[archive.html tags.html categories.html pages.html about.md] config:map[RuhohSpec:1 theme:twitter production_url:http://gavin1989.github.io posts:map[permalink:/:categories/:title/ summary_lines:20 latest:10 layout:post exclude:] pages:map[permalink:pretty layout:page exclude:]]] layouts:map[default:map[_content:0xc2000e3870] page:map[layout:default _content:0xc2000e3930] post:map[layout:default _content:0xc2000e39f0]] theme:map[stylesheets:map[default:[bootstrap.min.css style.css] widgets:map[google_prettify:twitter-bootstrap.css]] javascripts:map[default:[]] manifest:map[author:Jacob Thornton and Mark Otto website:http://twitter.github.com/bootstrap]] urls:map[media:/assets/media theme:/assets/twitter theme_media:/assets/twitter/media theme_javascripts:/assets/twitter/javascripts theme_stylesheets:/assets/twitter/stylesheets base_path:/] db:map[pages:map[about.md:map[title:About Me description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3f00 id:about.md layout:page permalink:pretty url:/about] archive.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3f60 id:archive.html layout:page permalink:pretty title:Archive url:/archive] categories.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc2000e3fc0 id:categories.html layout:page permalink:pretty title:Categories url:/categories] index.html:map[title:首页 description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a060 id:index.html layout:page permalink:pretty url:/] pages.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a0c0 id:pages.html layout:page permalink:pretty title:Pages url:/pages] tags.html:map[description:&amp;amp;lt;nil&amp;amp;gt; _content:0xc20011a120 id:tags.html layout:page permalink:pretty title:Tags url:/tags]] navigation:[archive.html tags.html categories.html pages.html about.md] posts:map[dictionary:map[posts\revel-manual.md:map[title:Revel开发手册 date:2013-04-23 22:57:15 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000e3660 layout:post permalink:2013/04/revel-manual.html tags:[Go revel] id:posts\revel-manual.md _date:2013-04-23 22:57:15 +0000 UTC url:/2013/04/revel-manual.html] posts\how-are-android-touch-events-delivered.md:map[date:2013-02-27 description:&amp;amp;lt;nil&amp;amp;gt; title:Android中view的Touch事件传递顺序 categories:[Android 源码分析] _content:0xc2001a2900 layout:post permalink:/2013/02/how-are-android-touch-events-delivered.html tags:[Android onTouch事件 view] id:posts\how-are-android-touch-events-delivered.md _date:2013-02-27 00:00:00 +0000 UTC url:/2013/02/how-are-android-touch-events-delivered.html] posts\java-lang-void.md:map[permalink:2013/02/java-lang-void.html tags:[Java Void] id:posts\java-lang-void.md _date:2013-02-28 10:06:39 +0000 UTC url:/2013/02/java-lang-void.html title:java.lang.Void类 date:2013-02-28 10:06:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java] _content:0xc20011a690 layout:post] posts\android-lint.md:map[title:android之lint date:2013-03-14 22:49:13 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc2000b5e70 layout:post permalink:2013/03/android-lint.html tags:[Android lint] id:posts\android-lint.md _date:2013-03-14 22:49:13 +0000 UTC url:/2013/03/android-lint.html] posts\android-processes-and_threads.md:map[title:Android之进程和线程 date:2013-03-11 17:40:19 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a570 layout:post permalink:2013/03/android-processes-and_threads.html tags:[Android Process Thread] id:posts\android-processes-and_threads.md _date:2013-03-11 17:40:19 +0000 UTC url:/2013/03/android-processes-and_threads.html] posts\golang-tour-1.md:map[permalink:2013/04/golang-tour-1.html tags:[Go tour] id:posts\golang-tour-1.md _date:2013-04-16 22:52:51 +0000 UTC url:/2013/04/golang-tour-1.html title:Go语言之旅——基本概念（一） date:2013-04-16 22:52:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a21b0 layout:post] posts\ubuntu-golang-emacs-configuration.md:map[title:Ubuntu下golang的emacs配置 date:2013-04-19 23:10:58 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001b44b0 layout:post permalink:2013/04/ubuntu-golang-emacs-configuration.html tags:[emacs Go] id:posts\ubuntu-golang-emacs-configuration.md _date:2013-04-19 23:10:58 +0000 UTC url:/2013/04/ubuntu-golang-emacs-configuration.html] posts\state-of-thread.md:map[title:线程的状态 date:2013-02-28 10:29:17 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001b4060 layout:post permalink:2013/02/state-of-thread.html tags:[Java 线程状态] id:posts\state-of-thread.md _date:2013-02-28 10:29:17 +0000 UTC url:/2013/02/state-of-thread.html] posts\thoughtworks-developer-reading-radar.md:map[title:[转载 ]] date:2013-04-22 13:43:19 description:&amp;amp;lt;nil&amp;amp;gt; categories:[读书] _content:0xc2001b4120 layout:post permalink:2013/04/thoughtworks-developer-reading-radar.html id:posts\thoughtworks-developer-reading-radar.md _date:2013-04-22 13:43:19 +0000 UTC tags:[] url:/2013/04/thoughtworks-developer-reading-radar.html] posts\android-intentservice.md:map[title:android之intentservice date:2013-02-28 14:10:33 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc2000e3480 layout:post permalink:2013/02/android-intentservice.html tags:[Android HandlerThread IntentService] id:posts\android-intentservice.md _date:2013-02-28 14:10:33 +0000 UTC url:/2013/02/android-intentservice.html] posts\blocking-queue.md:map[permalink:2013/02/blocking-queue.html tags:[Java 线程 阻塞队列] id:posts\blocking-queue.md _date:2013-02-28 13:59:39 +0000 UTC url:/2013/02/blocking-queue.html title:阻塞队列 date:2013-02-28 13:59:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a900 layout:post] posts\gavin-s-ndk.md:map[permalink:2013/04/gavin-s-ndk.html tags:[ndk] id:posts\gavin-s-ndk.md _date:2013-05-12 00:00:00 +0000 UTC url:/2013/04/gavin-s-ndk.html title:新篇章——NDK date:2013-05-12 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011aab0 layout:post] posts\golang-stein-gcd.md:map[title:Go——Stein算法求最大公约数 date:2013-04-17 23:28:07 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011afc0 layout:post permalink:2013/04/golang-stein-gcd.html tags:[Go stein] id:posts\golang-stein-gcd.md _date:2013-04-17 23:28:07 +0000 UTC url:/2013/04/golang-stein-gcd.html] posts\golang-tour-method-and-interface.md:map[title:Go语言之旅——方法与接口 date:2013-04-17 16:51:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2780 layout:post permalink:2013/04/golang-tour-method-and-interface.html tags:[Go] id:posts\golang-tour-method-and-interface.md _date:2013-04-17 16:51:51 +0000 UTC url:/2013/04/golang-tour-method-and-interface.html] posts\revel-results.md:map[title:Revel框架——Result date:2013-04-27 16:00:20 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2150 layout:post permalink:2013/04/revel-results.html tags:[Go revel] id:posts\revel-results.md _date:2013-04-27 16:00:20 +0000 UTC url:/2013/04/revel-results.html] posts\revel-routing.md:map[title:Revel框架——路由 date:2013-04-24 16:47:50 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a23c0 layout:post permalink:2013/04/revel-routing.html tags:[Go revel] id:posts\revel-routing.md _date:2013-04-24 16:47:50 +0000 UTC url:/2013/04/revel-routing.html] posts\revel-sharing-functionality.md:map[permalink:2013/04/revel-sharing-functionality.html tags:[Go revel] id:posts\revel-sharing-functionality.md _date:2013-04-23 22:37:40 +0000 UTC url:/2013/04/revel-sharing-functionality.html title:Revel框架——共享功能 date:2013-04-23 22:37:40 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2c00 layout:post] posts\android-aidl.md:map[permalink:2013/03/android-aidl.html tags:[AIDL Android] id:posts\android-aidl.md _date:2013-03-10 19:57:28 +0000 UTC url:/2013/03/android-aidl.html title:Android之AIDL date:2013-03-10 19:57:28 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a420 layout:post] posts\android-handler.md:map[permalink:2013/02/android-handler.html tags:[Android Handler Looper Message] id:posts\android-handler.md _date:2013-02-28 00:00:00 +0000 UTC url:/2013/02/android-handler.html title:Android之Handler date:2013-02-28 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc2000e32a0 layout:post] posts\property-of-thread.md:map[permalink:property-of-thread.html tags:[Java 守护线程 未捕获异常处理器 线程优先级] id:posts\property-of-thread.md _date:2013-02-28 10:45:48 +0000 UTC url:/property-of-thread.html title:线程的属性（优先级、守护线程、未捕获异常处理器） date:2013-02-28 10:45:48 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a930 layout:post] posts\revel-organization.md:map[title:Revel框架——结构布局 date:2013-04-23 17:57:39 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000b5f60 layout:post permalink:2013/04/revel-organization.html tags:[Go revel] id:posts\revel-organization.md _date:2013-04-23 17:57:39 +0000 UTC url:/2013/04/revel-organization.html] posts\revel-session-and-flash.md:map[permalink:2013/04/revel-session-and-flash.html tags:[Go revel] id:posts\revel-session-and-flash.md _date:2013-04-27 13:47:00 +0000 UTC url:/2013/04/revel-session-and-flash.html title:Revel框架——Session域和Flash域 date:2013-04-27 13:47:00 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a26c0 layout:post] posts\revel-templates.md:map[title:Revel框架之模版（Template） date:2013-05-08 14:28:13 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2ea0 layout:post permalink:2013/05/revel-templates.html tags:[Go revel] id:posts\revel-templates.md _date:2013-05-08 14:28:13 +0000 UTC url:/2013/05/revel-templates.html] posts\android-looper.md:map[title:Android之Looper date:2013-02-28 14:18:11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android 源码分析] _content:0xc20011a2a0 layout:post permalink:2013/02/android-looper.html tags:[Android Handler Looper Message] id:posts\android-looper.md _date:2013-02-28 14:18:11 +0000 UTC url:/2013/02/android-looper.html] posts\android-service.md:map[permalink:2013/02/android-service.html tags:[Android Service] id:posts\android-service.md _date:2013-03-07 13:02:03 +0000 UTC url:/2013/02/android-service.html title:Android之Service date:2013-03-07 13:02:03 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a750 layout:post] posts\golang-fibonacci.md:map[permalink:2013/04/golang-fibonacci.html tags:[fibonacci Go] id:posts\golang-fibonacci.md _date:2013-04-17 22:34:41 +0000 UTC url:/2013/04/golang-fibonacci.html title:Go——斐波那契数列 date:2013-04-17 22:34:41 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011ad20 layout:post] posts\golang-tour-concurrent.md:map[title:Go语言之旅——并发 date:2013-05-11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2570 layout:post permalink:2013/04/golang-tour-concurrent.html tags:[Go goroutine] id:posts\golang-tour-concurrent.md _date:2013-05-11 00:00:00 +0000 UTC url:/2013/04/golang-tour-concurrent.html] posts\revel-binding-parameters.md:map[permalink:2013/04/revel-binding-parameters.html tags:[Go revel] id:posts\revel-binding-parameters.md _date:2013-04-24 23:56:25 +0000 UTC url:/2013/04/revel-binding-parameters.html title:Revel框架——绑定参数 date:2013-04-24 23:56:25 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011aba0 layout:post] posts\revel-interceptors.md:map[title:Revel框架之拦截器 date:2013-05-08 15:16:51 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2000e3330 layout:post permalink:2013/05/revel-interceptors.html tags:[Go revel] id:posts\revel-interceptors.md _date:2013-05-08 15:16:51 +0000 UTC url:/2013/05/revel-interceptors.html] posts\android-bound-service.md:map[title:Android之Bound Service date:2013-03-10 00:35:09 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc20011a5d0 layout:post permalink:2013/03/android-bound-service.html tags:[Android Bound Service] id:posts\android-bound-service.md _date:2013-03-10 00:35:09 +0000 UTC url:/2013/03/android-bound-service.html] posts\android-lint-list-1.md:map[permalink:2013/03/android-lint-list-1.html tags:[Android lint] id:posts\android-lint-list-1.md _date:2013-05-11 00:00:00 +0000 UTC url:/2013/03/android-lint-list-1.html title:android工具之lint检测列表(一) date:2013-05-11 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Android] _content:0xc2000e3e10 layout:post] posts\golang-tour-2.md:map[permalink:2013/04/golang-tour-2.html tags:[golang] id:posts\golang-tour-2.md _date:2013-04-17 14:24:37 +0000 UTC url:/2013/04/golang-tour-2.html title:Go语言之旅——基本概念（二） date:2013-04-17 14:24:37 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc2001a2390 layout:post] posts\interrupt-thread.md:map[title:中断线程 date:2013-02-28 10:26:32 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001a2ab0 layout:post permalink:2013/02/interrupt-thread.html tags:[Java 中断线程] id:posts\interrupt-thread.md _date:2013-02-28 10:26:32 +0000 UTC url:/2013/02/interrupt-thread.html] posts\java-lang-thread.md:map[permalink:2013/02/java-lang-thread.html tags:[Java Thread] id:posts\java-lang-thread.md _date:2013-02-28 10:14:07 +0000 UTC url:/2013/02/java-lang-thread.html title:java.lang.Thread date:2013-02-28 10:14:07 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc20011a330 layout:post] posts\revel-concepts.md:map[permalink:2013/04/revel-concepts.html tags:[Go revel] id:posts\revel-concepts.md _date:2013-05-12 00:00:00 +0000 UTC url:/2013/04/revel-concepts.html title:Revel框架——基本概念 date:2013-05-12 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Go] _content:0xc20011af60 layout:post] posts\thread-sync.md:map[permalink:2013/02/thread-sync.html tags:[Java 线程同步] id:posts\thread-sync.md _date:2013-02-28 11:05:44 +0000 UTC url:/2013/02/thread-sync.html title:线程同步 date:2013-02-28 11:05:44 description:&amp;amp;lt;nil&amp;amp;gt; categories:[Java 多线程] _content:0xc2001b42d0 layout:post]] tags:map[Android:0xc200091140 Message:0xc200091280 Service:0xc2000918c0 线程同步:0xc200091c40 emacs:0xc200091f00 ndk:0xc200150240 Java:0xc2000913c0 中断线程:0xc200091b00 onTouch事件:0xc200091c80 HandlerThread:0xc200150100 守护线程:0xc200091400 lint:0xc200091a80 view:0xc200091cc0 Process:0xc200091e40 stein:0xc200150280 AIDL:0xc2000ebfc0 线程优先级:0xc200091480 Go:0xc200091640 Bound Service:0xc200091a00 Handler:0xc200091200 revel:0xc200091680 fibonacci:0xc200091900 Thread:0xc200091b80 线程状态:0xc200091fc0 Looper:0xc200091240 未捕获异常处理器:0xc200091440 IntentService:0xc200150140 goroutine:0xc200091980 golang:0xc200091ac0 Void:0xc200091d80 tour:0xc200091e80 线程:0xc200150180 阻塞队列:0xc200150200] categories:map[Android:0xc2000911c0 源码分析:0xc2000912c0 Java:0xc200091500 多线程:0xc200091600 Go:0xc200091700 读书:0xc200150080] chronological:[posts\gavin-s-ndk.md posts\revel-concepts.md posts\golang-tour-concurrent.md posts\android-lint-list-1.md posts\revel-interceptors.md posts\revel-templates.md posts\revel-results.md posts\revel-session-and-flash.md posts\revel-binding-parameters.md posts\revel-routing.md posts\revel-manual.md posts\revel-sharing-functionality.md posts\revel-organization.md posts\thoughtworks-developer-reading-radar.md posts\ubuntu-golang-emacs-configuration.md posts\golang-stein-gcd.md posts\golang-fibonacci.md posts\golang-tour-method-and-interface.md posts\golang-tour-2.md posts\golang-tour-1.md posts\android-lint.md posts\android-processes-and_threads.md posts\android-aidl.md posts\android-bound-service.md posts\android-service.md posts\android-looper.md posts\android-intentservice.md posts\blocking-queue.md posts\thread-sync.md posts\property-of-thread.md posts\state-of-thread.md posts\interrupt-thread.md posts\java-lang-thread.md posts\java-lang-void.md posts\android-handler.md posts\how-are-android-touch-events-delivered.md] collated:[0xc2001b45a0]]]]&amp;quot; type=&amp;quot;text/javascript&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;amp;lt;/script&amp;gt;&#xA;&#xA;&amp;amp;lt;/head&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;并且包含它的模版像下面这样：&#xA;&lt;pre&gt;&lt;code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;自定义函数&#34; href=&#34;#自定义函数&#34;&gt;&lt;/a&gt;自定义函数&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;应用可以注册在模版中使用的自定义函数。&lt;br /&gt;&#xA;这里有一个例子：&#xA;&lt;pre&gt;&lt;code&gt;func init() {&#xA;    revel.TemplateFuncs[&amp;ldquo;eq&amp;rdquo;] = func(a, b interface{}) bool { return a == b }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——Result</title>
      <link>http://gavin1989.github.io/2013/04/revel-results.html</link>
      <pubDate>2013-04-27 04:00:20 +0800</pubDate>
      <description>&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;results&#34; href=&#34;#results&#34;&gt;&lt;/a&gt;Results&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;action必须返回一个用于处理响应生成的revel.Result。它遵循一个简单的接口：&#xA;&lt;pre&gt;&lt;code&gt;type Result interface {&#xA;    Apply(req *Request, resp *Response)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;revel.Controller提供一些产生Result的方法：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Render，RenderTemplate——渲染模版，传递参数。&lt;/li&gt;&#xA;&lt;li&gt;RenderJson，RenderXml——将一个结构串行化为json或xml。&lt;/li&gt;&#xA;&lt;li&gt;RenderText——返回一个纯文本的响应。&lt;/li&gt;&#xA;&lt;li&gt;Redirect——重定向到另外一个action或URL。&lt;/li&gt;&#xA;&lt;li&gt;RenderFile——返回一个文件，通常为一个被下载的附件。&lt;/li&gt;&#xA;&lt;li&gt;RenderError——返回一个500响应，并且渲染errors/500.html模版。&lt;/li&gt;&#xA;&lt;li&gt;NotFound——返回一个404响应，并且渲染errors/404.html模版。&lt;/li&gt;&#xA;&lt;li&gt;Todo——返回一个存根响应（500）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;另外，开发者可以定义自己的revel.Result并返回。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;设置状态码和内容类型&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;每一个内建的Result都有一个默认的状态码和内容类型。覆盖这些默认值非常简单，只需要在响应中设置它们的属性即可：&#xA;&lt;pre&gt;&lt;code&gt;func (c Application) Action() revel.Result {&#xA;    c.Response.Status = http.StatusTeapot&#xA;    c.Response.ContentType = &amp;ldquo;application/dishware&amp;rdquo;&#xA;    return c.Render()&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;render&#34; href=&#34;#render&#34;&gt;&lt;/a&gt;Render&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在一个action中调用Render（例如“Controller.Action”），mvc.Controller.Render做两件事：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;添加所有的参数到Controller的RenderArgs，使用它们当前的标识符作为key。&lt;/li&gt;&#xA;&lt;li&gt;执行模版“views/Controller/Action.html”，并将Controller的RenderArgs作为数据的映射表传递给模版。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如果不成功（例如它找不到这个模版），它会返回一个替代的ErrorResult： 即允许开发者这样写：&#xA;&lt;pre&gt;&lt;code&gt;func (c MyApp) Action() revel.Result {&#xA;    myValue := calculateValue()&#xA;    return c.Render(myValue)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;并且在他们的模版中使用“myValue”。使用这种方式比构造一个明确的映射表更方便，总之在多数情况下，把将要被处理的数据作为本地变量。&lt;br /&gt;&#xA;&lt;strong&gt;注意：&lt;/strong&gt;Revel在看参数名之前会先根据方法名决定模版的路径。因此，c.Render()只能在Action中调用。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;renderjson-/-renderxml&#34; href=&#34;#renderjson-/-renderxml&#34;&gt;&lt;/a&gt;RenderJson / RenderXml&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;应用可以调用RenderJson或RenderXml并且传递任意的Go类型（通常是一个Struct）。Revel会使用json.Marshal或xml.Marshal将它串行化。 如果app.conf中results.pretty=true，串行化工作将使用MarshalIndent代替，以生成可供人浏览的友好输出。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;redirect&#34; href=&#34;#redirect&#34;&gt;&lt;/a&gt;Redirect&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;有一个助手函数被用来产生重定向。它被用于两种情况：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不带参数重定向到一个Action：&#xA;&lt;pre&gt;&lt;code&gt;return c.Redirect(Hotels.Settings)&lt;/code&gt;&lt;/pre&gt;&#xA;这种形式非常有用，因为它从路由提供了一定程度的安全性和独立性。（它会自动生成URL。）&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;重定向到一个已格式化的string：&#xA;&lt;pre&gt;&lt;code&gt;return c.Redirect(&amp;ldquo;/hotels/%d/settings&amp;rdquo;, hotelId)&lt;/code&gt;&lt;/pre&gt;&#xA;这种形式必须传递参数。&lt;br /&gt;&#xA;它返回一个302（临时重定向）状态码。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;添加你自己的result&#34; href=&#34;#添加你自己的result&#34;&gt;&lt;/a&gt;添加你自己的Result&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这有一个添加一个简单Result的例子：&lt;br /&gt;&#xA;创建这个类型：&#xA;&lt;pre&gt;&lt;code&gt;type Html string&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;func (r Html) Apply(req *Request, resp *Response) {&#xA;    resp.WriteHeader(http.StatusOK, &amp;ldquo;text/html&amp;rdquo;)&#xA;    resp.Out.Write([]byte&amp;reg;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;然后在一个Action中使用它：&#xA;&lt;pre&gt;&lt;code&gt;func (c *Application) Action() revel.Result {&#xA;    return Html(&amp;ldquo;Hello World&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;状态码&#34; href=&#34;#状态码&#34;&gt;&lt;/a&gt;状态码&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;每个Result默认都会设置一个状态码。你可以自己设置一个以覆盖默认的状态码：&#xA;&lt;pre&gt;&lt;code&gt;func (c *Application) CreateEntity() revel.Result {&#xA;    c.Response.Status = 201&#xA;    return c.Render()&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——Session域和Flash域</title>
      <link>http://gavin1989.github.io/2013/04/revel-session-and-flash.html</link>
      <pubDate>2013-04-27 01:47:00 +0800</pubDate>
      <description>&lt;p&gt;##Session / Flash域&#xA;Revel提供两种基于Cookie的存储机制：&#xA;&lt;pre&gt;&lt;code&gt;// 一个已签名的Cookie（从而大小被限制为4kb）。&#xA;// 约束: Key中不能有冒号（:）。&#xA;type Session map[string]string&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Flash表示一个每次请求都会被覆盖的Cookie。&#xA;// 它允许数据每跨一个页面就被存储一次。&#xA;// 它通常被用来实现成功或失败信息。&#xA;// 例如Post/Redirect/Get模式: &lt;a href=&#34;http://en.wikipedia.org/wiki/Post/Redirect/Get&#34;&gt;http://en.wikipedia.org/wiki/Post/Redirect/Get&lt;/a&gt;&#xA;type Flash struct {&#xA;    Data, Out map[string]string&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Session（会话）&#xA;在Revel中，Session的概念是一个string类型的map，存储为加密签名的Cookie。&lt;br /&gt;&#xA;这意味着：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大小被限制为4kb。&lt;/li&gt;&#xA;&lt;li&gt;所有的数据必须被串行化为一个string以用于存储。&lt;/li&gt;&#xA;&lt;li&gt;用户可以查看所有的数据（未加密的），但修改是安全的。&#xA;##Flash&#xA;Flash提供一次性的string存储。它在实现&lt;a href=&#34;http://en.wikipedia.org/wiki/Post/Redirect/Get&#34;&gt;Post/Redirect/Post模式&lt;/a&gt;或短暂的“操作成功！”或“操作失败！”信息时非常有用。&lt;br /&gt;&#xA;下面是这种用法的一个例子：&#xA;&lt;pre&gt;&lt;code&gt;// 显示设置表格&#xA;func (c App) ShowSettings() revel.Result {&#xA;return c.Render()&#xA;}&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;// 处理一个请求&#xA;func (c App) SaveSettings(setting string) revel.Result {&#xA;    c.Validation.Required(setting)&#xA;    if c.Validation.HasErrors() {&#xA;        c.Flash.Error(&amp;ldquo;Settings invalid!&amp;rdquo;)&#xA;        c.Validation.Keep()&#xA;        c.Params.Flash()&#xA;        return c.Redirect(App.ShowSettings)&#xA;    }&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;saveSetting(setting)&#xA;c.Flash.Success(&amp;quot;Settings saved!&amp;quot;)&#xA;return c.Redirect(App.ShowSettings)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;例子的来龙去脉：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户取得一个设置页面。&lt;/li&gt;&#xA;&lt;li&gt;用户提交一个设置（POST方式）&lt;/li&gt;&#xA;&lt;li&gt;应用处理这个请求，保存一个错误或成功信息到flash，并重定向到设置页面（REDIRECT方式）。&lt;/li&gt;&#xA;&lt;li&gt;用户取得设置页面，页面的模版显示flash中的信息。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;它使用了两个便利的函数：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Flash.Success(message string)是Flash.Out[“success”] = message的一个简便写法。&lt;/li&gt;&#xA;&lt;li&gt;Flash.Error(message string)是Flash.Out[&amp;ldquo;error&amp;rdquo;] = message的一个简便写法。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——绑定参数</title>
      <link>http://gavin1989.github.io/2013/04/revel-binding-parameters.html</link>
      <pubDate>2013-04-24 11:56:25 +0800</pubDate>
      <description>&lt;p&gt;##绑定参数&#xA;Revel尝试尽可能地简单地将参数转换为它们期望的Go类型。这种从字符串到其他类型的转换被称为“数据绑定”。&#xA;##参数&#xA;所有的请求参数都被集中在了一个单独的Params对象中。其中包括：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;URL路径参数&lt;/li&gt;&#xA;&lt;li&gt;URL查询参数&lt;/li&gt;&#xA;&lt;li&gt;表格数据（multipart或非multipart）&lt;/li&gt;&#xA;&lt;li&gt;文件上传&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;这里是定义（&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/binder.html&#34;&gt;godoc&lt;/a&gt;）:&#xA;&lt;pre&gt;&lt;code&gt;type Params struct {&#xA;    url.Values&#xA;    Files map[string][]*multipart.FileHeader&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;内嵌的url.Values(&lt;a href=&#34;http://www.golang.org/pkg/net/url/#Values&#34;&gt;godoc&lt;/a&gt;)提供了一个简单值的存取器，但是开发者会发现使用Revel对任意非字符串值的数据绑定机制更简单。&#xA;##Action参数&#xA;参数可以直接被接收为action的方法参数，例如：&#xA;&lt;pre&gt;&lt;code&gt;func (c AppController) Action(name string, ids []int, user User, img []byte) revel.Result {&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在调用action之前，Revel要求它的Binder将这些参数转换为请求的数据类型。如果转换不成功，参数将会被赋予它的类型的零值。&#xA;##Binder&#xA;绑定一个参数到一个数据类型，就要使用Revel的Binder（&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/binder.html&#34;&gt;godoc&lt;/a&gt;）。它像下面例子中展示的那样整合参数对象：&#xA;&lt;pre&gt;&lt;code&gt;func (c SomeController) Action() revel.Result {&#xA;    var ids []int = c.Params.Bind(&amp;ldquo;ids[]&amp;ldquo;, reflect.TypeOf([]int{}))&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;下列的数据类型支持拆箱：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有宽度的int&lt;/li&gt;&#xA;&lt;li&gt;布尔值&lt;/li&gt;&#xA;&lt;li&gt;所有支持类型的指针&lt;/li&gt;&#xA;&lt;li&gt;所有支持类型的切片&lt;/li&gt;&#xA;&lt;li&gt;struct&lt;/li&gt;&#xA;&lt;li&gt;用于日期和时间的time.Time&lt;/li&gt;&#xA;&lt;li&gt;用于文件上传的*os.File,[]byte,io.Reader,io.ReadSeeker&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;下面的部分描述了这些类型的语法。如果需要更多有用的信息，请参阅&lt;a href=&#34;http://robfig.github.io/revel/docs/src/binder.html&#34;&gt;源码&lt;/a&gt;&#xA;###布尔值&#xA;字符串“true”，“on”和“1”都被认为是true。其它绑定的值将是false。&#xA;###Slices&#xA;Revel支持两种绑定Slice的语法：有序的和无序的。&lt;br /&gt;&#xA;&lt;strong&gt;有序的：&lt;/strong&gt;&#xA;&lt;pre&gt;&lt;code&gt;?ids[0]=1&#xA;&amp;amp;ids[1]=2&#xA;&amp;amp;ids[3]=4&lt;/code&gt;&lt;/pre&gt;&#xA;slice中的结果为[]int{1,2,0,4}&lt;br /&gt;&#xA;&lt;strong&gt;无序的：&lt;/strong&gt;&#xA;&lt;pre&gt;&lt;code&gt;?ids[]=1&#xA;&amp;amp;ids[]=2&#xA;&amp;amp;ids[]=3&lt;/code&gt;&lt;/pre&gt;&#xA;slice中的结果为[]int{1,2,3} &lt;strong&gt;注意：&lt;/strong&gt;当绑定一个struct的slice时，应该仅仅使用有序slice：&#xA;&lt;pre&gt;&lt;code&gt;?user[0].Id=1&#xA;&amp;amp;user[0].Name=rob&#xA;&amp;amp;user[1].Id=2&#xA;&amp;amp;user[1].Name=jenny&lt;/code&gt;&lt;/pre&gt;&#xA;###Struct&#xA;使用一个简单的句点（.）来绑定struct：&#xA;&lt;pre&gt;&lt;code&gt;?user.Id=1&#xA;&amp;amp;user.Name=rob&#xA;&amp;amp;user.Friends[]=2&#xA;&amp;amp;user.Friends[]=3&#xA;&amp;amp;user.Father.Id=5&#xA;&amp;amp;user.Father.Name=Hermes&lt;/code&gt;&lt;/pre&gt;&#xA;将要绑定的结构定义为：&#xA;&lt;pre&gt;&lt;code&gt;type User struct {&#xA;    Id int&#xA;    Name string&#xA;    Friends []int&#xA;    Father User&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;strong&gt;注意：&lt;/strong&gt;为了方便绑定，属性必须是可导出的。&#xA;###日期和时间&#xA;内建的日期时间格式为SQL标准时间格式[&amp;ldquo;2006-01-02&amp;rdquo;,&amp;ldquo;2006-01-02 15:04&amp;rdquo;]。&#xA;使用&lt;a href=&#34;http://golang.org/pkg/time/#constants&#34;&gt;官方模式&lt;/a&gt;可以为应用添加更多的格式。简单点的方法是：添加识别模式到TimeFormats变量即可，像这样：&#xA;&lt;pre&gt;&lt;code&gt;func init() {&#xA;    revel.TimeFormats = append(revel.TimeFormats, &amp;ldquo;01/02/2006&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;###文件上传&#xA;文件上传可以绑定到下列任意的类型：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;*os.File&lt;/li&gt;&#xA;&lt;li&gt;[]byte&lt;/li&gt;&#xA;&lt;li&gt;io.Reader&lt;/li&gt;&#xA;&lt;li&gt;io.ReadSeeker&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;这是一个通过&lt;a href=&#34;http://golang.org/pkg/mime/multipart/&#34;&gt;Go的multipart包&lt;/a&gt;提供的围绕上传处理的包装者。字节保留在内存中，除非它们超过阈值（默认为10MB），在那种情况下，它们将被写入到一个临时文件。 &lt;strong&gt;注意：&lt;/strong&gt;将一个文件上传绑定到os.File需要Revel将其写入到一个临时文件中,这样会使它比其它类型效率低。&#xA;###自定义Binder&#xA;应用可以自定义Binder以获得这个框架的优点。&#xA;它只需要注册&lt;a href=&#34;http://robfig.github.io/revel/docs/godoc/binder.html#Binder&#34;&gt;binder接口&lt;/a&gt;并且注册每一个它要访问的类型：&#xA;&lt;pre&gt;&lt;code&gt;func myBinder(params Params, name string, typ reflect.Type) reflect.Value {&#xA;    &amp;hellip;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func init() {&#xA;    revel.TypeBinders[reflect.TypeOf(MyType{})] = myBinder&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——路由</title>
      <link>http://gavin1989.github.io/2013/04/revel-routing.html</link>
      <pubDate>2013-04-24 04:47:50 +0800</pubDate>
      <description>&lt;p&gt;##路由&#xA;路由被定义在单独的routes文件中，使用原始的Play!语法。&lt;br /&gt;&#xA;基本语法为：&#xA;&lt;pre&gt;&lt;code&gt;(METHOD) (URL Pattern) (Controller.Action)&lt;/code&gt;&lt;/pre&gt;&#xA;下面这个例子演示了所有功能：&#xA;&lt;pre&gt;&lt;code&gt;# conf/routes&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;这个文件定义了应用所有的路由（以优先级从高到低排列）&#34; href=&#34;#这个文件定义了应用所有的路由（以优先级从高到低排列）&#34;&gt;&lt;/a&gt;这个文件定义了应用所有的路由（以优先级从高到低排列）&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;GET    /login                 Application.Login      # 这是一个简单的路径&#xA;GET    /hotels/?              Hotels.Index           # 匹配 /hotels 和 /hotels/ (尾部的斜线是可选的)&#xA;GET    /hotels/{id}           Hotels.Show            # 提取一个URI参数(匹配 /[^/]+/)&#xA;POST   /hotels/{&amp;lt;[0-9]+&amp;gt;id}   Hotels.Save            # 匹配自定义正则表达式的URI参数&#xA;WS     /hotels/{id}/feed      Hotels.Feed            # WebSockets.&#xA;POST   /hotels/{id}/{action}  Hotels.{action}        # 自动路由一些action.&#xA;GET    /public/{&amp;lt;.&lt;em&gt;&amp;gt;filepath} Static.Serve(&amp;ldquo;public&amp;rdquo;) # 映射到 /app/public 下的资源 /public/&amp;hellip;&#xA;*      /{controller}/{action} {controller}.{action}  # 捕获所有; 自动生成URL&lt;/code&gt;&lt;/pre&gt;&#xA;让我们一行一行来看。&#xA;###一个简单的路径&#xA;&lt;pre&gt;&lt;code&gt;GET    /login                 Application.Login&lt;/code&gt;&lt;/pre&gt;&#xA;最简单的路由使用精确匹配的方法和路径，在上例中调用了Application Controller的Login Action。&#xA;###可选的尾部斜线&#xA;&lt;pre&gt;&lt;code&gt;GET    /hotels/?              Hotels.Index&lt;/code&gt;&lt;/pre&gt;&#xA;问号在正则表达式中作用为：它既允许路径匹配前面的字符也允许路径不匹配前面的字符。上例中，在路径为/hotels和/hotels/两种情况下，路由都会调用Hotels.Index。&#xA;###URL参数&#xA;&lt;pre&gt;&lt;code&gt;GET    /hotels/{id}           Hotels.Show&lt;/code&gt;&lt;/pre&gt;&#xA;路径的片段可匹配并可提取。默认{id}会匹配除斜线（[^/]+）外的任何事物。在这种情况下，/hotels/123和/hotels/abc都匹配这个路由。&lt;br /&gt;&#xA;提取的参数可以在Controller.Params这个映射表中得到，也可以通过action方法的参数得到。例如：&#xA;&lt;pre&gt;&lt;code&gt;func (c Hotels) Show(id int) revel.Result {&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;或者&#xA;&lt;pre&gt;&lt;code&gt;func (c Hotels) Show() revel.Result {&#xA;    var id string = c.Params.Get(&amp;ldquo;id&amp;rdquo;)&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;或者&#xA;&lt;pre&gt;&lt;code&gt;func (c Hotels) Show() revel.Result {&#xA;    var id int = c.Params.Bind(&amp;ldquo;id&amp;rdquo;, reflect.TypeOf(0))&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;###采用自定义正则表达式的URL参数&#xA;&lt;pre&gt;&lt;code&gt;POST   /hotels/{&amp;lt;[0-9]+&amp;gt;id}   Hotels.Save&lt;/code&gt;&lt;/pre&gt;&#xA;路由为url参数指定了约束它们的正则表达式。正则表达式的位置在尖括号&amp;lt;&amp;gt;之间，参数名之前。&lt;br /&gt;&#xA;在这个例子中，我们限制Hotel ID为数字。&#xA;###WebSockets&#xA;&lt;pre&gt;&lt;code&gt;WS     /hotels/{id}/feed      Hotels.Feed&lt;/code&gt;&lt;/pre&gt;&#xA;WebSockets的路由方式和其它请求相同，只不过使用一个含有WS标识符的方法。&lt;br /&gt;&#xA;相应的action必须有这样的签名：&#xA;&lt;pre&gt;&lt;code&gt;func (c Hotels) Feed(ws *websocket.Conn, id int) revel.Result {&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;###静态服务&#xA;&lt;pre&gt;&lt;code&gt;GET    /public/{&amp;lt;.&lt;/em&gt;&amp;gt;filepath}       Static.Serve(&amp;ldquo;public&amp;rdquo;)&#xA;GET    /favicon.ico                 Static.Serve(&amp;ldquo;public&amp;rdquo;, &amp;ldquo;img/favicon.png&amp;rdquo;)&lt;/code&gt;&lt;/pre&gt;&#xA;关于对静态资产目录的服务，Revel提供一个static组件，它包含一个单独的Static Controller。它服务action需要两个参数：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前缀（字符串）——一个关于资产根目录的相对或绝对路径&lt;/li&gt;&#xA;&lt;li&gt;文件路径（字符串）——一个指定请求文件的相对路径&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;（请参阅&lt;a href=&#34;http://droider.sinaapp.com/?p=172&#34;&gt;结构布局&lt;/a&gt;）&#xA;###固定参数&#xA;与静态服务部分演示的一样，路由可以为action指定一个或多个值。例如：&#xA;&lt;pre&gt;&lt;code&gt;GET    /products/{id}    ShowList(&amp;ldquo;PRODUCT&amp;rdquo;)&#xA;GET    /menus/{id}       ShowList(&amp;ldquo;MENU&amp;rdquo;)&lt;/code&gt;&lt;/pre&gt;&#xA;提供的参数被绑定到这里使用的参数名上。在这种情况下，列表类型的字符串将被绑定到action的第一个参数。&lt;br /&gt;&#xA;这样做可能对下面的情况有帮助：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;你有几个类似的action&lt;/li&gt;&#xA;&lt;li&gt;你有几个在不同模式下工作的action在做相同的事情&lt;/li&gt;&#xA;&lt;li&gt;你有几个操作不同类型数据的action在做相同的事情&#xA;##自动路由&#xA;&lt;pre&gt;&lt;code&gt;POST   /hotels/{id}/{action}  Hotels.{action}&lt;/li&gt;&#xA;&lt;li&gt;/{controller}/{action} {controller}.{action}&lt;/code&gt;&lt;/pre&gt;&#xA;提取的URL参数也用于确定要调用的action。匹配Controller和action时不区分大小写。&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;上面示例中的第一行会产生下面的路由：&#xA;&lt;pre&gt;&lt;code&gt;/hotels/1/show    =&amp;gt; Hotels.Show&#xA;/hotels/2/details =&amp;gt; Hotels.Details&lt;/code&gt;&lt;/pre&gt;&#xA;同样的，示例中第二行的路由可以用来访问应用的任意action。&#xA;&lt;pre&gt;&lt;code&gt;/application/login =&amp;gt; Application.Login&#xA;/users/list        =&amp;gt; Users.List&lt;/code&gt;&lt;/pre&gt;&#xA;由于匹配到Controller时不区分大小写，所以下面的路由也可以工作：&#xA;&lt;pre&gt;&lt;code&gt;/APPLICATION/LOGIN =&amp;gt; Application.Login&#xA;/Users/List        =&amp;gt; Users.List&lt;/code&gt;&lt;/pre&gt;&#xA;使用文件最后的自动路由来捕获所有请求对于快速地将action挂钩到非虚的URL非常有用。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel开发手册</title>
      <link>http://gavin1989.github.io/2013/04/revel-manual.html</link>
      <pubDate>2013-04-23 10:57:15 +0800</pubDate>
      <description>&lt;h1&gt;&lt;a style=&#34;display: block;&#34; name=&#34;revel开发手册&#34; href=&#34;#revel开发手册&#34;&gt;&lt;/a&gt;Revel开发手册&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;概述&#34; href=&#34;#概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://droider.sinaapp.com/?p=167&#34;&gt;概念&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=172&#34;&gt;结构&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=175&#34;&gt;共享功能&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;controllers&#34; href=&#34;#controllers&#34;&gt;&lt;/a&gt;Controllers&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://droider.sinaapp.com/?p=182&#34;&gt;路由&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=185&#34;&gt;绑定参数&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=189&#34;&gt;参数验证&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=194&#34;&gt;Session域 / Flash域&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=198&#34;&gt;Results&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=210&#34;&gt;模板(Templates)&lt;/a&gt;&lt;br /&gt;&#xA;&lt;a href=&#34;http://droider.sinaapp.com/?p=212&#34;&gt;拦截者&lt;/a&gt;&lt;br /&gt;&#xA;[插件]()&lt;br /&gt;&#xA;[Websockets]()&lt;br /&gt;&#xA;[国际化]()&lt;br /&gt;&#xA;[缓存]()&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;组件&#34; href=&#34;#组件&#34;&gt;&lt;/a&gt;组件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;[概述]()&lt;br /&gt;&#xA;[测试]()&lt;br /&gt;&#xA;[Jobs]()&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;操作&#34; href=&#34;#操作&#34;&gt;&lt;/a&gt;操作&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;[Logging]()&lt;br /&gt;&#xA;[Deployment]()&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;reference&#34; href=&#34;#reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;[app.conf]()&lt;br /&gt;&#xA;[Command line tool]()&lt;br /&gt;&#xA;[FAQ]()&lt;br /&gt;&#xA;[How Revel Works]()&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——共享功能</title>
      <link>http://gavin1989.github.io/2013/04/revel-sharing-functionality.html</link>
      <pubDate>2013-04-23 10:37:40 +0800</pubDate>
      <description>&lt;p&gt;##共享功能&#xA;Revel提供了在不同的域之间共享功能的途径：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;actions&lt;/li&gt;&#xA;&lt;li&gt;controllers&lt;/li&gt;&#xA;&lt;li&gt;applications&#xA;##Actions&#xA;相关的actions共享一个单独的Controller类型。开发者可以为它添加数据域以便存储更多关于请求的上下文。拦截器可以在Revel运行前或后注册到Controller的任意action上。&#xA;##Controllers&#xA;Revel允许将Controller混合在一起以便跨越不同的Controller类型共享字段、方法以及拦截器。&lt;br /&gt;&#xA;下面是一个例子：&#xA;&lt;pre&gt;&lt;code&gt;// MongoController提供访问我们的MongoDB&#xA;type MongoController struct {&#xA;*revel.Controller&#xA;Session *mgo.Session&#xA;}&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;func (c *MongoController) Begin() revel.Result {&#xA;    c.Session = &amp;hellip;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func init() {&#xA;    revel.InterceptMethod((*MongoController).Begin, revel.BEFORE)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type AppController struct {&#xA;    *revel.Controller&#xA;    MongoController&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在这个例子中，开发者创建了一个MongoController，它用来跨越整个应用，开发者可以将它混合到另外的Controller中。在这里，拦截器将会运行并且AppController上的action可以访问*mgo.Session。&#xA;##Application&#xA;组件可以用来跨应用共享Controller类型、模板和资产。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Revel框架——结构布局</title>
      <link>http://gavin1989.github.io/2013/04/revel-organization.html</link>
      <pubDate>2013-04-23 05:57:39 +0800</pubDate>
      <description>&lt;p&gt;##结构&#xA;Revel规定它自身和用户应用都要安装在通过Go命令行工具规定的GOPATH布局中。（参阅&lt;a href=&#34;http://golang.org/cmd/go/&#34;&gt;“GOPATH环境变量”&lt;/a&gt;）&#xA;##布局示例&#xA;下面是一个名为sample的Revel应用的默认布局：&#xA;&lt;pre&gt;&lt;code&gt;gocode                  GOPATH根目录&#xA;  src                   GOPATH源码文件夹&#xA;    revel               Revel源码&#xA;      &amp;hellip;&#xA;    sample              应用根目录&#xA;      app               App源码目录&#xA;        controllers     App controllers目录&#xA;          init.go       拦截者注册器&#xA;        models          App域模型&#xA;        views           Templates（模版）&#xA;      tests             Test suites测试套件&#xA;      conf              配置文件目录&#xA;        app.conf        主配置文件&#xA;        routes          路由定义&#xA;      messages          消息文件&#xA;      public            公共目录&#xA;        css             CSS文件目录&#xA;        js              Javascript文件目录&#xA;        images          图片文件目录&lt;/code&gt;&lt;/pre&gt;&#xA;##app/目录&#xA;app/目录包含你的应用的源码以及模版。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;app/controllers&lt;/li&gt;&#xA;&lt;li&gt;app/models&lt;/li&gt;&#xA;&lt;li&gt;app/views&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;Revel规定：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有的模版（template）都在app/views目录下&lt;/li&gt;&#xA;&lt;li&gt;所有的Controller都在app/controllers目录下&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;除此之外，应用可以按它希望的结构组织代码。Revel会监视app/目录下的所有文件夹，并在监视到改变时重新build应用。任何依赖于app/之外的改变不会被监视到，当必须这样时，就得程序员负责重新编译。&lt;br /&gt;&#xA;另外，Revel在启动时会导入app/（或导入的模块）下所有包含init()方法的包，以此来确保程序员所有的代码被初始化。&lt;br /&gt;&#xA;controllers/init.go文件是约定的本地用来注册所有拦截者的钩子（hooks）。对于同一个包中的源文件，init()方法的顺序是没有定义的，因此在同一个文件中收集所有的拦截者定义允许程序员指定（并且知道）它们运行的顺序。（它也可以用于未来其它顺序敏感的初始化）&#xA;##conf/目录&#xA;conf目录包含应用的配置文件，下面是两个主要的配置文件：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;app.conf，应用主要的配置文件，它包含标准的配置参数&lt;/li&gt;&#xA;&lt;li&gt;routes，路由定义文件&#xA;##messages/目录&#xA;messages目录包含所有本地的消息文件。&#xA;##public/目录&#xA;存储在public目录的资源是通过Web Server直接保存的静态资产。一般它被分割为三个标准的子文件夹来存放图片、CSS样式以及JavaScript文件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>[转载 ]]</title>
      <link>http://gavin1989.github.io/2013/04/thoughtworks-developer-reading-radar.html</link>
      <pubDate>2013-04-22 01:43:19 +0800</pubDate>
      <description>&lt;p&gt;转载自：&lt;a href=&#34;http://agiledon.github.io/blog/2013/04/17/thoughtworks-developer-reading-radar/&#34;&gt;http://agiledon.github.io/blog/&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/17/thoughtworks-developer-reading-radar/&lt;/a&gt;&#xA;&lt;img src=&#34;http://droider-wordpress.stor.sinaapp.com/reading-radar.jpg&#34; alt=&#34;&#34; /&gt;&#xA;&#xA;软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。&lt;br /&gt;&#xA;ThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。&lt;br /&gt;&#xA;现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。&lt;br /&gt;&#xA;该读书雷达将书籍分为了如下四个维度：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Coding Practice（编程实践）&lt;/li&gt;&#xA;&lt;li&gt;Architecture &amp;amp; Design（架构与设计）&lt;/li&gt;&#xA;&lt;li&gt;Methodology（方法学）&lt;/li&gt;&#xA;&lt;li&gt;Thought &amp;amp; Leadership（思想与领导力）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。&lt;br /&gt;&#xA;每个维度皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。&lt;br /&gt;&#xA;或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，”吾生也有涯，而知也无涯”，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodolog（方法学）维度，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于我和刘龙军还不够擅长的领域，我们不敢也不愿做出可能误导人的推荐。&lt;br /&gt;&#xA;本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。&lt;br /&gt;&#xA;我将在后面的文章中，根据每个维度为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示(感谢凯峰为这个雷达图建立的豆列，可以访问ThoughtWorks(中国)程序员读书雷达)：&lt;br /&gt;&#xA;##Coding Practice | 编程实践&#xA;###基础篇&#xA;&lt;strong&gt;Clean Code《代码整洁之道》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Pragmatic Unit Testing《单元测试之道》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The Productive Programmer《卓有成效的程序员》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Test-Driven Development By Example《测试驱动开发》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Clean Coder《程序员的职业修养》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The Art of Readable Code《编写可读代码的艺术》&lt;/strong&gt;&lt;br /&gt;&#xA;###进阶篇&#xA;&lt;strong&gt;Refactoring To Patterns《重构与模式》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Implementation Patterns《实现模式》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Code Completed《代码大全》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The Pragmatic Programmer《程序员修炼之道》&lt;/strong&gt;&lt;br /&gt;&#xA;###高级篇&#xA;&lt;strong&gt;Structure and Interpretation of Computer Programs《计算机程序的构造和解释》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Working Effectively with Legacy Code《修改代码的艺术》&lt;/strong&gt;&lt;br /&gt;&#xA;##Architecture &amp;amp; Design | 架构与设计&#xA;###基础篇&#xA;&lt;strong&gt;Agile Software Development 《敏捷软件开发：原则、实践与模式》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Head First Design Patterns《深入浅出设计模式》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Design Patterns 《设计模式》&lt;/strong&gt;&lt;br /&gt;&#xA;###进阶篇&#xA;&lt;strong&gt;The Art of UNIX Programming 《Unix编程艺术》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Practical API Design 《框架设计的艺术》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Domain Specific Languages 《领域特定语言》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Patterns of Enterprise Application Architecture 《企业应用架构模式》&lt;/strong&gt;&lt;br /&gt;&#xA;###高级篇&#xA;&lt;strong&gt;Release It&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Domain-Driven Design 《领域驱动设计》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Enterprise Integration Patterns《企业集成模式》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Beautiful Architecture《架构之美》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Pattern-Oriented Software Architecture《面向模式的软件架构》&lt;/strong&gt;&lt;br /&gt;&#xA;##Methodology | 方法学&#xA;###基础篇&#xA;&lt;strong&gt;User Stories Applied《用户故事与敏捷方法》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The Gold Mine《金矿》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Scrum and XP From the Trenches《硝烟中的Scrum和XP》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Continuous Integration《持续集成》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Extreme Programming Explained《解析极限编程》&lt;/strong&gt;&lt;br /&gt;&#xA;###进阶篇&#xA;&lt;strong&gt;Lean Thinking《精益思想》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Continuous Delivery《持续交付》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;How Google Tests Software&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Agile Testing&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Extreme Programming Refactored《重构极限编程》&lt;/strong&gt;&lt;br /&gt;&#xA;###高级篇&#xA;&lt;strong&gt;Specification By Example&lt;/strong&gt;&lt;br /&gt;&#xA;##Thought &amp;amp; Leadership | 思想与领导力&#xA;###基础篇&#xA;&lt;strong&gt;The Effective Executive《卓有成效的管理者》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Are Your Lights On?《你的灯亮着吗》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Becoming A Technical Leader《成为技术领导者》&lt;/strong&gt;&lt;br /&gt;&#xA;###进阶篇&#xA;&lt;strong&gt;The Fifth Discipline《第五项修炼》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The Design Of Business&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Management 3.0《管理3.0：培养和提升敏捷领导力》&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;Presentation To Win&lt;/strong&gt;&lt;br /&gt;&#xA;&lt;strong&gt;The McKinsey Way《麦肯锡方法》&lt;/strong&gt;&lt;br /&gt;&#xA;###高级篇&#xA;&lt;strong&gt;Thinking, Fast and Slow《思考快与慢》&lt;/strong&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Ubuntu下golang的emacs配置</title>
      <link>http://gavin1989.github.io/2013/04/ubuntu-golang-emacs-configuration.html</link>
      <pubDate>2013-04-19 11:10:58 +0800</pubDate>
      <description>&lt;p&gt;参考了&lt;a href=&#34;https://github.com/astaxie/build-web-application-with-golang/blob/master/ebook/01.4.md&#34;&gt;《Go Web编程》&lt;/a&gt;&#xA;这里说一下我的步骤：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;配置emacs高亮显示&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;cp $GOROOT/misc/emacs/* ~/.emacs.d/&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装gocode&#xA;&lt;pre&gt;&lt;code&gt;go get -u github.com/nsf/gocode&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;配置gocode&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;~ cd $GOROOT/src/pkg/github.com/nsf/gocode/emacs&#xA;~ cp go-autocomplete.el ~/.emacs.d/&#xA;~ gocode set propose-builtins true&#xA;propose-builtins true&#xA;~ gocode set lib-path &amp;ldquo;/home/gavin/go/pkg/linux_amd64&amp;rdquo; // 这个是自己的路径&#xA;lib-path &amp;ldquo;/home/gavin/go/pkg/linux_amd64&amp;rdquo;&#xA;~ gocode set&#xA;propose-builtins true&#xA;lib-path &amp;ldquo;/home/gavin/go/pkg/linux_amd64&amp;rdquo;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;安装&lt;a href=&#34;http://cx4a.org/software/auto-complete/&#34;&gt;auto-complete&lt;/a&gt;&lt;br /&gt;&#xA;下载并解压&#xA;&lt;pre&gt;&lt;code&gt;cd ~/.emacs.d&#xA;mkdir auto-complete&lt;/code&gt;&lt;/pre&gt;&#xA;然后cd到auto-complete解压到的文件夹&#xA;&lt;pre&gt;&lt;code&gt;make install DIR=$HOME/.emacs.d/auto-complete&lt;/code&gt;&lt;/pre&gt;&#xA;安装成功后配置.emacs文件&#xA;&lt;pre&gt;&lt;code&gt;(add-to-list &amp;lsquo;load-path &amp;ldquo;/home/gavin/.emacs.d/auto-complete&amp;rdquo;)&#xA;(require &amp;lsquo;auto-complete-config)&#xA;(add-to-list &amp;lsquo;ac-dictionary-directories &amp;ldquo;/home/gavin/.emacs.d/auto-complete/ac-dict&amp;rdquo;)&#xA;(ac-config-default)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;配置.emacs文件&#xA;&lt;pre&gt;&lt;cpde&gt;;; golang mode&#xA;(add-to-list &amp;lsquo;load-path &amp;ldquo;/home/gavin/.emacs.d&amp;rdquo;)&#xA;(require &amp;lsquo;go-mode-load)&#xA;(require &amp;lsquo;go-autocomplete)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Go——Stein算法求最大公约数</title>
      <link>http://gavin1989.github.io/2013/04/golang-stein-gcd.html</link>
      <pubDate>2013-04-17 11:28:07 +0800</pubDate>
      <description>&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;func gcd(p, q int) int {&#xA;    if p &lt; q {&#xA;        t := p&#xA;        p = q&#xA;        q = t&#xA;    }&#xA;    if q == 0 {&#xA;        return p&#xA;    }&#xA;    if p&amp;1 == 0 &amp;&amp; q&amp;1 == 0 {&#xA;        return gcd(p&gt;&gt;1, q&gt;&gt;1) &lt;&lt; 1&#xA;    }&#xA;    if p&amp;1 == 0 {&#xA;        return gcd(p&gt;&gt;1, q)&#xA;    }&#xA;    if q&amp;1 == 0 {&#xA;        return gcd(p, q&gt;&gt;1)&#xA;    }&#xA;    return gcd((p+q)&gt;&gt;1, (p-q)&gt;&gt;1)&#xA;}&#xA;&#xA;func main() {&#xA;    p, q := 3, 11&#xA;    println(gcd(p, q))&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Go——斐波那契数列</title>
      <link>http://gavin1989.github.io/2013/04/golang-fibonacci.html</link>
      <pubDate>2013-04-17 10:34:41 +0800</pubDate>
      <description>&lt;p&gt;由于Go语言支持闭包，所以实现的斐波那契数列算法非常简洁：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// fibonacci is a function that returns&#xA;// a function that returns an int.&#xA;func fibonacci() func() int {&#xA;    a, b := 0, 1&#xA;    return func() int {&#xA;        a, b = b, a+b&#xA;        return a&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    f := fibonacci()&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        println(f())&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;下面附上Java版，这里维护了一个数组：&#xA;&lt;pre&gt;&lt;code&gt;package algs;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;public class Fibonacci {&#xA;    private static long[] FN = new long[100];&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {&#xA;    for(int i = 0; i &amp;lt; 10; i++) {&#xA;        System.out.println(F(i));&#xA;    }&#xA;}&#xA;&#xA;private static long F(int N){&#xA;    if(N == 0) return 0;&#xA;    if(N == 1) {&#xA;        FN[N] = 1;&#xA;        return 1;&#xA;    }&#xA;    FN[N] = FN[N-1] + FN[N-2];&#xA;    return FN[N];&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言之旅——方法与接口</title>
      <link>http://gavin1989.github.io/2013/04/golang-tour-method-and-interface.html</link>
      <pubDate>2013-04-17 04:51:51 +0800</pubDate>
      <description>&lt;p&gt;##方法&#xA;Go中没有类。但是，可以在结构体类型上定义方法。方法接收者出现在func关键字与方法名之间的参数中。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X, Y float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (v *Vertex) Abs() float64 {&#xA;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    v := &amp;amp;Vertex{3, 4}&#xA;    fmt.Println(v.Abs())&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;可以对包中的任意类型定义方法，而不只是结构体。但是，不能对来自于其它包的类型和基本类型定义方法。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type MyFloat float64&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (f MyFloat) Abs() float64 {&#xA;    if f &amp;lt; 0 {&#xA;        return float64(-f)&#xA;    }&#xA;    return float64(f)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    f := MyFloat(-math.Sqrt2)&#xA;    fmt.Println(f.Abs())&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;方法可以与命名类型或命名类型的指针相关联。只看两个Abs方法，下面例子中方法的接收者为*Vertex指针类型，而上面例子中为MyFloat值类型）。&lt;br /&gt;&#xA;使用指针接收者有两个原因：首先，避免在每一次方法调用上复制值（当值类型是非常大的结构体时更有效率）；其次，方法可以修改接收者指向的值。&lt;br /&gt;&#xA;尝试改变下例中Abs和Scale方法的声明，使用Vertex代替*Vertex为接收者。你将看到：当v为Vertex时，Scale方法没有任何效果，当v是一个值（非指针）类型时，这个方法复制了一个Vertex类型的值，所以它无法修改原始值；Abs方法可以正常工作，它仅仅是读取了v的值，无论是通过复制的值还是原始值（通过指针）都没有关系。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X, Y float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (v *Vertex) Scale(f float64) {&#xA;    v.X = v.X * f&#xA;    v.Y = v.Y * f&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (v *Vertex) Abs() float64 {&#xA;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    v := &amp;amp;Vertex{3, 4}&#xA;    v.Scale(5)&#xA;    fmt.Println(v, v.Abs())&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##接口&#xA;接口类型用来描述一组方法的集合。接口类型的值可以存放任意实现这些方法的值。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Abser interface {&#xA;    Abs() float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    var a Abser&#xA;    f := MyFloat(-math.Sqrt2)&#xA;    v := Vertex{3, 4}&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;a =f // a MyFloat implements Abser&#xA;a = &amp;amp;v // a *Vertex implements Abser&#xA;//a = v // a Vertex, does NOT implements Abser&#xA;&#xA;fmt.Println(a.Abs())&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type MyFloat float64&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (f MyFloat) Abs() float64 {&#xA;    if f &amp;lt; 0 {&#xA;        return float64(-f)&#xA;    }&#xA;    return float64(f)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X, Y float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (v *Vertex) Abs() float64 {&#xA;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;类型通过实现方法来实现一个接口，因此也就没有显式声明的必要。&#xA;隐式接口分离了实现的包与定义接口的包：即二者互不依赖。它还鼓励明确的接口定义，因此不必通过一个新的接口名查找所有实现和标签。&#xA;下例中，由于包io下已经定义了Reader和Writer接口，所以这里你不必如此：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;os&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Reader interface {&#xA;    Read(b []byte) (n int, err error)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Writer interface {&#xA;    Write(b []byte) (n int, err error)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type ReadWriter interface {&#xA;    Reader&#xA;    Writer&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    var w Writer&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// os.Stdout implements Writer&#xA;w = os.Stdout&#xA;&#xA;fmt.Fprintf(w, &amp;quot;hello, writer\n&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;##错误&#xA;错误可以是任意能用一个错误字符串描述自身的东西。思路是通过捕获内建的预定义error接口类型，这个接口只有一个返回一个字符串的方法：Error。&#xA;&lt;pre&gt;&lt;code&gt;type error interface {&#xA;    Error() string&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;当用fmt包的各种打印方法打印error时，会自动调用这个方法：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;time&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type MyError struct {&#xA;    When time.Time&#xA;    What string&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (e *MyError) Error() string {&#xA;    return fmt.Sprintf(&amp;ldquo;at %v, %s&amp;rdquo;, e.When, e.What)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func run() error {&#xA;    return &amp;amp;MyError {&#xA;        time.Now(),&#xA;        &amp;ldquo;it didn&amp;rsquo;t work&amp;rdquo;,&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    if err := run(); err != nil {&#xA;        fmt.Println(err)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Web server&#xA;http包可以使用任意实现了http.Handler接口的值来处理HTTP请求。&#xA;&lt;pre&gt;&lt;code&gt;package http&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Handler interface {&#xA;    ServeHTTP(w ResponseWriter, r *Request)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在下面的例子中，Hello类型实现了http.Handler接口。访问http://localhost:4000会看到程序给出的问候。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;net/http&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Hello struct {}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (h Hello) ServeHTTP(&#xA;    w http.ResponseWriter,&#xA;    r *http.Request) {&#xA;        fmt.Fprint(w, &amp;ldquo;Hello!&amp;rdquo;)&#xA;    }&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    var h Hello&#xA;    http.ListenAndServe(&amp;ldquo;localhost:4000&amp;rdquo;, h)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;处理你web服务器上指定的路径。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;net/http&amp;rdquo;&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type String string&#xA;type Struct struct {&#xA;    Greeting string&#xA;    Punct string&#xA;    Who string&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (s String) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Fprint(w, s)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func (s *Struct) ServeHTTP(w http.ResponseWriter, r *http.Request) {&#xA;    fmt.Fprint(w, s)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    // your http.Handle calls here&#xA;    http.Handle(&amp;ldquo;/string&amp;rdquo;, String(&amp;ldquo;I&amp;rsquo;m a frayed knot.&amp;rdquo;))&#xA;    http.Handle(&amp;ldquo;/struct&amp;rdquo;, &amp;amp;Struct{&amp;ldquo;Hello&amp;rdquo;, &amp;ldquo;:&amp;ldquo;, &amp;ldquo;Gophers!&amp;rdquo;})&#xA;    http.ListenAndServe(&amp;ldquo;localhost:4000&amp;rdquo;, nil)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##图像&#xA;image包中定义了Image接口：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package image&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Image interface {&#xA;    ColorModel() color.Model&#xA;    Bounds() Rectangle&#xA;    At(x, y int) color.Color&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;其中color.Color和color.Model都是接口，但是这里将不使用它们，而是用内建的实现color.RGBA和color.RGBAModel。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;image&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    m := image.NewRGBA(image.Rect(0, 0, 100, 100))&#xA;    fmt.Println(m.Bounds())&#xA;    fmt.Println(m.At(0, 0).RGBA())&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言之旅——基本概念（二）</title>
      <link>http://gavin1989.github.io/2013/04/golang-tour-2.html</link>
      <pubDate>2013-04-17 02:24:37 +0800</pubDate>
      <description>&lt;p&gt;##结构体&#xA;结构体是字段的集合，Go中使用type关键字来声明它。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X int&#xA;    y int&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(Vertex{1, 2})&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;可以使用点号来访问结构体字段：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X int&#xA;    Y int&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    v := Vertex{1, 2}&#xA;    v.X = 4&#xA;    fmt.Println(v.X)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;Go有指针，但是没有指针运算。可以通过指针访问结构体字段，通过指针的间接访问是透明的。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X int&#xA;    Y int&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    p := Vertex{1, 2}&#xA;    q := &amp;amp;p&#xA;    q.X = 1e9&#xA;    fmt.Println(p)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;结构体字面量（Struct Literals）表示通过列出结构体字段的值来新分配一个结构体（Literal这个词不好理解，详情猛击&lt;a href=&#34;http://en.wikipedia.org/wiki/Literal_(computer_programming&#34;&gt;维基百科&lt;/a&gt;)）。&#xA;使用Name:语法可以只列出一部分字段，而且和字段名的顺序无关。&#xA;使用特殊的前缀&amp;amp;会构造一个结构体字面量的指针。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X, Y int&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var (&#xA;    p = Vertex{1, 2} // has type Vertex&#xA;    q = &amp;amp;Vertex{1, 2} // has type *Vertex&#xA;    r = Vertex{X: 1} // Y:0 is implicit&#xA;    s = Vertex{} // X:0 and Y:0&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(p, q, r, s)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;new(T)表达式分配一个零初始化的T值，并返回一个指向它的指针。&#xA;&lt;pre&gt;&lt;code&gt;var t *T = new(T)&lt;/code&gt;&lt;/pre&gt;&#xA;或：&#xA;&lt;pre&gt;&lt;code&gt;t := new(T)&lt;/code&gt;&lt;/pre&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    X, Y int&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    v := new(Vertex)&#xA;    fmt.Println(v)&#xA;    v.X, v.Y = 11, 9&#xA;    fmt.Println(v)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Slices（切片）&#xA;slice指向一个数组的值，同时还包含有长度信息。[]T是一个元素类型为T的slice。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    p := []int{2, 3, 5, 7, 11, 13}&#xA;    fmt.Println(&amp;ldquo;p ==&amp;rdquo;, p)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for i := 0; i &amp;lt; len(p); i++ {&#xA;    fmt.Printf(&amp;quot;p[%d] == %d\n&amp;quot;, i, p[i])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;slice可以重新切片，即创建一个新的切片指向同一个数组。&#xA;表达式：&#xA;&lt;pre&gt;&lt;code&gt;s[lo:hi]&lt;/code&gt;&lt;/pre&gt;&#xA;表示从lo到hi-1的元素的一个切片，包含边界。&#xA;&lt;pre&gt;&lt;code&gt;s[lo:lo]&lt;/code&gt;&lt;/pre&gt;&#xA;为空，但是：&#xA;&lt;pre&gt;&lt;code&gt;s[lo:lo+1]&lt;/code&gt;&lt;/pre&gt;&#xA;有一个元素。示例代码：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    p := []int{2, 3, 5, 7, 11, 13}&#xA;    fmt.Println(&amp;ldquo;p ==&amp;rdquo;, p)&#xA;    fmt.Println(&amp;ldquo;p[1:4] ==&amp;ldquo;, p[1:4])&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// missing low index implies 0&#xA;fmt.Println(&amp;quot;p[:3] ==&amp;quot;, p[:3])&#xA;&#xA;// missing high index implies len(s)&#xA;fmt.Println(&amp;quot;p[4:] ==&amp;quot;, p[4:])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;使用make函数创建slice，它分配一个归零的数组并返回这个数组的slice：&#xA;&lt;pre&gt;&lt;code&gt;a := make([]int, 5) // len(a)=5&lt;/code&gt;&lt;/pre&gt;&#xA;要指定容量的话，就要使用第三个参数：&#xA;&lt;pre&gt;&lt;code&gt;b := make([]int, 0, 5) // len(b)=0, cap(b)=5&lt;/p&gt;&#xA;&#xA;&lt;p&gt;b = b[:cap(b)] // len(b)=5, cap(b)=5&#xA;b = b[1:]      // len(b)=4, cap(b)=4&lt;/code&gt;&lt;/pre&gt;&#xA;示例代码：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    a := make([]int, 5)&#xA;    printSlice(&amp;ldquo;a&amp;rdquo;, a)&#xA;    b := make([]int, 0, 5)&#xA;    printSlice(&amp;ldquo;b&amp;rdquo;, b)&#xA;    c := b[:2]&#xA;    printSlice(&amp;ldquo;c&amp;rdquo;, c)&#xA;    d := c[2:5]&#xA;    printSlice(&amp;ldquo;d&amp;rdquo;, d)&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func printSlice(s string, x []int) {&#xA;    fmt.Printf(&amp;ldquo;%s len=%d cap=%d %v\n&amp;rdquo;,&#xA;        s, len(x), cap(x), x)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;slice的零值是nil。一个nil slice的长度和容量都是0。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    var z []int&#xA;    fmt.Println(z, len(z), cap(z))&#xA;    if z == nil {&#xA;        fmt.Println(&amp;ldquo;nil!&amp;rdquo;)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Range&#xA;使用for循环的range形式可以遍历map或slice：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    for i, v := range pow {&#xA;        fmt.Printf(&amp;ldquo;2**%d = %d\n&amp;rdquo;, i, v)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果想要略过索引或值，可以将其设置为_。如果只想使用索引，可以直接去掉“,value”部分：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    pow := make([]int, 10)&#xA;    for i, value := range pow {&#xA;        fmt.Printf(&amp;ldquo;%d : %d\n&amp;rdquo;, i, value)&#xA;    }&#xA;    for i := range pow {&#xA;        pow[i] = 1 &amp;lt;&amp;lt; uint(i)&#xA;    }&#xA;    for _, value := range pow {&#xA;        fmt.Printf(&amp;ldquo;%d\n&amp;rdquo;, value)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Map&#xA;map是映射键到值的映射表。map必须在使用前用make函数创建（不是new），一个值为nil的map是空的，并且不能被赋值：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    Lat, Long float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var m map[string]Vertex&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    m = make(map[string]Vertex)&#xA;    m[&amp;ldquo;Bell Labs&amp;rdquo;] = Vertex{&#xA;        40.68433, -74.39967,&#xA;    }&#xA;    fmt.Println(m[&amp;ldquo;Bell Labs&amp;rdquo;])&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;map字面量与结构体字面量相似，只不过必须有键：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    Lat, Long float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var m = map[string]Vertex{&#xA;    &amp;ldquo;Bell Labs&amp;rdquo; : Vertex{&#xA;        40.68433, -74.39967,&#xA;    },&#xA;    &amp;ldquo;Google&amp;rdquo; : Vertex{&#xA;        37.42202, -122.08408,&#xA;    },&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(m)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果顶层类型只有类型名的话，就可以忽略字面量中元素的类型：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;type Vertex struct {&#xA;    Lat, Long float64&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var m = map[string]Vertex{&#xA;    &amp;ldquo;Bell Labs&amp;rdquo; : {40.68433, -74.39967},&#xA;    &amp;ldquo;Google&amp;rdquo; : {37.42202, -122.08408},&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(m)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在map m中插入或更新一个元素：&#xA;&lt;pre&gt;&lt;code&gt;m[key] = elem&lt;/code&gt;&lt;/pre&gt;&#xA;获得一个元素：&#xA;&lt;pre&gt;&lt;code&gt;elem = m[key]&lt;/code&gt;&lt;/pre&gt;&#xA;删除一个元素：&#xA;&lt;pre&gt;&lt;code&gt;delete[m, key]&lt;/code&gt;&lt;/pre&gt;&#xA;通过双赋值来检测某个键是否存在：&#xA;&lt;pre&gt;&lt;code&gt;// 如果m中存在key，ok为true；否则ok为false，并且elem的值为map元素类型的零值。&#xA;// 同样，如果读取一个不存在于map中的元素时，得到的将会是map中元素类型的零值。&#xA;elem, ok := m[key]&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    m := make(map[string]int)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;m[&amp;quot;Answer&amp;quot;] = 42&#xA;fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;Answer&amp;quot;])&#xA;&#xA;m[&amp;quot;Answer&amp;quot;] = 48&#xA;fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;Answer&amp;quot;])&#xA;&#xA;delete(m, &amp;quot;Answer&amp;quot;)&#xA;fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;Answer&amp;quot;])&#xA;&#xA;v, ok := m[&amp;quot;Answer&amp;quot;]&#xA;fmt.Println(&amp;quot;The value:&amp;quot;, v, &amp;quot;Present?&amp;quot;, ok)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;##函数&#xA;函数也是值：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import(&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    hypot := func(x, y float64) float64 {&#xA;        return math.Sqrt(x*x + y*y)&#xA;    }&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;fmt.Println(hypot(3, 4))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;函数是完全闭包的。下例中，函数adder返回一个闭包，每个闭包都被绑定到了它自己的sum变量上：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func adder() func(int) int {&#xA;    sum := 0&#xA;    return func(x int) int {&#xA;        sum += x&#xA;        return sum&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    pos, neg := adder(), adder()&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        fmt.Println(&#xA;            pos(i),&#xA;            neg(-2*i),&#xA;        )&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##Switch&#xA;case体是自动break的，除非它以一个fallthrough语句结束。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;runtime&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Print(&amp;ldquo;Go runs on &amp;ldquo;)&#xA;    switch os := runtime.GOOS; os {&#xA;    case &amp;ldquo;darwin&amp;rdquo;:&#xA;        fmt.Println(&amp;ldquo;OS X.&amp;rdquo;)&#xA;    case &amp;ldquo;linux&amp;rdquo;:&#xA;        fmt.Println(&amp;ldquo;Linux.&amp;rdquo;)&#xA;    case &amp;ldquo;windows&amp;rdquo;:&#xA;        fmt.Println(&amp;ldquo;Windows.&amp;rdquo;)&#xA;        fallthrough&#xA;    default:&#xA;        // freesd, openbsd&#xA;        // plan9&#xA;        fmt.Printf(&amp;ldquo;%s.&amp;rdquo;, os)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;switch的条件从上到下执行，当匹配成功时停止：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;time&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(&amp;ldquo;When&amp;rsquo;s Saturday?&amp;rdquo;)&#xA;    today := time.Now().Weekday()&#xA;    switch time.Saturday {&#xA;    case today + 0:&#xA;        fmt.Println(&amp;ldquo;Today.&amp;rdquo;)&#xA;    case today + 1:&#xA;        fmt.Println(&amp;ldquo;Tomorrow.&amp;rdquo;)&#xA;    case today + 2:&#xA;        fmt.Println(&amp;ldquo;In two days.&amp;rdquo;)&#xA;    default:&#xA;        fmt.Println(&amp;ldquo;Too far aways.&amp;rdquo;)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;没有条件的switch与switch true一样。这种构造可以以一种更简洁的方式书写if-then-else：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;time&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    t := time.Now()&#xA;    switch {&#xA;    case t.Hour() &amp;lt; 12:&#xA;        fmt.Println(&amp;ldquo;Good morning!&amp;rdquo;)&#xA;    case t.Hour() &amp;lt; 17:&#xA;        fmt.Println(&amp;ldquo;Good afternoon.&amp;rdquo;)&#xA;    default:&#xA;        fmt.Println(&amp;ldquo;Good evening&amp;rdquo;)&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Go语言之旅——基本概念（一）</title>
      <link>http://gavin1989.github.io/2013/04/golang-tour-1.html</link>
      <pubDate>2013-04-16 10:52:51 +0800</pubDate>
      <description>&lt;p&gt;##第一个程序&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(&amp;ldquo;Hello,world!&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;最开始的package语句不能省略；语句后不必有分号。&lt;br /&gt;&#xA;go语言支持中文，不过文本编码必须时UTF-8无BOM格式，否则编译错误，切记。&#xA;##包：&#xA;每一个Go程序都由包组成，并且程序运行的入口包是main。&lt;br /&gt;&#xA;按照惯例，包名与导入路径的最后一个目录相同。&lt;br /&gt;&#xA;下面的例子中导入了两个包：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import(&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(&amp;ldquo;Happy&amp;rdquo;,math.Pi,&amp;ldquo;Day&amp;rdquo;,&amp;ldquo;Gavin&amp;rdquo;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;导入需要的包时，既可以像上面那样将需要导入的包用括号括起来，也可以使用多条import语句：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&#xA;import &amp;ldquo;math&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(&amp;ldquo;Now you have %g problems.&amp;rdquo;,math.Nextafter(2,3))&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在导入一个包后，就可以引用它导出的名称。在Go中，导出的名字必须以大写字母开头。&lt;br /&gt;&#xA;下面是一个例子，math.pi不是导出的名字，改为Pi再试一下：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import(&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(math.pi)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;报错信息：&#xA;&lt;pre&gt;&lt;code&gt;.\exportednames.go:9: cannot refer to unexported name math.pi&#xA;.\exportednames.go:9: undefined: math.pi&lt;/code&gt;&lt;/pre&gt;&#xA;##函数&#xA;Go中的函数可以有0个或多个参数。在下面的例子中，add函数有两个int类型的参数，注意类型在变量名的后面：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func add(x int, y int) int{&#xA;    return x + y;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(add(3,4));&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;当函数参数中连续几个属于同一个类型时，可以省略前面几个参数的类型，只保留最后一个参数的类型。例如上例中&#xA;&lt;pre&gt;&lt;code&gt;x int, y int&lt;/code&gt;&lt;/pre&gt;&#xA;可以写为：&#xA;&lt;pre&gt;&lt;code&gt;x, y int&lt;/code&gt;&lt;/pre&gt;&#xA;一个函数可以有任意数目的返回值。下面的例子中，函数swap返回了两个string：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func swap(x, y string)(string ,string){&#xA;    return y,x&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    a, b := swap(&amp;ldquo;Gavin&amp;rdquo;,&amp;ldquo;fleischer&amp;rdquo;);&#xA;    fmt.Println(a,b)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在Go中，可以像变量一样对函数的返回值命名，此时return语句不用带任何返回值：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func split(sum int)(x , y int){&#xA;    x = sum * 4 / 9&#xA;    y = sum - x&#xA;    return&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(split(17))&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##变量&#xA;使用var语句声明一个变量的列表，与函数参数列表一样，类型在变量名后面。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var x,y,z int&#xA;var c,python,java bool&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(x,y,z,c,python,java)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;var语句可以初始化每一个变量，初始化时，可以省略变量的类型。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&#xA;var x, y, z int = 1, 2, 3&#xA;var c, python, java = true, false, &amp;ldquo;no!&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    fmt.Println(x, y, z, c, python, java)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在函数体内可以使用:=短赋值语句替换var进行隐式声明。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main(){&#xA;    var x, y, z int = 1, 2, 3&#xA;    c, python, java := true, false, &amp;ldquo;no!&amp;rdquo;&#xA;    fmt.Println(x, y, z, c, python, java)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;隐式声明不能在函数体外进行，因为外部的语句块都以一个关键字开头。&#xA;##Go的基本数据类型：&#xA;Go的基本数据类型有：&#xA;&lt;pre&gt;&lt;code&gt;bool&#xA;string&#xA;int int8 int16 int32 int64&#xA;uint uint8 uint16 uint32 uint64 uintptr&#xA;byte //uint8的别名&#xA;rune //int32的别名，表示一个Unicode代码点&#xA;float32 float64&#xA;complex64 complex128&lt;/code&gt;&lt;/pre&gt;&#xA;示例：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math/cmplx&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;var (&#xA;    ToBe bool = false&#xA;    MaxInt uint64 = 1&amp;lt;&amp;lt;64 - 1&#xA;    z complex128 = cmplx.Sqrt(-5 + 12i)&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    const f = &amp;ldquo;%T(%v)\n&amp;rdquo;&#xA;    fmt.Printf(f, ToBe, ToBe)&#xA;    fmt.Printf(f, MaxInt, MaxInt)&#xA;    fmt.Printf(f, z, z)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##常量&#xA;常量声明与变量声明一样，只不过多了const关键字。常量可以是字母、字符串、布尔值或者数值。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;const Pi = 3.14&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    const World = &amp;ldquo;世界&amp;rdquo;&#xA;    fmt.Println(&amp;ldquo;Hello,&amp;rdquo;,World)&#xA;    fmt.Println(&amp;ldquo;Happy,&amp;rdquo;,Pi,&amp;ldquo;Day&amp;rdquo;)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;const Truth = true&#xA;fmt.Println(&amp;quot;Go rules?&amp;quot;,Truth)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;数字常量是高精度值，隐式常量需要根据上下文取得具体类型。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;const (&#xA;    Big = 1 &amp;lt;&amp;lt; 100&#xA;    Small = Big &amp;gt;&amp;gt; 99&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(needInt(Small))&#xA;    fmt.Println(needFloat(Small))&#xA;    fmt.Println(needFloat(Big))&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func needInt(x int) int {&#xA;    return x*10 +1&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func needFloat(x float64) float64 {&#xA;    return x * 0.1&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##循环&#xA;Go目前只有一种循环结构：for循环。&lt;br /&gt;&#xA;最基本的for循环与c或java中的很像，除了没有()（这个不能有）以及必须有{}。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    sum := 0&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        sum += i&#xA;    }&#xA;    fmt.Println(sum)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;与c或java一样，可以省略前置和后置语句：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    sum := 1&#xA;    for ; sum &amp;lt; 1000; {&#xA;        sum += sum&#xA;    }&#xA;    fmt.Println(sum)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;当前置和后置语句为空时，甚至可以省略分号，使之看起来像c的while循环那样：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    sum := 1&#xA;    for sum &amp;lt; 1000 {&#xA;        sum += sum&lt;br /&gt;&#xA;    }&#xA;    fmt.Println(sum)&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果在循环中省略循环条件，那它就是一个最简洁的死循环：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    for {&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;##if语句&#xA;if语句与c或java很像，就是没有()（这个必须不能有）和必须有{}（与for循环一样）。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func sqrt(x float64) string {&#xA;    if x &amp;lt; 0 {&#xA;        return sqrt(-x) + &amp;ldquo;i&amp;rdquo;&lt;br /&gt;&#xA;    }&#xA;    return fmt.Sprint(math.Sqrt(x))&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(sqrt(2), sqrt(-4))&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;与for循环一样，if语句在执行条件之前可以有一个短语句，这个语句中声明的变量作用域只在if语句范围内。&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func pow(x, n, lim float64) float64 {&#xA;    if v := math.Pow(x, n); v &amp;lt; lim {&#xA;        return v&#xA;    }&#xA;    return lim&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(&#xA;        pow(3, 2, 10),&#xA;        pow(3, 3, 20),&#xA;    )&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;在if的简单语句中声明的变量同样可以在任何对应的else语句块中使用：&#xA;&lt;pre&gt;&lt;code&gt;package main&lt;/p&gt;&#xA;&#xA;&lt;p&gt;import (&#xA;    &amp;ldquo;fmt&amp;rdquo;&#xA;    &amp;ldquo;math&amp;rdquo;&#xA;)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func pow(x, n, lim float64) float64 {&#xA;    if v := math.Pow(x, n); v &amp;lt; lim {&#xA;        return v&#xA;    } else {&#xA;            fmt.Printf(&amp;ldquo;%g &amp;gt;= %g\n&amp;rdquo;, v, lim)&#xA;    }&#xA;    return lim&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;func main() {&#xA;    fmt.Println(&#xA;        pow(3, 2, 10),&#xA;        pow(3, 3, 20),&#xA;    )&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>android之lint</title>
      <link>http://gavin1989.github.io/2013/03/android-lint.html</link>
      <pubDate>2013-03-14 10:49:13 +0800</pubDate>
      <description>&lt;p&gt;##lint简介&#xA;lint是Android提供的一种静态代码分析工具，用它扫描Android工程源文件可以发现一些关于源文件正确性、安全性、性能、可用性、可访问性和国际化等方面潜在的bug并且可以给出合理的优化改进建议。&#xA;##lint的语法&#xA;lint的语法比较简单：&#xA;&lt;pre&gt;&lt;code&gt;lint [flags] &amp;lt;project directory&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;例如，如果想要扫描myproject文件夹及其子文件夹下的Java和XML文件，可以使用下面的命令，结果会显示在控制台中：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;lint myproject&lt;/code&gt;&lt;/pre&gt;&#xA;上面的命令会检测源文件中所有的问题，如果只是想检测某些特定的问题，比如说XML缺少命名空间前缀的问题，可以使用下面的命令：&#xA;&lt;pre&gt;&lt;code&gt;lint &amp;ndash;check MissingPrefix myproject&lt;/code&gt;&lt;/pre&gt;&#xA;lint还可以将检测结果存储到一个指定的html文件中。比如要检查myproject文件夹的accessibility问题，并将检测结果存储为accessibility_report.html文件，可以使用下面的命令：&#xA;&lt;pre&gt;&lt;code&gt;lint &amp;ndash;check Accessibility &amp;ndash;HTML accessibility_report.html myproject&lt;/code&gt;&lt;/pre&gt;&#xA;##lint可用的命令行选项&#xA;###分类：检测（Checking）&#xA;&lt;strong&gt;&amp;ndash;disable &amp;lt;list&amp;gt;&lt;/strong&gt;：不检测list中指定的问题。如果list中包含多个ID或分类，应用半角逗号将它们分开。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;enable &amp;lt;list&amp;gt;&lt;/strong&gt;：会检测所有lint默认支持的以及list中指定的问题，如果list中包含多个ID或分类，应用半角逗号将它们分开。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;check &amp;lt;list&amp;gt;&lt;/strong&gt;：检测list中指定的问题，如果list中包含多个ID或分类，应用半角逗号将它们分开。&lt;br /&gt;&#xA;&lt;strong&gt;-w&lt;/strong&gt; 或 &lt;strong&gt;&amp;ndash;nowarn&lt;/strong&gt;：只检测error级别的问题，会忽略warning级别的问题。&lt;br /&gt;&#xA;&lt;strong&gt;-Wall&lt;/strong&gt;：检测所有的warning级别的问题，包括那些默认不检查的。&lt;br /&gt;&#xA;&lt;strong&gt;-Werror&lt;/strong&gt;：将所有的warning级别的问题都提交为error级别。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;config &amp;lt;filename&amp;gt;&lt;/strong&gt;：使用配置文件来决定检测或不检测某些问题。如果工程包含了一个lint.xml文件，则这个lint.xml就被认为是默认的配置文件。&#xA;###分类：报告（Reporting）&#xA;&lt;strong&gt;&amp;ndash;html &amp;lt;filename&amp;gt;&lt;/strong&gt;：生成一个HTML格式的报告。报告会输出到参数指定的文件中，内容包括lint检测到问题的代码片段、问题的详细描述并且会链接到源文件中。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;url &amp;lt;filepath&amp;gt;=&amp;lt;url&amp;gt;&lt;/strong&gt;：在HTML输出中，将本地路径前缀&amp;lt;filepath&amp;gt;替换为url前缀&amp;lt;url&amp;gt;。&amp;ndash;url选项只用于使用&amp;ndash;html选项生成HTML报告的情况下，可以使用多个由半角逗号分隔的&amp;lt;filepath&amp;gt;=&amp;lt;url&amp;gt;映射，如果不链接到文件，可以使用&amp;ndash;url none。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;simplehtml &amp;lt;filename&amp;gt;&lt;/strong&gt;：生成一个简单的HTML报告。报告会保存到参数指定的输出文件中。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;xml &amp;lt;filename&amp;gt;&lt;/strong&gt;：生成一个XML报告，报告会保存到参数指定的输出文件中。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;fullpath&lt;/strong&gt;：在lint的检测结果中显示文件全名。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;showall&lt;/strong&gt;：不会截断长信息或交叉位置列表。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;nolines&lt;/strong&gt;：输出中不包含源码的代码片段。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;exitcode&lt;/strong&gt;：如果发现error，则设置退出代码为1。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;quiet&lt;/strong&gt;：不显示进度指示器。&#xA;###分类：帮助（Help）&#xA;&lt;strong&gt;&amp;ndash;help&lt;/strong&gt;：列出lint工具支持的命令行参数。使用&amp;ndash;help &lt;topic&gt;查阅指定主题的帮助信息，必须“suppress”。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;list&lt;/strong&gt;：列出lint可以检测的问题的ID和简要描述。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;show&lt;/strong&gt;：列出lint可以检测的问题的ID和详细描述。使用&amp;ndash;show &lt;ids&gt;查看指定lint问题的描述。&lt;br /&gt;&#xA;&lt;strong&gt;&amp;ndash;version&lt;/strong&gt;：显示lint的版本。&#xA;##在Java和XML源文件中配置&#xA;如果不检查指定的Java类或方法，可以使用@SuppressLint注解。&lt;br /&gt;&#xA;如果不检查XML文件中的指定位置，可以使用tools:ignore属性。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之进程和线程</title>
      <link>http://gavin1989.github.io/2013/03/android-processes-and_threads.html</link>
      <pubDate>2013-03-11 05:40:19 +0800</pubDate>
      <description>&lt;p&gt;##简介：&#xA;当一个应用组件启动时，如果当前应用中没有其它正在运行的组件的话，Android系统就会为这个应用启动一个进程和一个单独的执行线程。默认情况下，同一个应用中的所有组件都运行在同一个进程和线程（主线程）中。不过，也可以让同一个应用中的不同组件运行在不同的进程，还可以在任意进程中创建另外的线程。&#xA;##进程&#xA;一般来说，大多数应用不需要改变应用程序进程的默认状态。不过，如果想要完全控制一个确定的组件所属的进程，可以通过配置manifest文件来达成目标。&lt;br /&gt;&#xA;manifest文件中的所有组件元素（&amp;lt;activity&amp;gt;、&amp;lt;service&amp;gt;、&amp;lt;receiver&amp;gt;和&amp;lt;provider&amp;gt;）都支持&lt;strong&gt;android:process&lt;/strong&gt;属性，设置这个属性可以指定当前组件运行时所在的进程。通过设置android:process属性也可以让使用同一个证书签名的不同应用的组件在同一个进程中运行，这个进程提供一个共享的Linux User ID。&#xA;&amp;lt;application&amp;gt;元素也支持android:process属性，使用它可以设置所有组件的默认值。&lt;br /&gt;&#xA;当系统内存不足并且其它进程需要更好地为用户服务时，Android可能会在某个时间点关闭一个进程。在这个进程中运行的应用组件都会被销毁。&lt;br /&gt;&#xA;###进程的生命周期&#xA;Android系统会尽可能长时间地保留应用进程，除非要为新的或更重要的进程回收内存。为了确定哪个进程要保留以及哪个进程要被杀死，系统会将所有进程放入一个基于进程中组件运行状态的“重要性等级”列表中。重要性最低的进程首先被淘汰，然后淘汰重要性次低的进程，等等。直到恢复了足够的系统资源。&lt;br /&gt;&#xA;下面是重要性等级的五个级别，重要性最高的进程会被最后杀死。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;前台进程&lt;/strong&gt;：    这种进程是用户最需要的，如果一个进程的状态符合下面任意一项，那么这个进程就被认为是前台进程：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程中驻留着正在与用户交互的Activity（Activity的onResume()方法被调用）。&lt;/li&gt;&#xA;&lt;li&gt;进程中有一个Service和正在与用户交互的Activity绑定。&lt;/li&gt;&#xA;&lt;li&gt;进程中有一个前台服务（这个Service调用了startForeground()）。&lt;/li&gt;&#xA;&lt;li&gt;进程中有一个Service正在执行生命周期回调（onCreate()、onStart()或onDestroy()）。&lt;/li&gt;&#xA;&lt;li&gt;进程中有一个BroadcastReceiver正在执行它的onReceive()方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;一般来说，一定时间只存在很少的前台进程。前台进程只有在内存极低时，才会被当作最后手段杀死。通常来说，在那个时候，设备达到了一个内存分页状态，为了用户界面的响应会杀死一些前台进程。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;可见进程&lt;/strong&gt;：    这种进程没有任何前台组件，但是仍然对用户可见。在下面两种情况下进程会被认为是可见的：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;进程中某个Activity不在前台，但是仍然对用户可见（它的onPause()被调用）。&lt;/li&gt;&#xA;&lt;li&gt;进程中有一个Service与一个可见的（或前台）Activity绑定。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;可见进程被认为是非常重要的，一般不会被杀死，除非内存不足以所有前台进程运行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Service进程&lt;/strong&gt;：   这种进程中有一条由startService()方法启动，并且不属于以上两种情况所列类型的Service。服务进程不会与用户可以看到的任何事物有直接联系，但是它们的工作却是用户会经常注意的（例如在后台播放音乐或者从网络下载数据），因此系统会保持它们运行，除非内存不足以支撑所有的前台和可见进程。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;后台进程&lt;/strong&gt;：    这种进程包含一个对用户不可见的Activity（Activity的onStop()方法已经被调用）。这种进程不会对用户的使用产生任何影响，系统可以在任意时刻杀死它们并回收内存。通常会存在很多后台进程，系统将它们保存在一个LRU列表中以保证最近加入的进程会被最后一个杀死。当一个Activity正确地实现了它的生命周期，并保存了自己的状态时，杀死它所在的进程对用户来说没有任何效果，因为当用户再次回到这个Activity时，这个Activity会恢复它所有的可视状态。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;空进程&lt;/strong&gt;：这种进程中没有任何存活的应用组件。保持这种进程存活的唯一目的就是为了缓存，它可以提高组件下次运行时的启动时间。系统经常会杀死这种进程来平衡进程缓存和底层内核缓存之间的整体系统资源Android系统通过权衡进程中当前存活的组件的重要性来将进程排入最高的那个级别。例如，如果进程有一个Service和一个可见的Activity，系统就会认为这个进程是一个可见进程，而不是服务进程。&lt;br /&gt;&#xA;另外，一个进程的排行可能会由于另外一个依赖于它的进程而增加。这是因为为其它进程提供服务的进程排行不会低于被服务的那个进程。例如，如果A进程中的一个内容提供者为B进程中的一个客户端提供服务，或者A进程中的一个Bound Service与进程B中的一个组件绑定，那么A进程的重要性至少与B进程相同。&lt;br /&gt;&#xA;由于运行一个Service的进程排行高于Activity已经进入后台的进程，所以如果要在Activity中做一个长时间运行的操作的话，应该最好为这个操作启动一个Service，而不是简单地创建一条工作线程——特别是这个操作可能比Activity更持久的情况下。例如，Activity要向服务器上传一张图片的话，应该启动一个服务来执行上传任务，在这种情况下，就算用户离开Activity，任务也会在后台继续。无论对Activity做了什么，使用Service能保证操作至少有服务进程级别的优先级。这也跟广播接受者使用服务而不是简单地把耗时操作放入线程中的原因。&#xA;##线程：&#xA;一个应用启动后，系统就会为应用创建一个名为“main”的执行线程。这个线程非常重要，因为它负责为适当的用户界面调度事件，包括绘制事件。它也是应用与Android UI工具包中的组件发生交互所在的线程，因此，main线程也被称为UI线程。&lt;br /&gt;&#xA;系统不能为组件的实例创建不同的线程。所有运行在同一个进程中的组件都在UI线程中初始化，系统对每个组件的调用都会经过UI线程的调度。所以，对系统回调方法的回应也发生在进程的UI线程中。&lt;br /&gt;&#xA;在这种情况下，当用户触摸屏幕上的一个按钮时，应用的UI线程会为这个Widget调度触摸事件，这个触摸事件包括将按钮的状态设置为按下并且向事件队列发送一个invalidate请求。UI线程会从队列中取出请求并通知这个Widget重绘自己。&lt;br /&gt;&#xA;当应用执行对用户来说非常细致的工作时，这种单线程模型可能产生不良的影响。具体来说，如果在UI线程中执行一个长时间的操作，比如访问网络或者查询数据库时，这种操作会导致阻塞整个UI。当线程阻塞时，就不能调度任何事件，包括绘制事件。从用户的角度来看，就是应用程序挂起。更糟的是，如果UI线程被阻塞大约5秒，系统就会为用户弹出臭名昭著的ANR对话框。然后用户可能决定退出并卸载这个让他不愉快的应用。&lt;br /&gt;&#xA;另外，Android UI工具包不是线程安全的。所以，必须在UI线程中处理所有对用户界面的操作。因此，对于单线程模型有两条最基本的规则：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;不能阻塞UI线程。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;不要在UI线程以外访问Android UI工具包。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;###工作线程&#xA;如果执行的操作不是瞬时的，就应该将它们放到单独的线程（后台线程或工作线程）中执行。&lt;br /&gt;&#xA;下面是一个例子，当监听到点击事件后，就在一个单独的线程中下载图片并交给一个ImageView显示：&#xA;&lt;pre&gt;&lt;code&gt;public void onClick(View v) {&#xA;    new Thread(new Runnable() {&#xA;        public void run() {&#xA;            Bitmap b = loadImageFromNetwork(&amp;ldquo;http://example.com/image.png&amp;rdquo;);&#xA;            mImageView.setImageBitmap(b);&#xA;        }&#xA;    }).start();&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;这段代码看起来会正常运行，但是由于它没有遵守单线程模型的第二条规则：不要在UI线程以外访问Android UI工具包，所以可能导致未定义的和意外的行为，这种行为追查起来可能是非常困难而且耗时的。&lt;br /&gt;&#xA;要解决这个问题，Android提供了以下几种从其它线程访问UI线程的途径：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Activity.runOnUiThread(Runnable)&lt;/li&gt;&#xA;&lt;li&gt;View.post(Runnable)&lt;/li&gt;&#xA;&lt;li&gt;View.postDelayed(Runnable,long)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;例如，可以使用View.post(Runnable)方法来修复上面的代码：&#xA;&lt;pre&gt;&lt;code&gt;public void onClick(View v) {&#xA;    new Thread(new Runnable() {&#xA;        public void run() {&#xA;            final Bitmap bitmap = loadImageFromNetwork(&amp;ldquo;http://example.com/image.png&amp;rdquo;);&#xA;            mImageView.post(new Runnable() {&#xA;                public void run() {&#xA;                    mImageView.setImageBitmap(bitmap);&#xA;                }&#xA;            });&#xA;        }&#xA;    }).start();&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;问题似乎完美解决了，然而，由于操作的复杂性的增加，这种代码也会变得非常复杂并且难以维护。为了处理与工作者线程之间更复杂的交互，应该考虑在工作者线程中使用一个Handler处理来自UI线程的消息。可能最好的办法是继承AsyncTask类，它简化了UI与工作者线程交互的过程。&#xA;###使用AsyncTask&#xA;AsyncTask允许在用户界面上执行一个同步操作。它在工作者线程中执行阻塞操作并在UI线程中返回结果，而不需要自己处理线程和Handler。&lt;br /&gt;&#xA;要使用它，首先得创建一个AsyncTask的子类并实现doInBackground()回调方法，这个方法运行在一个后台线程池中。要更新UI的话，还应该实现onPostExecute()方法，这个方法运行在UI线程并且从doInBackground()方法中取回结果，因此可以安全地更新UI。可以在UI线程中调用execute()来执行任务。&lt;br /&gt;&#xA;下面是前一个例子使用AsyncTask的实现：&#xA;&lt;pre&gt;&lt;code&gt;public void onClick(View v) {&#xA;    new DownloadImageTask().execute(&amp;ldquo;http://example.com/image.png&amp;rdquo;);&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; {&#xA;    /** The system calls this to perform work in a worker thread and&#xA;      * delivers it the parameters given to AsyncTask.execute() */&#xA;    protected Bitmap doInBackground(String&amp;hellip; urls) {&#xA;        return loadImageFromNetwork(urls[0]);&#xA;    }&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/** The system calls this to perform work in the UI thread and delivers&#xA;  * the result from doInBackground() */&#xA;protected void onPostExecute(Bitmap result) {&#xA;    mImageView.setImageBitmap(result);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之AIDL</title>
      <link>http://gavin1989.github.io/2013/03/android-aidl.html</link>
      <pubDate>2013-03-10 07:57:28 +0800</pubDate>
      <description>&lt;p&gt;###AIDL简介：&#xA;AIDL（Android Interface Definition Language）与其它IDL类似，它允许定义一个客户端和Service都认同的编程接口以便它们可以使用IPC进行交互。在Android中，一个进程通常不能访问另外一个进程的内存。也就是说，应该将对象分解成操作系统可以理解的基本数据类型，并且伪装成对象跨越进程边界。编写这样的伪装代码是非常枯燥的，所以Android提供了AIDL工具。&lt;br /&gt;&#xA;注意：应该只在其它应用想要通过IPC访问Service并且想要在Service中进行多线程处理的情况下才使用AIDL。如果不需要跨进程，就应该使用Binder；而如果想要执行IPC，但不需要处理多线程，就应该使用Messenger。&lt;br /&gt;&#xA;在设计AIDL接口之前，应该知道对一个AIDL接口的调用是直接的方法调用。不应该对发生调用的线程做出假设。调用来自本地进程的线程和远程进程是不一样的：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;调用来自本地进程，此时处理过程会在发生调用的线程中进行。因此，如果只有本地线程访问Service，应该完全控制执行代码的线程。&lt;/li&gt;&#xA;&lt;li&gt;调用来自远程进程，此时这些调用由本地进程的一个线程池管理。因此必须准备在同一时间接收来自未知线程的多次调用，也就是说，AIDL接口的实现必须是完全线程安全的。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用oneway关键字可以修改远程调用的行为，此时，远程调用不会阻塞，它只是简单地发送数据并立即返回。接口的实现最终接收到的是与正常的Binder线程池一样的普通远程调用。如果oneway用于本地调用，则不会造成任何影响，此时调用仍然是同步的。&#xA;##定义一个AIDL接口：&#xA;首先在一个.aidl文件中使用Java语言的语法定义AIDL接口，然后将它保存在Service所在的应用以及其它所有需要绑定到此Service的应用的源代码文件夹(src)中。当编译包含.aidl文件的应用时，Android SDK tools会基于.aidl文件生成一个IBinder接口并将它保存在工程的gen文件夹中。Service必须适当地实现这个IBinder，然后客户端应用绑定到Service后就可以通过这个IBinder调用方法以执行IPC。&lt;br /&gt;&#xA;要使用AIDL创建一个Bound Service，有以下几个步骤：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建.aidl文件：这个文件定义了编程接口的方法签名。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;实现这个接口：Android SDK tools会基于.aidl文件生成一个接口。这个接口包含一个名为Stub的继承自Binder的内部抽象类，Stub类包含AIDL接口声明的所有方法。必须继承Stub类并实现这些方法。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;为客户端暴露接口：实现一个Service，重写onBind()方法并返回Stub类的实现。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：AIDL接口的每一次改变都应该兼容上一个版本。&#xA;###创建一个.aidl文件&#xA;AIDL的语法特别简单。可以声明一个包含一个或多个方法的接口，这些方法可以带有参数或返回类型。方法参数和返回值类型可以是任意AIDL支持的数据类型，或者其它AIDL生成的接口。&lt;br /&gt;&#xA;必须使用Java语言构建.aidl文件，每一个.aidl文件必须定义一个单独的接口，并且只包含接口声明和方法签名。&lt;br /&gt;&#xA;默认情况下，AIDL支持以下的数据类型：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有Java中的基本数据类型（例如int、long、char、boolean等等）。&lt;/li&gt;&#xA;&lt;li&gt;String&lt;/li&gt;&#xA;&lt;li&gt;CharSequence&lt;/li&gt;&#xA;&lt;li&gt;List：List中的所有元素必须是下列类型中的一种：1)AIDL支持的数据类型中的一种；2)其它AIDL生成的接口；3）已声明的可序列化的类型。支持泛型。而且就算方法签名中用的是List接口，在其它地方接收到的实际类型也是ArrayList。&lt;/li&gt;&#xA;&lt;li&gt;Map：与List的元素的类型要求一样。而且其它地方接收到的实际类型总是HashMap。与List不同的是不支持泛型Map。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;需要注意的是，不在以上列表中的每一个用到的类型都必须加入到import语句中，即使这个类与接口在同一个包里。&lt;br /&gt;&#xA;定义Service接口需要知道的事情：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;方法可以有0个或多个参数，可以有返回值也可以没有。&lt;/li&gt;&#xA;&lt;li&gt;所有非基本数据类型要有一个代表数据来路或去向的标签，这个标签可以是in、out或inout中的一个。&lt;/li&gt;&#xA;&lt;li&gt;所有.aidl文件中的代码注释也会包含到生成的IBinder接口中（import语句与package语句之间的注释除外）。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;AIDL中仅支持方法，不能定义静态常量。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;// IRemoteService.aidl&#xA;package com.example.android;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Declare any non-default types here with import statements&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/** Example service interface */&#xA;interface IRemoteService {&#xA;    /** Request the process ID of this service, to do evil things with it. */&#xA;    int getPid();&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/** Demonstrates some basic types that you can use as parameters&#xA; * and return values in AIDL.&#xA; */&#xA;void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,&#xA;        double aDouble, String aString);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;将.aidl文件放入工程的src文件夹下并编译工程，SDK tools就会在gen文件夹下生成IBinder接口文件。且生成的文件名与.aidl文件名匹配，只不过是.java扩展名。&#xA;###实现这个接口&#xA;生成.java接口文件后，这个生成的接口包含了一个名为Stub的抽象类实现，这个实现中包含了所有在.aidl文件中声明的方法。&#xA;&lt;pre&gt;&lt;code&gt;private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {&#xA;public int getPid(){&#xA;    return Process.myPid();&#xA;}&#xA;public void basicTypes(int anInt, long aLong, boolean aBoolean,&#xA;    float aFloat, double aDouble, String aString) {&#xA;    // Does nothing&#xA;}&#xA;};&lt;/code&gt;&lt;/pre&gt;&#xA;这地方的mBinder就是Stub类的一个实例，这个Stub类描述了Service的RPC接口。在下一步中，会将这个实例提供给客户端。&lt;br /&gt;&#xA;下面是一些实现AIDL接口时需要知道的规则：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;接收到的调用不能保证是在主线程中执行的，因此需要考虑多线程并且将Service正确地构建为线程安全的。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;RPC调用默认是同步的，如果知道Service不能在很短的时间内完成请求，就不应该在Activity的主线程中发送请求，因为这可能导致应用程序挂起。所以调用一般应该在客户端之外的线程进行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;没有可以抛给调用者的异常。&#xA;###给客户端暴露接口&#xA;一旦实现了Service的接口，就应该将它暴露给可以绑定到它的客户端。要暴露Service接口，就要继承Service类并且实现onBind()方法，并且返回一个生成的Stub类的实例。&#xA;&lt;pre&gt;&lt;code&gt;public class RemoteService extends Service {&#xA;@Override&#xA;public void onCreate() {&#xA;    super.onCreate();&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@Override&#xA;public IBinder onBind(Intent intent) {&#xA;    // Return the interface&#xA;    return mBinder;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {&#xA;    public int getPid(){&#xA;        return Process.myPid();&#xA;    }&#xA;    public void basicTypes(int anInt, long aLong, boolean aBoolean,&#xA;        float aFloat, double aDouble, String aString) {&#xA;        // Does nothing&#xA;    }&#xA;};&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;现在，当一个客户端调用bindService()连接到Service时，客户端的onServiceConnected()回调方法就会接收到Service的onBind()方法返回的mBinder实例。&lt;br /&gt;&#xA;由于客户端必须可以访问这个接口，因此在客户端与Service属于不同应用的情况下，客户端应用必须将相关的.aidl文件复制到自己工程的src文件夹下。&lt;br /&gt;&#xA;当客户端在onServiceConnected()回调中接收到IBinder实例后，必须调用YourServiceInterface.Stub.asInterface(service)将返回的参数转换为YourServiceInterface类型。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;IRemoteService mIRemoteService;&#xA;private ServiceConnection mConnection = new ServiceConnection() {&#xA;// Called when the connection with the service is established&#xA;public void onServiceConnected(ComponentName className, IBinder service) {&#xA;    // Following the example above for an AIDL interface,&#xA;    // this gets an instance of the IRemoteInterface, which we can use to call on the service&#xA;    mIRemoteService = IRemoteService.Stub.asInterface(service);&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Called when the connection with the service disconnects unexpectedly&#xA;public void onServiceDisconnected(ComponentName className) {&#xA;    Log.e(TAG, &amp;ldquo;Service has unexpectedly disconnected&amp;rdquo;);&#xA;    mIRemoteService = null;&#xA;}&#xA;};&lt;/code&gt;&lt;/pre&gt;&#xA;###通过IPC传递对象&#xA;如果想在进程间通过IPC接口传送自己的类，就需要确保这个类的代码对另一侧的IPC通道也是可用的，并且这个类必须支持Parcelable接口。支持Parcelable接口可以让Android系统将对象分解为基本数据类型，以便跨进程。&lt;br /&gt;&#xA;要创建一个支持Parcelable协议的类，有以下几个步骤：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;让这个类实现Parcelable接口。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;实现writeToParcel方法，这个方法可以将对象当前的状态写入一个Parcel。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;在类中添加一个名为CREATOR的静态常量，这个静态常量是Parcelable.Creator接口的一个实现。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;最后，创建一个.aidl文件声明这个类。这个.aidl文件在编译过程中不会被编译，它就类似于C语言中的头文件。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;例如，下面是Rect.aidl文件：&#xA;&lt;pre&gt;&lt;code&gt;package android.graphics;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Declare Rect so AIDL can find it and knows that it implements&#xA;// the parcelable protocol.&#xA;parcelable Rect;&lt;/code&gt;&lt;/pre&gt;&#xA;下面是Rect类实现Parcelable协议的一个例子：&#xA;&lt;pre&gt;&lt;code&gt;import android.os.Parcel;&#xA;import android.os.Parcelable;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;public final class Rect implements Parcelable {&#xA;    public int left;&#xA;    public int top;&#xA;    public int right;&#xA;    public int bottom;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static final Parcelable.Creator&amp;lt;Rect&amp;gt; CREATOR = new Parcelable.Creator&amp;lt;Rect&amp;gt;() {&#xA;    public Rect createFromParcel(Parcel in) {&#xA;        return new Rect(in);&#xA;    }&#xA;&#xA;    public Rect[] newArray(int size) {&#xA;        return new Rect[size];&#xA;    }&#xA;};&#xA;&#xA;public Rect() {&#xA;}&#xA;&#xA;private Rect(Parcel in) {&#xA;    readFromParcel(in);&#xA;}&#xA;&#xA;public void writeToParcel(Parcel out) {&#xA;    out.writeInt(left);&#xA;    out.writeInt(top);&#xA;    out.writeInt(right);&#xA;    out.writeInt(bottom);&#xA;}&#xA;&#xA;public void readFromParcel(Parcel in) {&#xA;    left = in.readInt();&#xA;    top = in.readInt();&#xA;    right = in.readInt();&#xA;    bottom = in.readInt();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;###调用一个IPC方法&#xA;下面是一个类调用AIDL定义的远程接口必需的步骤：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在工程的src文件夹下定义一个.aidl文件。&lt;/li&gt;&#xA;&lt;li&gt;声明一个IBinder接口（基于AIDL生成）的实例。&lt;/li&gt;&#xA;&lt;li&gt;实现ServiceConnection。&lt;/li&gt;&#xA;&lt;li&gt;通过ServiceConnection实现调用Context.bindService()。&lt;/li&gt;&#xA;&lt;li&gt;在onServiceConnected()实现中，会接收到一个名为service的IBinder实例。调用YourInterfaceName.Stub.asInterface((IBinder)service)方法将返回的参数转换为YourInterface类型。&lt;/li&gt;&#xA;&lt;li&gt;调用在接口中定义的方法时，应该始终捕获DeadObjectException异常。&lt;/li&gt;&#xA;&lt;li&gt;连接断开时，使用接口实例调用Context.unbindService()。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;调用一个IPC Service的一些注释：&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;对象被跨进程引用计数。&#xA;2.可以将匿名对象作为方法参数发送。&#xA;&lt;pre&gt;&lt;code&gt;public static class Binding extends Activity {&#xA;/** The primary interface we will be calling on the service. */&#xA;IRemoteService mService = null;&#xA;/** Another interface we use on the service. */&#xA;ISecondary mSecondaryService = null;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Button mKillButton;&#xA;TextView mCallbackText;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private boolean mIsBound;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/**&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Standard initialization of this activity.  Set up the UI, then wait&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;for the user to poke it before doing anything.&#xA;*/&#xA;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;super.onCreate(savedInstanceState);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;setContentView(R.layout.remote_service_binding);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;// Watch for button clicks.&#xA;Button button = (Button)findViewById(R.id.bind);&#xA;button.setOnClickListener(mBindListener);&#xA;button = (Button)findViewById(R.id.unbind);&#xA;button.setOnClickListener(mUnbindListener);&#xA;mKillButton = (Button)findViewById(R.id.kill);&#xA;mKillButton.setOnClickListener(mKillListener);&#xA;mKillButton.setEnabled(false);&lt;/p&gt;&#xA;&#xA;&lt;p&gt;mCallbackText = (TextView)findViewById(R.id.callback);&#xA;mCallbackText.setText(&amp;ldquo;Not attached.&amp;rdquo;);&#xA;}&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;/**&#xA; * Class for interacting with the main interface of the service.&#xA; */&#xA;private ServiceConnection mConnection = new ServiceConnection() {&#xA;    public void onServiceConnected(ComponentName className,&#xA;            IBinder service) {&#xA;        // This is called when the connection with the service has been&#xA;        // established, giving us the service object we can use to&#xA;        // interact with the service.  We are communicating with our&#xA;        // service through an IDL interface, so get a client-side&#xA;        // representation of that from the raw service object.&#xA;        mService = IRemoteService.Stub.asInterface(service);&#xA;        mKillButton.setEnabled(true);&#xA;        mCallbackText.setText(&amp;ldquo;Attached.&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    // We want to monitor the service for as long as we are&#xA;    // connected to it.&#xA;    try {&#xA;        mService.registerCallback(mCallback);&#xA;    } catch (RemoteException e) {&#xA;        // In this case the service has crashed before we could even&#xA;        // do anything with it; we can count on soon being&#xA;        // disconnected (and then reconnected if it can be restarted)&#xA;        // so there is no need to do anything here.&#xA;    }&#xA;&#xA;&#xA;    // As part of the sample, tell the user what happened.&#xA;    Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show();&#xA;}&#xA;&#xA;&#xA;public void onServiceDisconnected(ComponentName className) {&#xA;    // This is called when the connection with the service has been&#xA;    // unexpectedly disconnected -- that is, its process crashed.&#xA;    mService = null;&#xA;    mKillButton.setEnabled(false);&#xA;    mCallbackText.setText(&amp;quot;Disconnected.&amp;quot;);&#xA;&#xA;&#xA;    // As part of the sample, tell the user what happened.&#xA;    Toast.makeText(Binding.this, R.string.remote_service_disconnected,&#xA;            Toast.LENGTH_SHORT).show();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;};&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/**&#xA; * Class for interacting with the secondary interface of the service.&#xA; */&#xA;private ServiceConnection mSecondaryConnection = new ServiceConnection() {&#xA;    public void onServiceConnected(ComponentName className,&#xA;            IBinder service) {&#xA;        // Connecting to a secondary interface is the same as any&#xA;        // other interface.&#xA;        mSecondaryService = ISecondary.Stub.asInterface(service);&#xA;        mKillButton.setEnabled(true);&#xA;    }&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void onServiceDisconnected(ComponentName className) {&#xA;    mSecondaryService = null;&#xA;    mKillButton.setEnabled(false);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;};&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private OnClickListener mBindListener = new OnClickListener() {&#xA;    public void onClick(View v) {&#xA;        // Establish a couple connections with the service, binding&#xA;        // by interface names.  This allows other applications to be&#xA;        // installed that replace the remote service by implementing&#xA;        // the same interface.&#xA;        bindService(new Intent(IRemoteService.class.getName()),&#xA;                mConnection, Context.BIND_AUTO_CREATE);&#xA;        bindService(new Intent(ISecondary.class.getName()),&#xA;                mSecondaryConnection, Context.BIND_AUTO_CREATE);&#xA;        mIsBound = true;&#xA;        mCallbackText.setText(&amp;ldquo;Binding.&amp;rdquo;);&#xA;    }&#xA;};&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private OnClickListener mUnbindListener = new OnClickListener() {&#xA;    public void onClick(View v) {&#xA;        if (mIsBound) {&#xA;            // If we have received the service, and hence registered with&#xA;            // it, then now is the time to unregister.&#xA;            if (mService != null) {&#xA;                try {&#xA;                    mService.unregisterCallback(mCallback);&#xA;                } catch (RemoteException e) {&#xA;                    // There is nothing special we need to do if the service&#xA;                    // has crashed.&#xA;                }&#xA;            }&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        // Detach our existing connection.&#xA;        unbindService(mConnection);&#xA;        unbindService(mSecondaryConnection);&#xA;        mKillButton.setEnabled(false);&#xA;        mIsBound = false;&#xA;        mCallbackText.setText(&amp;quot;Unbinding.&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;};&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private OnClickListener mKillListener = new OnClickListener() {&#xA;    public void onClick(View v) {&#xA;        // To kill the process hosting our service, we need to know its&#xA;        // PID.  Conveniently our service has a call that will return&#xA;        // to us that information.&#xA;        if (mSecondaryService != null) {&#xA;            try {&#xA;                int pid = mSecondaryService.getPid();&#xA;                // Note that, though this API allows us to request to&#xA;                // kill any process based on its PID, the kernel will&#xA;                // still impose standard restrictions on which PIDs you&#xA;                // are actually able to kill.  Typically this means only&#xA;                // the process running your application and any additional&#xA;                // processes created by that app as shown here; packages&#xA;                // sharing a common UID will also be able to kill each&#xA;                // other&amp;rsquo;s processes.&#xA;                Process.killProcess(pid);&#xA;                mCallbackText.setText(&amp;ldquo;Killed service process.&amp;rdquo;);&#xA;            } catch (RemoteException ex) {&#xA;                // Recover gracefully from the process hosting the&#xA;                // server dying.&#xA;                // Just for purposes of the sample, put up a notification.&#xA;                Toast.makeText(Binding.this,&#xA;                        R.string.remote_call_failed,&#xA;                        Toast.LENGTH_SHORT).show();&#xA;            }&#xA;        }&#xA;    }&#xA;};&#xA;// &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&#xA;// Code showing how to deal with callbacks.&#xA;// &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/**&#xA; * This implementation is used to receive callbacks from the remote&#xA; * service.&#xA; */&#xA;private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {&#xA;    /**&#xA;     * This is called by the remote service regularly to tell us about&#xA;     * new values.  Note that IPC calls are dispatched through a thread&#xA;     * pool running in each process, so the code executing here will&#xA;     * NOT be running in our main thread like most other things &amp;ndash; so,&#xA;     * to update the UI, we need to use a Handler to hop over there.&#xA;     */&#xA;    public void valueChanged(int value) {&#xA;        mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));&#xA;    }&#xA;};&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private static final int BUMP_MSG = 1;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private Handler mHandler = new Handler() {&#xA;    @Override public void handleMessage(Message msg) {&#xA;        switch (msg.what) {&#xA;        case BUMP_MSG:&#xA;            mCallbackText.setText(&amp;ldquo;Received from service: &amp;ldquo; + msg.arg1);&#xA;            break;&#xA;        default:&#xA;            super.handleMessage(msg);&#xA;        }&#xA;    }&#xA;};&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Bound Service</title>
      <link>http://gavin1989.github.io/2013/03/android-bound-service.html</link>
      <pubDate>2013-03-10 12:35:09 +0800</pubDate>
      <description>&lt;p&gt;##Bound Service简介：&#xA;Bound Service相当于C/S架构中的Server。它允许其它组件（客户端）绑定到它，向它发送请求并接受应答，甚至执行IPC。Bound Service适用于需要向其它组件提供服务，并且不会在后台无限期运行的场合。&lt;br /&gt;&#xA;要实现一个Bound Service，必须重写onBind()回调方法。这个方法返回一个定义了客户端与服务端编程接口的IBinder对象。客户端可以调用bindService()绑定到Service，此时客户端必须提供一个ServiceConnection的实现，这个实现可以监控与Service的连接。bindService()方法会立即返回（返回类型为void），当系统在客户端与Service之间创建一个连接后，ServiceConnection的onServiceConnected()方法就会被调用，此时客户端就可以得到IBinder对象并用它与Service交互。&lt;br /&gt;&#xA;多个客户端可以同时绑定到一个Service，但是，系统只会在第一个客户端绑定到时调用onBind()方法，后来绑定到的客户端都会被返回与第一个绑定到的客户端相同的IBinder。&lt;br /&gt;&#xA;当最后一个客户端从Service解绑后，系统就会销毁这个Service（除非Service同时是被startService()启动的）。&#xA;##创建一个Bound Service&#xA;定义IBinder接口，可以有三种方式：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;继承Binder类：当Service相对于自己的应用是私有的，并且与客户端运行在同一个进程，就应该通过onBind()返回一个继承自Binder类的实例。客户端接收到这个Binder后，可以用它直接访问这个Binder实现甚至Service的公共方法。&lt;br /&gt;&#xA;如果Service只是在后台为自己的应用工作，这是最好的技术。&lt;/li&gt;&#xA;&lt;li&gt;使用Messenger：如果接口需要在不同进程间工作，可以为Service提供一个Messenger接口。在这种方式中，Service使用一个Handler应答不同类型的Message对象。这个Handler是Messenger的基础，它与客户端共享一个IBinder，并且允许客户端使用Message对象向Service发送命令。另外，客户端可以定义一个自己的Messenger，这样Service就可以使用这个Messenger向它返回结果。&lt;br /&gt;&#xA;这是执行IPC的最简单的方式，由于Messenger将所有请求顺序排入了一个单线程，所以Service不用设计成线程安全的。&lt;/li&gt;&#xA;&lt;li&gt;使用AIDL:AIDL（Android Interface Definition Language，Android接口描述语言）将所有的工作对象分解为操作系统可认的基本数据类型，并且安排它们跨进程以执行IPC。Messenger实际上正是基于AIDL底层结构的技术。如上文所说，Messenger在一个单线程中创建一个包含所有客户端请求的队列，因此Service只能同时接收一个请求。所以，如果希望Service可以同时处理多个请求，就应该直接使用AIDL。此时，Service必须能在多线程下工作，并且是线程安全的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：大多数应用不应该使用AIDL去创建一个Bound Service，因为它可能需要多线程能力并导致更复杂的实现。因此，AIDL是不适用于大多数应用的。&#xA;##继承Binder类&#xA;如果Service只被用于本地应用并且不需要跨进程，可以给客户端提供一个自己的Binder实现，客户端可以通过这个Binder直接访问Service的公共方法。&lt;br /&gt;&#xA;注意：这种方式只适合于客户端和Service处于相同的应用和进程的情况下。&lt;br /&gt;&#xA;下面是建立这种方式的步骤：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Service中，创建一个下面三种方式中任意一个类型的Binder实例：&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包含客户端可以调用的公共方法。&lt;/li&gt;&#xA;&lt;li&gt;返回当前的Service实例，这个Service拥有客户端可以调用的公共方法。&lt;/li&gt;&#xA;&lt;li&gt;或者，返回一个Service中另外一个类的实例，客户端可以通过这个实例调用Service中的公共方法。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;从onBind()回调方法中返回这个Binder实例。&lt;/li&gt;&#xA;&lt;li&gt;在客户端中，在onServiceConnected()回调方法中接收Binder，并且使用这个Binder调用Bound Service中的方法。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Service和客户端必须要在同一个应用中的理由是客户端可以转换返回的对象并且正确地调用它的API。Service和客户端必须在同一个进程，是因为这种技术不能执行任何跨进程的任务。&lt;br /&gt;&#xA;下面是Android文档提供的一个例子：&#xA;&lt;pre&gt;&lt;code&gt;public class LocalService extends Service {&#xA;    // Binder given to clients&#xA;    private final IBinder mBinder = new LocalBinder();&#xA;    // Random number generator&#xA;    private final Random mGenerator = new Random();&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * Class used for the client Binder.  Because we know this service always&#xA; * runs in the same process as its clients, we don&#39;t need to deal with IPC.&#xA; */&#xA;public class LocalBinder extends Binder {&#xA;    LocalService getService() {&#xA;        // Return this instance of LocalService so clients can call public methods&#xA;        return LocalService.this;&#xA;    }&#xA;}&#xA;&#xA;@Override&#xA;public IBinder onBind(Intent intent) {&#xA;    return mBinder;&#xA;}&#xA;&#xA;/** method for clients */&#xA;public int getRandomNumber() {&#xA;    return mGenerator.nextInt(100);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;LocalBinder为客户端提供了getService()方法来获得LocalService的实例。这种方式允许客户端调用Service的公共方法。例如，客户端可以调用LocalService的getRandomNumber()方法。&lt;br /&gt;&#xA;下面是一个绑定到LocalService的Activity，当一个button被点击时就会调用getRandomNumber()。&#xA;&lt;pre&gt;&lt;code&gt;public class BindingActivity extends Activity {&#xA;    LocalService mService;&#xA;    boolean mBound = false;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.main);&#xA;}&#xA;&#xA;@Override&#xA;protected void onStart() {&#xA;    super.onStart();&#xA;    // Bind to LocalService&#xA;    Intent intent = new Intent(this, LocalService.class);&#xA;    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#xA;}&#xA;&#xA;@Override&#xA;protected void onStop() {&#xA;    super.onStop();&#xA;    // Unbind from the service&#xA;    if (mBound) {&#xA;        unbindService(mConnection);&#xA;        mBound = false;&#xA;    }&#xA;}&#xA;&#xA;/** Called when a button is clicked (the button in the layout file attaches to&#xA; * this method with the android:onClick attribute) */&#xA;public void onButtonClick(View v) {&#xA;    if (mBound) {&#xA;        // Call a method from the LocalService.&#xA;        // However, if this call were something that might hang, then this request should&#xA;        // occur in a separate thread to avoid slowing down the activity performance.&#xA;        int num = mService.getRandomNumber();&#xA;        Toast.makeText(this, &amp;quot;number: &amp;quot; + num, Toast.LENGTH_SHORT).show();&#xA;    }&#xA;}&#xA;&#xA;/** Defines callbacks for service binding, passed to bindService() */&#xA;private ServiceConnection mConnection = new ServiceConnection() {&#xA;&#xA;    @Override&#xA;    public void onServiceConnected(ComponentName className,&#xA;            IBinder service) {&#xA;        // We&#39;ve bound to LocalService, cast the IBinder and get LocalService instance&#xA;        LocalBinder binder = (LocalBinder) service;&#xA;        mService = binder.getService();&#xA;        mBound = true;&#xA;    }&#xA;&#xA;    @Override&#xA;    public void onServiceDisconnected(ComponentName arg0) {&#xA;        mBound = false;&#xA;    }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;##使用Messenger&#xA;如果需要Service与远程进程交互，就可以使用一个Messenger暴露这个Service的接口。这种技术允许不通过AIDL执行IPC。&lt;br /&gt;&#xA;下面是关于如何使用Messenger的简介：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Service提供一个Handler实现，这个Handler接收来自一个客户端的每一个调用的回调。&lt;/li&gt;&#xA;&lt;li&gt;用Handler来创建一个Messenger对象，这个对象拥有前面Handler的一个引用。&lt;/li&gt;&#xA;&lt;li&gt;这个Messenger对象创建一个IBinder，随后Service从onBind()向客户端返回这个IBinder对象。&lt;/li&gt;&#xA;&lt;li&gt;客户端使用这个IBinder初始化拥有Service的Handler引用的Messenger，客户端可以使用这个Messenger对象向Service发送Message对象。&lt;/li&gt;&#xA;&lt;li&gt;Service在Handler的handleMessage()方法中接收每一个Message。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在这种情况下，客户端不会去调用Service中的方法，取而代之的是，客户端给Service的Handler提供消息。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;public class MessengerService extends Service {&#xA;    /** Command to the service to display a message */&#xA;    static final int MSG_SAY_HELLO = 1;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/**&#xA; * Handler of incoming messages from clients.&#xA; */&#xA;class IncomingHandler extends Handler {&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        switch (msg.what) {&#xA;        case MSG_SAY_HELLO:&#xA;            Toast.makeText(getApplicationContext(), &amp;quot;hello!&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;            break;&#xA;        default:&#xA;            super.handleMessage(msg);&#xA;        }&#xA;    }&#xA;}&#xA;&#xA;/**&#xA; * Target we publish for clients to send messages to IncomingHandler.&#xA; */&#xA;final Messenger mMessenger = new Messenger(new IncomingHandler());&#xA;&#xA;/**&#xA; * When binding to the service, we return an interface to our messenger&#xA; * for sending messages to the service.&#xA; */&#xA;@Override&#xA;public IBinder onBind(Intent intent) {&#xA;    Toast.makeText(getApplicationContext(), &amp;quot;binding&amp;quot;, Toast.LENGTH_SHORT).show();&#xA;    return mMessenger.getBinder();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;此时，客户端需要做的就是基于Service返回的IBinder创建一个Messenger对象，并且使用send()发送一条消息。&#xA;&lt;pre&gt;&lt;code&gt;public class ActivityMessenger extends Activity {&#xA;    /** Messenger for communicating with the service. */&#xA;    Messenger mService = null;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/** Flag indicating whether we have called bind on the service. */&#xA;boolean mBound;&#xA;&#xA;/**&#xA; * Class for interacting with the main interface of the service.&#xA; */&#xA;private ServiceConnection mConnection = new ServiceConnection() {&#xA;    public void onServiceConnected(ComponentName className, IBinder service) {&#xA;        // This is called when the connection with the service has been&#xA;        // established, giving us the object we can use to&#xA;        // interact with the service.  We are communicating with the&#xA;        // service using a Messenger, so here we get a client-side&#xA;        // representation of that from the raw IBinder object.&#xA;        mService = new Messenger(service);&#xA;        mBound = true;&#xA;    }&#xA;&#xA;    public void onServiceDisconnected(ComponentName className) {&#xA;        // This is called when the connection with the service has been&#xA;        // unexpectedly disconnected -- that is, its process crashed.&#xA;        mService = null;&#xA;        mBound = false;&#xA;    }&#xA;};&#xA;&#xA;public void sayHello(View v) {&#xA;    if (!mBound) return;&#xA;    // Create and send a message to the service, using a supported &#39;what&#39; value&#xA;    Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);&#xA;    try {&#xA;        mService.send(msg);&#xA;    } catch (RemoteException e) {&#xA;        e.printStackTrace();&#xA;    }&#xA;}&#xA;&#xA;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;    super.onCreate(savedInstanceState);&#xA;    setContentView(R.layout.main);&#xA;}&#xA;&#xA;@Override&#xA;protected void onStart() {&#xA;    super.onStart();&#xA;    // Bind to the service&#xA;    bindService(new Intent(this, MessengerService.class), mConnection,&#xA;        Context.BIND_AUTO_CREATE);&#xA;}&#xA;&#xA;@Override&#xA;protected void onStop() {&#xA;    super.onStop();&#xA;    // Unbind from the service&#xA;    if (mBound) {&#xA;        unbindService(mConnection);&#xA;        mBound = false;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果希望得到Service的回应，就需要在客户端中创建一个Messenger。然后在客户端接收到onServiceConnected()回调的时候，使用send()发送一个包含了客户端Messenger对象（将Message对象的replyTo参数设为此Messenger对象）的Message给Service。&#xA;###另外需要注意的一些地方：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应该始终捕获DeadObjectException异常，当连接被破坏的时候会抛出这个异常。它也是远程方法唯一可以抛出的异常。&lt;/li&gt;&#xA;&lt;li&gt;对象在整个过程都持有引用记数。&lt;/li&gt;&#xA;&lt;li&gt;通常应该在客户端生命周期中匹配的产生和拆除方法中，各自配对地绑定和取消绑定服务。例如，如果只需要在Activity显示时与Service交互，就应该在onStart()方法中绑定，并在onStop()方法中取消绑定。&#xA;##Bound Service的生命周期&#xA;当所有客户端都取消与Service的绑定后，Android系统就会销毁它（除非它同时也是通过onStartCommand()启动的）。因此，如果是一个纯粹的Bound Service，就不应该管理这个Service的生命周期。&lt;br /&gt;&#xA;如果这个Service既是Bound Service又是Started Service，则这个Service的销毁取决于所有客户端是否都取消绑定，并且是否调用过stopSelf()或由其它组件调用stopService()。&lt;br /&gt;&#xA;另外，如果Service是Started Service并接受绑定，当系统调用onUnbind()方法并返回true时，如果有一个客户端调用了bindService()，那么Service就会在onRebind()中接收调用而不是在onBind()中。onRebind()返回void，但是客户端仍然可以在它的onServiceConnected()中接收IBinder。&lt;br /&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://droider-wordpress.stor.sinaapp.com/service_binding_tree_lifecycle.png&#34; alt=&#34;&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Service</title>
      <link>http://gavin1989.github.io/2013/02/android-service.html</link>
      <pubDate>2013-03-07 01:02:03 +0800</pubDate>
      <description>&lt;p&gt;##Service简介&#xA;Service是一种可以在后台长时间执行操作并且不提供用户界面的应用组件。当Service被其它应用组件启动后，它将一直在后台运行，即使用户切换到了其它应用。另外，组件也可以绑定到一个Service与它交互，甚至执行进程间通信（InterProcess Communication，IPC）。例如，Service可以用于网络通信、播放音乐、执行文件I/O、或者与Content Provider交互，所有的操作都发生在后台。&lt;br /&gt;&#xA;&lt;strong&gt;警告&lt;/strong&gt;：Service是运行在它宿主进程的主线程，它不会创建它自己的线程并且不能在其它进程运行（除非另有指定）。这意味着，如果Service要做任何CPU密集型工作或阻塞操作（比如MP3播放或网络连接）时，必须在Service中创建一个新的线程来做这些工作。这样可以减少应用程序无响应（ANR）错误发生的风险，并且可以使主线程专门处理Activity与用户的交互。&lt;br /&gt;&#xA;Service的两种工作方式：&#xA;##Started Service&#xA;当Service是由其它组件（比如一个Activity）调用startService()启动的时，这个Service就是Started Service。在这种情况下，一旦Service被启动，即使启动它的那个组件已经被销毁，它也会在后台无限期地运行。通常，Started Service执行的是不向调用者返回结果的单独的操作。例如使用网络下载或上传一个文件。当操作结束时，这个Service需要自己调用stopSelf()结束，或由其它组件调用stopService()结束。&lt;br /&gt;&#xA;##Bound Service&#xA;当其它组件调用bindService()绑定到一个Service时，这个Service就是一个“Bound Service”。Bound Service提供一个允许组件与Service交互的C/S接口，使用这个接口可以发送请求、得到返回结果、甚至跨进程通信。当有另外的组件绑定到它时Bound Service才会运行，并且多个组件可以绑定到同一个Service。这种情况下，当所有的组件都取消和它绑定后，这个Bound Service才会被销毁。&lt;br /&gt;&#xA;实际上，Service可以同时有两种工作途径——可以是被启动的（Started，此时会无限期运行），也可以允许绑定。要达成这样的目的只要实现一对回调方法即可:&lt;br /&gt;&#xA;onStartCommand()和onBind()。前者允许组件启动Service，后者允许组件绑定到Service。&#xA;##几个重要的回调方法&#xA;&lt;strong&gt;onStartCommand()&lt;/strong&gt;：当其它组件（比如Activity）调用startService()启动Service时，系统就会调用这个方法。一旦这个方法执行，这个Service就是一个“Started Service”，可以无限期在后台运行。此时要停止它就需要自己调用stopSelf()，或者由其它组件调用stopService()。&lt;br /&gt;&#xA;需要注意的是，onStartCommand()必须返回一个整数，这个整数代表的是Service被系统杀死时的后续行为。这个值必须是下面三个常量中的一个：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;START_NOT_STICKY：如果系统在onStartCommand()返回后杀死了Service，除非还有等待接收的Intent，否则不会重新创建Service。如果应用可以非常简单地重启所有未完成的任务，那么这种方式是最安全的，它可以避免你的Service在不需要时运行。&lt;/li&gt;&#xA;&lt;li&gt;START_STICKY：如果系统在onStartCommand()返回后杀死了Service，会重新创建Service，此时系统不会提供上次的intent，如果没有等待接收的intent，则使用空的intent调用onStartCommand()，否则使用接收到的intent启动Service。这种情况适用于音乐播放器或类似的不需要执行命令，但是要无限期运行以等待工作的服务。&lt;/li&gt;&#xA;&lt;li&gt;START_REDELIVER_INTENT：如果系统在onStartCommand()返回后杀死了Service，会重新创建Service并使用上次提供的intent调用onStartCommand()，其它所有等待接收的intent会依次提供给Service。这种情况适合于像下载文件等需要立即恢复的服务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;onBind()&lt;/strong&gt;：当其它组件调用bindService()与Service绑定（比如执行Remote Procedure Call Protocol，RPC）时，系统就会调用这个方法。无论是否允许绑定，这个方法都必须实现，如不允许绑定，必须返回null；否则这个方法返回一个提供客户端与Service交互接口的IBinder。&lt;br /&gt;&#xA;&lt;strong&gt;onCreate()&lt;/strong&gt;：Service的一次性安装过程，当Service第一次创建时，系统会调用这个方法（在onStartService()或onBind()之前）。如果Service已经是运行状态，则这个方法不会执行。&lt;br /&gt;&#xA;&lt;strong&gt;onDestroy()&lt;/strong&gt;：当Service不再使用，并且即将被销毁时，系统就会调用这个方法。Service使用这个方法来清理所有资源，比如线程、已注册的监听者、接收者等。这是Service能接收到的最后一个调用。&lt;br /&gt;&#xA;###在manifest文件中声明Service&#xA;与其他应用组件一样，必须在应用的manifest文件中声明所有Service：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;manifest &amp;hellip; &amp;gt;&#xA;    &amp;hellip;&#xA;    &amp;lt;application &amp;hellip; &amp;gt;&#xA;        &amp;lt;service android:name=&amp;ldquo;.ExampleService&amp;rdquo; /&amp;gt;&#xA;        &amp;hellip;&#xA;    &amp;lt;/application&amp;gt;&#xA;&amp;lt;/manifest&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;strong&gt;android:name&lt;/strong&gt;是唯一必需的属性，它指定了Service的名字。一旦你的应用发布了的话，就不应该更改这个属性。因为如果这么做的话，可能会影响一些需要使用显式intent引用Service的功能。&lt;br /&gt;&#xA;其次，跟Activity一样，Service也可以定义一个Intent Filter，使其它组件可以使用隐式意图运行这个Service。需要注意的是，如果这里声明的Intent Filter与其它应用通过startService()传递的intent匹配的话，其它应用程序就可能会启动这个Service。因此，如果Service只是用于本地（不允许其它应用使用），就不需要也不应该有任何intent Filter。&lt;br /&gt;&#xA;另外，如果将&lt;strong&gt;android:export&lt;/strong&gt;属性设置为&amp;rdquo;false&amp;rdquo;，Service就会确保为应用私有的。&lt;br /&gt;&#xA;##创建一个Started Service&#xA;一般来说，创建一个Started Service有两种途径：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;继承Service类&lt;/strong&gt;：Service类是所有服务的基类，继承该类时，由于Service默认是运行在应用的主线程的，所以应该创建一个新线程来做Service的工作。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;&lt;strong&gt;继承IntentService类&lt;/strong&gt;：IntentService是Service的一个子类，它使用一个工作线程处理所有的启动请求。如果不需要同时处理多个请求的话，继承IntentService类是最好的选择。此时需要做的只是实现onHandleIntent()方法，这个方法接收每一个启动请求的intent，并且在后台处理请求。&lt;br /&gt;&#xA;###IntentService&#xA;IntentService做的事情：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建一个默认的工作者线程，这个线程处理所有来自于主线程onStartCommand()提供的intent。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;创建一个工作队列，这个工作队列同一时间只会给onHandleIntent()实现传递一个intent，所以不必担心多线程。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;当所有的启动请求都处理完成后停止自己，所以不需要调用stopSelf()。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;提供一个默认的onBind()实现，默认返回null。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;提供一个默认的onStartCommand()实现，它会将启动请求的intent发送给工作队列。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;实际上，继承IntentService时，只需要提供一个onHandleIntent()实现，并且提供一个很小的构造方法（调用super IntentService(String)，这个String就是工作者线程的名字）。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果需要重写其它回调方法，比如onCreate()、onStartCommand()、或者onDestroy()，为了保证IntentService能正确处理自己的生命周期，就要确保这些回调方法都调用了父类的实现。（除了onHandleIntent()，另一个不需要调用父类的是onBind()。）&lt;br /&gt;&#xA;从上面可以看到，使用IntentService实现一个Started Service是非常简单的。但是如果你的Service不想使用工作队列处理启动请求，而是使用多线程时，就要继承Service基类。但是，由于Service默认是运行在应用主线程的，所以应该针对每一个启动请求都创建一条新的线程。&#xA;##启动服务&#xA;可以在Activity或其它组件中调用startService()传递一个指定了要启动的Service的Intent来启动Service，系统会将这个Intent传递给指定的Service的onStartCommand()方法。如果Service之前没有启动，调用onStartCommand()之前会首先调用Service的onCreate()方法。&#xA;&lt;pre&gt;&lt;code&gt;Intent intent = new Intent(this, HelloService.class);&#xA;startService(intent);&lt;/code&gt;&lt;/pre&gt;&#xA;如果Service不允许绑定，且想要给调用者传送结果，可以创建一个PendingIntent，并放入用于启动Service的Intent中。&lt;br /&gt;&#xA;##停止服务&#xA;Started Service必须自己管理生命周期。也就是说，除非当Service的onStartCommand()返回并且继续运行时遇到了系统内存不足，否则系统不会停止或销毁Service。因此，Service必须自己调用stopSelf()或由其它组件通过调用stopService()结束。一旦接收到stopSelf()或stopService()请求，系统会尽快地销毁Service。&lt;br /&gt;&#xA;不过，在Service同时处理多个请求的情况下，就不能在完成一个请求后结束Service，因为这可能会影响到其它请求。为避免这个问题，可以使用stopSelf(int)。参数int是结束请求对应的启动请求的ID，如果ID不匹配则Service不会停止。&lt;br /&gt;&#xA;##创建一个Bound Service&#xA;Bound Service允许应用组件调用bindService()与Service绑定，以便于创建一个两者之间的长链接（此时一般不允许组件调用startService()启动它）。Bound Service只服务于绑定到它的应用组件，所以当没有组件绑定到它时，系统就会销毁它。&lt;br /&gt;&#xA;Bound Service一般用在想要应用中的其它组件与Service交互，或者通过IPC为其它应用程序暴露一些功能的情况下。创建Bound Service时，只需要实现onBind()回调方法并返回一个定义了与Service交互接口的IBinder即可。其它应用组件可以调用bindService()得到这个IBinder并通过它调用Service中的方法。&lt;br /&gt;&#xA;同时可以有多个客户端绑定到Service，当一个客户端完成与Service的交互时，它可以调用unbindService()解除与Service的绑定。&lt;br /&gt;&#xA;##向用户发送通知&#xA;Service在运行过程中可以使用Toast通知或状态栏通知向用户通知事件。Toast通知会在用户的当前屏幕上停留片刻并随后消失；状态栏通知会在用户的状态栏显示一个关于事件信息的图标，用户选择这个图标会触发一个动作（比如启动一个Activity）。&lt;br /&gt;&#xA;通常来说，当后台任务完成后，使用状态栏通知是最好的技术。&lt;br /&gt;&#xA;##运行一个前台服务&#xA;前台服务（Foreground Service）是考虑到了用户的积极行为的一种服务，并因此在内存不足时几乎不可能被杀死。前台服务必须提供一个状态栏通知，这个通知属于持续通知，也就是说，除非服务停止或服务从前台移出，否则这个状态栏通知不能取消显示。&lt;br /&gt;&#xA;要让一个Service成为前台服务，只需要调用startForeground()。这个方法需要两个参数：一个int（要显示的状态栏通知的ID）和一个Notification（要显示的状态栏通知）。例如：&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text), System.currentTimeMillis());&#xA;Intent notificationIntent = new Intent(this, ExampleActivity.class);&#xA;PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);&#xA;notification.setLatestEventInfo(this, getText(R.string.notification_title), getText(R.string.notification_message), pendingIntent);&#xA;startForeground(ONGOING_NOTIFICATION, notification);&lt;/code&gt;&lt;/pre&gt;&#xA;调用stopForeground()将Service从前台移除。这个方法需要一个boolean参数，这个参数指的是在将Service从前台移除时是否同时移除状态栏通知。这个方法并不停止Service。不过，在停止Service时，如果Service仍然在前台运行，那么状态栏通知也会被移除。&lt;br /&gt;&#xA;&lt;strong&gt;注意&lt;/strong&gt;：startForeground()和stopForeground()是Android 2.0（API 5）新加入的，在之前的版本中需要调用setForeground()。&lt;br /&gt;&#xA;##管理Service的生命周期&#xA;由于Service有两种工作方式，所以它的生命周期也有两种路径：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于Started Service：这种Service由其它组件调用startService()创建，随后会无限期运行，必须自己调用stopSelf()或由其它组件通过stopService()结束。当Service停止时，系统就会销毁它。&lt;br /&gt;&lt;/li&gt;&#xA;&lt;li&gt;对于Bound Service：由其它组件（客户端）调用bindService()创建，随后客户端会通过一个IBinder接口与Service交互。客户端使用unbindService()关闭连接。多个客户端绑定到同一个Service时，只有当所有客户端都取消绑定时，系统才会销毁它。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;不过，这两条路径并不是完全独立的。也就是说，你可以绑定到一个已经通过startService()启动的Service。在这种情况下，如果还有绑定到Service的客户端，那么stopSelf()和stopService()就不能真正地停止Service。&lt;br /&gt;&#xA;&lt;strong&gt;注意&lt;/strong&gt;：与Activity不同，Service不要求在回调方法中调用父类的实现（继承IntentService时需要在部分回调方法中调用父类实现，是为了确保IntentService的生命周期可以正确执行）。&lt;br /&gt;&#xA;&lt;img src=&#34;http://droider-wordpress.stor.sinaapp.com/service_lifecycle.png&#34; alt=&#34;Service生命周期&#34; /&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Looper</title>
      <link>http://gavin1989.github.io/2013/02/android-looper.html</link>
      <pubDate>2013-02-28 02:18:11 +0800</pubDate>
      <description>&lt;p&gt;Looper：循环器，是一个用于使线程运行一个消息（Message）循环的类。线程默认没有关联的消息循环，在创建它之前，在将要运行循环的线程中调用prepare方法，然后loop方法会处理消息直到循环结束。&lt;br /&gt;&#xA;绝大多数消息循环是通过Handler类来Looper交互的。&lt;br /&gt;&#xA;下面是实现了Looper的线程的一个典型例子，使用分离的prepare方法和loop方法来创建一个用于跟Looper沟通的初始Handler。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;class LooperThread extends Thread {&#xA;    public Handler mHandler;&#xA;    public void run() {&#xA;        Looper.prepare();&#xA;        mHandler = new Handler() {&#xA;            public void handleMessage(Message msg) {&#xA;                // process incoming messages here&#xA;            }&#xA;        };&#xA;        Looper.loop();&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;先看准备工作的prepare方法：&#xA;&lt;pre&gt;&lt;code&gt;public static final void prepare() {&#xA;    if (sThreadLocal.get() != null) {&#xA;        throw new RuntimeException(&amp;ldquo;Only one Looper may be created per thread&amp;rdquo;);&#xA;    }&#xA;    sThreadLocal.set(new Looper());&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;每条线程只能绑定一个Looper，否则会抛出RuntimeException异常。如果不调用prepare方法，sThreadLocal.get()就会返回null。注意这是个静态方法，在最后一行中绑定了一个做为Looper的线程。怎么绑定的呢，看看Looper的一个私有无参构造方法：&#xA;&lt;pre&gt;&lt;code&gt;private Looper() {&#xA;    mQueue = new MessageQueue();&#xA;    mRun = true;&#xA;    mThread = Thread.currentThread();&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;构造方法里初始化了一个消息队列、一个运行状态的标志以及绑定一个线程（创建者所在的线程）。prepare方法给了一个在真正的循环开始之前，参照Looper创建一个Handler的机会。注意：在run方法中初始化Handler之前，必须调用Looper.prepare()，不然会抛出一个运行时异常，因为Handler需要一个从Looper得到的消息队列（即构造方法里面的mQueue）。调用prepare方法后一定要调用loop方法，并且调用quit方法退出循环。&lt;br /&gt;&#xA;接下来，看看在当前线程里运行一个消息队列的loop方法，用完后一定要调用quit方法结束循环：&#xA;&lt;pre&gt;&lt;code&gt;public static final void loop() {&#xA;    Looper me = myLooper();&#xA;    MessageQueue queue = me.mQueue;&#xA;    while (true) {&#xA;        Message msg = queue.next(); // might block&#xA;        if (msg != null) {&#xA;            if (msg.target == null) {&#xA;                // No target is a magic identifier for the quit message.&#xA;                return;&#xA;            }&#xA;            msg.target.dispatchMessage(msg);&#xA;            msg.recycle();&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;高潮来了，上面说过，Looper的mQueue是Handler使用的消息队列，loop方法启动一个死循环从队列中获取数据，当队列中没有数据时，queue.next()会阻塞。当有数据时，msg.target（即Handler）就会调用dispatchMessage方法，进而调用Handler的handleCallback或者handlerMessage方法。从这些也可以知道，如果Handler是在子线程的run方法中创建（之前必须调用Looper.prepare()）的，那么这个Handler的handleMessage或者handleCallback方法就是运行在子线程的。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>android之intentservice</title>
      <link>http://gavin1989.github.io/2013/02/android-intentservice.html</link>
      <pubDate>2013-02-28 02:10:33 +0800</pubDate>
      <description>&lt;p&gt;IntentService是一种用于处理异步请求（表现为Intent）的服务基类。客户通过调用Context.startService(Intent)发送请求；根据需要启动服务，依次使用工作者线程处理每一个Intent，并且在工作完成后终止自身。&lt;br /&gt;&#xA;这种“工作队列处理器”模式通常被用来从一个应用程序的主线程卸载任务。IntentService类的存在是为了简化这种模式，并且照顾了技术性的部分。要使用它，需要继承IntentService类并且实现onHandleIntent(Intent)方法。IntentService将会接收到这些Intent，运行一条工作者线程，并且在适当的时候停止服务。&lt;br /&gt;&#xA;所有的请求都是在一个单一的工作者线程中处理的，尽管处理过程可能需要很长时间（不会阻塞应用程序的主线程），但是每次只能有一个请求会被处理。&lt;br /&gt;&#xA;首先，看它提供的一个构造方法：&#xA;&lt;pre&gt;public IntentService(String name) {&#xA;    super();&#xA;    mName = name;&#xA;}&lt;/pre&gt;&#xA;参数name被用于命名即将用到的工作者线程，它的重要性仅用于调试。这里需要注意的一点是，Service的实例化是系统来完成的，并且系统是用无参的构造方法来实例化Service的。所以，你的子类必须是无参的，然后在无参构造方法里调用super(&amp;ldquo;name&amp;rdquo;)。&lt;br /&gt;&#xA;再看onCreate方法：&#xA;&lt;pre&gt;@Override&#xA;public void onCreate() {&#xA;    super.onCreate();&#xA;    HandlerThread thread = new HandlerThread(&amp;ldquo;IntentService[&amp;rdquo; + mName + &amp;ldquo;]&amp;rdquo;);&#xA;    thread.start();&#xA;    mServiceLooper = thread.getLooper();&#xA;    mServiceHandler = new ServiceHandler(mServiceLooper);&#xA;}&lt;/pre&gt;&#xA;其中的ServiceHandler是IntentService类的内部类：&#xA;&lt;pre&gt;private final class ServiceHandler extends Handler {&#xA;    public ServiceHandler(Looper looper) {&#xA;        super(looper);&#xA;    }&#xA;    @Override&#xA;    public void handleMessage(Message msg) {&#xA;        onHandleIntent((Intent)msg.obj);&#xA;        stopSelf(msg.arg1);&#xA;    }&#xA;}&lt;/pre&gt;&#xA;在onCreate方法里，创建并启动了一条工作线程。然后使用工作线程的Looper构造了一个Handler，这个Handler将循环处理请求。&lt;br /&gt;&#xA;根据Service的生命周期，我们再看onStartCommand方法：&#xA;&lt;pre&gt;@Override&#xA;public int onStartCommand(Intent intent, int flags, int startId) {&#xA;    onStart(intent, startId);&#xA;    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#xA;}&lt;/pre&gt;&#xA;后面的返回值，可以看看Service类的相关内容。onStartCommand方法调用了onStart方法。再跟到onStart方法：&#xA;&lt;pre&gt;@Override&#xA;public void onStart(Intent intent, int startId) {&#xA;    Message msg = mServiceHandler.obtainMessage();&#xA;    msg.arg1 = startId;&#xA;    msg.obj = intent;&#xA;    mServiceHandler.sendMessage(msg);&#xA;}&lt;/pre&gt;&#xA;每次调用Context.startService(Intent intent)，都会将一个请求（Message，包含一个Intent，并有一个id）添加到消息队列（工作线程的循环队列，相关内容可以看Handler源码）。处理完所有请求后，就会停止服务。&lt;br /&gt;&#xA;对于onHandleIntent(Intent intent)方法，官方注释是这样说的：&lt;br /&gt;&#xA;这个方法运行在工作线程，用于处理一个请求。同一时间只有一个Intent被处理，但是处理过程发生在一个独立于其它应用逻辑的工作线程。因此，如果这个代码块要执行很长时间，它将阻塞其它在同一个IntentService上的请求，除此之外，它不会阻塞其它任何东西。&lt;br /&gt;&#xA;另外，IntentService实现了一个默认的onBind方法，默认返回null。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>阻塞队列</title>
      <link>http://gavin1989.github.io/2013/02/blocking-queue.html</link>
      <pubDate>2013-02-28 01:59:39 +0800</pubDate>
      <description>&lt;p&gt;前面几篇文章看到了形成Java并发程序设计基础的底层构建块。然而，实际编程中，应该尽可能远离底层结构。使用由并发处理的专业人士实现的较高层次的结构要方便的多，而且也安全的多。&lt;br /&gt;&#xA;对于多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。例如，考虑银行转帐程序，转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象。另一个线程从队列中取出指令执行转账。只有该线程可以访问该银行对象的内部，因此不需要同步（锁和条件是线程安全的队列类的实现者需要考虑的）。&lt;br /&gt;&#xA;当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列（blocking queue）导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其它的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行的比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行的快，他将等待第二个队列集赶上来。&lt;br /&gt;&#xA;阻塞队列的方法：&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;&lt;td&gt;正常动作&lt;/td&gt;&lt;td&gt;特殊情况下的动作&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;add&lt;/td&gt;&lt;td&gt;添加一个元素&lt;/td&gt;&lt;td&gt;如果队列满，则抛出IllegalStateException异常&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;返回队列的头元素&lt;/td&gt;&lt;td&gt;如果队列空，抛出NoSuchElementException异常&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;offer&lt;/td&gt;&lt;td&gt;添加一个元素并返回true&lt;/td&gt;&lt;td&gt;如果队列满，返回false&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;peek&lt;/td&gt;&lt;td&gt;返回队列的头元素&lt;/td&gt;&lt;td&gt;如果队列空，则返回null&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;poll&lt;/td&gt;&lt;td&gt;移出并返回队列的头元素&lt;/td&gt;&lt;td&gt;如果队列空，则返回null&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;put&lt;/td&gt;&lt;td&gt;添加一个元素&lt;/td&gt;&lt;td&gt;如果队列满，则阻塞&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;remove&lt;/td&gt;&lt;td&gt;移出并返回头元素&lt;/td&gt;&lt;td&gt;如果队列空，则抛出NoSuchElementException异常&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td&gt;take&lt;/td&gt;&lt;td&gt;移出并返回头元素&lt;/td&gt;&lt;td&gt;如果队列空，则阻塞&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;如上所述，阻塞队列方法分为3类，这取决于当队列满或空时它们的响应方式。如果将队列当作线程管理工具来使用，将要用到put和take方法。当试图向满的队列中添加或从空的队列中移出元素时，add、remove和element操作抛出异常。当然，在一个多线程程序中，队列会在任何时刻满或空，因此，一定要使用offer、poll和peek方法作为替代。这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。需要注意的一点是，poll和peek方法返回null来指示失败，因此，向这些队列中插入null值是非法的。&lt;br /&gt;&#xA;offer和poll方法还有带有超时的方法变体。例如，下面的调用：&#xA;&lt;pre&gt;&lt;code&gt;boolean success = q.offer(x,100,TimeUtil.MILLISECONDS);&lt;/code&gt;&lt;/pre&gt;&#xA;尝试在100毫秒的时间内在队列的尾部插入一个元素。如果成功返回true，否则，达到超时时，返回false。类似地，下面的调用：&#xA;    Object head = q.poll(100,TimeUnit.MILLISECONDS);&#xA;尝试用100毫秒的时间移出队列的头元素，如果成功返回头元素，否则，达到超时时，返回null。&#xA;java.util.concurrent包提供了阻塞队列的几个变种。默认情况下，LinkedBlockingQueue的容量是没有上边界的，但是，也可以选择指定最大容量。LinkedBlockingDeque是一个双端的版本。ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它。&lt;br /&gt;&#xA;PriorityBlockingQueue是一个带优先级的队列，而不是先进先出队列。元素按照它们的优先级顺序被移出。该队列是没有容量上限的，但是，如果队列是空的，取元素的操作会阻塞。&lt;br /&gt;&#xA;最后，DelayQueue包含实现Delayed接口的对象：&#xA;&lt;pre&gt;&lt;code&gt;interface Delayed extends Comparable&lt;Delayed&gt;{&#xA;    long getDelay(TimeUnit unit);&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;getDelay方法返回对象的残留延迟。负值表示延迟已经结束。元素只有在延迟用完的情况下才能从DelayQueue移除。还必须实现compareTo方法，DelayQueue使用该方法对元素进行排序。&lt;br /&gt;&#xA;下面是一个使用阻塞队列来控制线程集的例子，在一个目录及它的所有子目录下搜索所有文件，打印出包含指定关键字的行。&#xA;&lt;pre&gt;&lt;code&gt;public class BlockingQueueTest {&#xA;    /**&#xA;      * @param args&#xA;      */&#xA;    public static void main(String[] args) {&#xA;        // TODO Auto-generated method stub&#xA;        Scanner in = new Scanner(System.in);&#xA;        System.out.print(&amp;ldquo;Enter base directory(e.g. /usr/local/jdk1.6.0/src):&amp;ldquo;);&#xA;        String directory = in.nextLine();&#xA;        System.out.print(&amp;ldquo;Enter keyword (e.g. volatile):&amp;ldquo;);&#xA;        String keyword = in.nextLine();&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    final int FILE_QUEUE_SIZE = 10;&#xA;    final int SEARCH_THREADS = 100;&#xA;    BlockingQueue&amp;lt;File&amp;gt; queue = new ArrayBlockingQueue&amp;lt;File&amp;gt;(FILE_QUEUE_SIZE);&#xA;&#xA;    FileEnumerationTask enumerator = new FileEnumerationTask(queue, new File(directory));&#xA;    new Thread(enumerator).start();&#xA;    for (int i = 1; i &amp;lt;= SEARCH_THREADS; i++) {&#xA;        new Thread(new SearchTask(queue, keyword)).start();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;public class FileEnumerationTask implements Runnable {&#xA;    private BlockingQueue&lt;File&gt; queue;&#xA;    private File startingDirectory;&#xA;    public static File DUMMY = new File(&amp;ldquo;&amp;rdquo;);&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public FileEnumerationTask(BlockingQueue&amp;lt;File&amp;gt; queue, File startingDirectory){&#xA;    this.queue = queue;&#xA;    this.startingDirectory = startingDirectory;&#xA;}&#xA;&#xA;@Override&#xA;public void run() {&#xA;    try {&#xA;        enumerate(startingDirectory);&#xA;        queue.put(DUMMY);&#xA;    } catch (InterruptedException e) {&#xA;        e.printStackTrace();&#xA;    }&#xA;}&#xA;&#xA;public void enumerate(File directory) throws InterruptedException{&#xA;    File[] files = directory.listFiles();&#xA;    for(File file : files){&#xA;        if (file.isDirectory()) {&#xA;            enumerate(file);&#xA;        }else {&#xA;            queue.put(file);&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;public class SearchTask implements Runnable {&#xA;    private BlockingQueue&lt;File&gt; queue;&#xA;    private String keyword;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public SearchTask(BlockingQueue&amp;lt;File&amp;gt; queue,String keyword){&#xA;    this.queue = queue;&#xA;    this.keyword = keyword;&#xA;}&#xA;&#xA;@Override&#xA;public void run() {&#xA;    try {&#xA;        boolean done = false;&#xA;        while (!done) {&#xA;            File file = queue.take();&#xA;            if (file == FileEnumerationTask.DUMMY) {&#xA;                queue.put(file);&#xA;                done = true;&#xA;            }else {&#xA;                search(file);&#xA;            }&#xA;        }&#xA;    } catch (InterruptedException e) {&#xA;        // TODO Auto-generated catch block&#xA;        e.printStackTrace();&#xA;    } catch (FileNotFoundException e) {&#xA;        // TODO Auto-generated catch block&#xA;        e.printStackTrace();&#xA;    }&#xA;}&#xA;&#xA;private void search(File file) throws FileNotFoundException {&#xA;    // TODO Auto-generated method stub&#xA;    Scanner in = new Scanner(new FileInputStream(file));&#xA;    int lineNumber = 0;&#xA;    while (in.hasNextLine()) {&#xA;        lineNumber++;&#xA;        String line = in.nextLine();&#xA;        if(line.contains(keyword))&#xA;            System.out.printf(&amp;quot;%s:%d:%s%n&amp;quot;,file.getPath(),lineNumber,line);&#xA;    }&#xA;    in.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>线程同步</title>
      <link>http://gavin1989.github.io/2013/02/thread-sync.html</link>
      <pubDate>2013-02-28 11:05:44 +0800</pubDate>
      <description>&lt;p&gt;##竞争条件&#xA;在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。当两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法的时候，根据各线程访问数据的次序，可能会产生讹误的对象。这样的情况通常称为“竞争条件”。为了避免多线程引起的对共享数据的讹误，就必须学习如何“同步存取”。&#xA;##锁对象&#xA;从Java SE 5.0开始，有两种机制防止代码块受并发访问的干扰。即Java语言关键字synchronized和Java SE 5.0引入的ReentrantLock类。synchronized关键字自动提供一个锁以及相关的“条件”（Condition），对于大多数需要显式锁的情况，这是很便利的。使用ReentrantLock保护代码块的基本结构如下：&#xA;&lt;pre&gt;&lt;code&gt;myLock.lock();//a ReentrantLock object&#xA;try{&#xA;    critical section&#xA;}finally{&#xA;    myLock.unlock();&#xA;    //make sure the lock is unlocked even if an exception is thrown&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其它任何线程都无法通过lock语句。当其它线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。&lt;br /&gt;&#xA;锁是可重入的（若一个程序或子程序可以“安全的被并行执行”，则称其为“可重入”的），因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（hold count）来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。&lt;br /&gt;&#xA;通常，可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作都完成后，另一个线程才能使用相同对象。&lt;br /&gt;&#xA;要留心临界区中的代码，不要因为异常的抛出而跳出了临界区。如果在临界区代码结束之前抛出了异常，finally子句将释放锁，但会使对象处于一种受损状态。&lt;br /&gt;&#xA;另外，ReentrantLock还提供一个带有公平策略的构造方法——ReentrantLock(boolean fair)。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。不过，遗憾的是，即使使用公平锁，也无法确保线程调度器是公平的。&#xA;##条件对象&#xA;通常，线程进入临界区，却发现在某一条件满足之后它才能执行。这时候，就需要一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程（由于历史原因，条件对象经常被称为条件变量（conditional variable））。&lt;br /&gt;&#xA;一个锁对象可以有一个或多个相关的条件对象，可以使用newCondition方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。&lt;br /&gt;&#xA;等待获得锁的线程和调用await方法的线程存在本质上的不同。一旦一个线程调用await方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll方法时为止。&lt;br /&gt;&#xA;当另一条线程调用signalAll方法时，这一调用重新激活了因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，它们将试图重新进入该对象。一旦锁成为可用的，他们中的某个将从await调用返回，获得该锁并从阻塞的地方继续执行。此时，线程应该再次测试该条件。由于无法确保该条件被满足——signalAll方法仅仅是通知正在等待的线程：此时有可能已经满足条件，值得再次去检测该条件。&lt;br /&gt;&#xA;通常，await的调用应该在如下形式的循环体中：&#xA;&lt;pre&gt;&lt;code&gt;while(!(Ok to proceed))&#xA;    condition.await();&lt;/code&gt;&lt;/pre&gt;&#xA;至关重要的是最终需要某个其它线程调用signalAll方法。当一个线程调用await时，它没有办法重新激活自身。它寄希望于其它线程，而如果没有其它线程来重新激活等待的线程的话，它就永远不在运行了。这将导致令人不快的死锁（deathlock）现象。如果所有其它线程被阻塞，最后一个活动线程在解除其它线程的阻塞状态之前就调用了await方法，那么它也就被阻塞了。没有任何线程可以解除其它线程的阻塞，那么该程序就挂起了。&lt;br /&gt;&#xA;从经验上讲，应该在对象的状态有利于等待线程的方向改变时调用signalAll方法。&lt;br /&gt;&#xA;*注意*：调用signalAll方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法后，通过竞争实现对对象的访问。&lt;br /&gt;&#xA;另一个方法signal，则是随机解除等待集中某个线程的阻塞状态。这比解除所有线程的阻塞更加有效，但也存在危险。如果随机选择的线程发现自己仍然不能运行，那么它再次被阻塞。如果没有其它线程再次调用signal，那么系统就死锁了。&lt;br /&gt;&#xA;##synchronized关键字&#xA;我们先总结一下锁和条件的关键之处：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。&lt;/li&gt;&#xA;&lt;li&gt;锁可以管理试图进入被保护代码段的线程。&lt;/li&gt;&#xA;&lt;li&gt;锁可以拥有一个或多个相关的条件对象。&lt;/li&gt;&#xA;&lt;li&gt;每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;Lock和Condition接口被添加到Java SE 5.0中，这也向程序设计人员提供了高度的封锁机制。然而，大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到Java语言内部的机制。从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。&lt;br /&gt;&#xA;换句话说，&#xA;&lt;pre&gt;&lt;code&gt;public synchronized void method(){&#xA;    method body&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;等价于&#xA;&lt;pre&gt;&lt;code&gt;public void method(){&#xA;    this.intrinsicLock.lock();&#xA;    try{&#xA;        method body&#xA;    }finally{&#xA;        this.intrinsicLock.unlock();&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;内部对象锁只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。换句话说，调用wait或者notifyAll方法等价于：&#xA;&lt;pre&gt;&lt;code&gt;intrinsicCondition.await();&#xA;    intrinsicCondition.signalAll();&lt;/code&gt;&lt;/pre&gt;&#xA;可以看出，使用synchronized关键字来编写代码要简洁的多。当然，要理解这些代码，就必须了解每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。&lt;br /&gt;&#xA;将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的类对象（Class）的内部锁。因此，没有其它线程可以调用同一个类的这个或任何其它的同步静态方法。&lt;br /&gt;&#xA;内部锁和条件存在一些局限，包括：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不能中断一个正在试图获得锁的线程。&lt;/li&gt;&#xA;&lt;li&gt;试图获得锁时不能设置超时。&lt;/li&gt;&#xA;&lt;li&gt;每个锁仅有单一的条件，可能是不够的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在代码中选择使用Lock和Condition对象还是同步方法的一些建议：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;最好既不使用Lock/Condition也不使用synchronized关键字。在许多情况下你可以使用java.util.concurrent包中的一种机制（阻塞队列），它会为你处理所有的加锁。&lt;/li&gt;&#xA;&lt;li&gt;如果synchronized关键字适合你的程序，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;如果特别需要Lock/Condition结构提供的独有特性时，才使用Lock/Condition。&#xA;##同步阻塞&#xA;每个Java对象都有一个锁。线程可以通过调用同步方法获得锁，也可以通过进入一个同步阻塞，获得该对象的锁：&#xA;&lt;pre&gt;&lt;code&gt;synchronized(obj){&#xA;critical section&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;有时程序员使用一个对象的锁来实现额外的原子操作，实际上被称为客户端锁定（client-side locking）。但是客户端锁定是非常脆弱的，通常不推荐使用。因为这种方法完全依赖于这样一个事实，obj对自己的所有可修改方法都使用内部锁。&#xA;##监视器概念&#xA;锁和条件是线程同步的强大工具，但是严格地讲，它们不是面向对象的。多年来，研究人员努力寻找一种方法，可以在不需要程序员考虑如何加锁的情况下，就可以保证多线程的安全性。最成功的解决方案之一是监视器（monitor），这一概念最早是由Per Brinch Hansen和Tony Hoare 在20世纪70年代提出的。用Java的术语讲，监视器具有如下特性：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;监视器是只包含私有域的类。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;每个监视器类的对象有一个相关的锁。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;使用该锁对所有的方法进行加锁。换句话说，如果客户端调用obj.method，那么obj对象的锁是在方法调用开始时自动获得，并且当方法返回时自动释放该锁。因为所有的域是私有的，这样的安排可以确保一个线程在对对象操作上，没有其它线程能访问该域。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;该锁可以有任意多个相关条件。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;监视器的早期版本只有单一的条件，不使用任何显式的条件变量。然而，研究表明盲目地重新测试条件是低效的。显式的条件变量解决了这一问题，每一个条件变量管理一个独立的线程集。&lt;br /&gt;&#xA;Java设计者以不是很精确的方式采用了监视器概念，Java中的每一个对象有一个内部的锁和内部的条件。如果一个方法用synchronized关键字声明，那么，它表现的就像是一个监视器方法。通过调用wait/notifyAll/notify来访问条件变量。&lt;br /&gt;&#xA;然而，在下面三个方面Java对象不同于监视器，从而使得线程的安全性下降：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;域不要求是私有的。&lt;/li&gt;&#xA;&lt;li&gt;方法不要求必须是synchronized。&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;内部锁对客户是可用的。&#xA;##Volatile域&#xA;有时，仅仅为了读写一个或两个实例域就使用同步，显得开销过大了。那么，什么地方能出错呢？遗憾的是，使用现代的处理器与编译器，出错的可能性很大：&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;多处理器的计算机能够暂时在寄存器或本地内存缓冲区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变！&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如果你使用锁来保护可以被多个线程访问的代码，那么可以不考虑这种问题。编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令。详细解释参见JSR 133的Java内存模型和线程规范（&lt;a href=&#34;http://www.jcp.org/en/jsr/detail?id=133&#34;&gt;http://www.jcp.org/en/jsr/detail?id=133&lt;/a&gt;）。&lt;br /&gt;&#xA;Brian Goetz给出了下述“同步格言”：如果向一个变量写入值，而这个变量接下来可能会被另一个线程读取，或者，从一个变量读值，而这个变量可能是之前被另一个线程写入的，此时必须使用同步。&lt;br /&gt;&#xA;volatile关键字为实例域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。&lt;br /&gt;&#xA;例如，假定一个对象有一个布尔标记done，它的值被一个线程设置却被另一个线程查询，如之前所述，你可以使用锁：&#xA;&lt;pre&gt;&lt;code&gt;public synchronized boolean isDone(){ return done; }&#xA;public synchronized void setDone(){ done = true; }&#xA;private boolean done;&lt;/code&gt;&lt;/pre&gt;&#xA;或许使用内部锁不是个好主意。如果另一个线程已经对该对象加锁，isDone和setDone方法可能阻塞。如果注意到这个方面，一个线程可以为这一变量使用独立的Lock。但是，这也会带来许多麻烦。&lt;br /&gt;&#xA;在这种情况下，就可以将域声明为volatile：&#xA;&lt;pre&gt;&lt;code&gt;public boolean getDone(){ return done; }&#xA;public void setDone(){ done = true; };&#xA;private volatile boolean done;&lt;/code&gt;&lt;/pre&gt;&#xA;这地方需要注意的一点是，Volatile不能提供原子性。例如，方法&#xA;&lt;pre&gt;&lt;code&gt;public void flipDone(){ done = !done; }//not atomic&lt;/code&gt;&lt;/pre&gt;&#xA;不能确保改变域中的值。&lt;br /&gt;&#xA;在这样一种非常简单的情况下，存在第三种可能性，使用AtomicBoolean。这个类有方法get和set，且确保是原子的（就像它们是同步的一样）。该实现使用有效的机器指令，在不使用锁的情况下确保原子性。在java.util.concurrent.atomic中有许多包装器类用于原子的整数、浮点数、数组等。这些类是为编写并发实用程序的系统程序员提供使用的，而不是应用程序员。&lt;br /&gt;&#xA;总之，在以下三个条件下，域的并发访问是安全的：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;域是final的，并且在构造器调用完成之后被访问。&lt;/li&gt;&#xA;&lt;li&gt;对域的访问由公有的锁进行保护。&lt;/li&gt;&#xA;&lt;li&gt;域是volatile的。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;语言的设计者试图在优化使用volatile域的代码的性能方面给实现人员留有余地。但是，旧规范太复杂，实现人员难以理解，这带来了混乱和非预期的行为。例如，不可变对象不是真的不可变。&#xA;##死锁&#xA;锁和条件不能解决多线程中的所有问题，比如死锁。在一个程序中，所有线程都被阻塞，这样的状态被称为死锁。遗憾的是，Java编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序，以确保不会出现死锁。&#xA;##锁测试与超时&#xA;线程在调用lock方法来获得另一个线程锁持有的锁的时候，很可能发生阻塞。应该更加谨慎地申请锁。tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其它事情。&#xA;&lt;pre&gt;&lt;code&gt;if(myLock.tryLock()){&#xA;    // now the thread owns the lock&#xA;    try {&#xA;        &amp;hellip;&#xA;    }finally{&#xA;        myLock.unlock();&#xA;    }&#xA;}else{&#xA;    do something else&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;可以调用tryLock时，使用超时参数，例如：&#xA;&lt;pre&gt;&lt;code&gt;if(myLock.tryLock(100,TimeUnit.MILLISECONDS))&amp;hellip;&amp;hellip;&lt;/code&gt;&lt;/pre&gt;&#xA;TimeUnit是一个枚举类型，可以取的值包括SECONDS、MILLISECONDS、MICROSECONDS和NANOSECONDS。&lt;br /&gt;&#xA;lock方法不能被中断。如果一个线程在等待获得一个锁时被中断，中断线程在获得锁之前一直处于阻塞状态。如果出现死锁，lock方法就无法终止。&lt;br /&gt;&#xA;然而，如果调用带有超时参数的tryLock，那么如果线程在等待期间被中断，将抛出InterruptedException异常。这是一个非常有用的特性，因为允许程序打破死锁。&lt;br /&gt;&#xA;也可以调用lockInterruptibly方法。它就相当于一个超时设为无限的tryLock方法。&lt;br /&gt;&#xA;在等待一个条件时，也可以提供一个超时：&#xA;&lt;pre&gt;&lt;code&gt;myCondition.await(100,TimeUnit.MILLISECONDS);&lt;/code&gt;&lt;/pre&gt;&#xA;如果一个线程被另一个线程通过调用signalAll或signal激活，或者超时时限已达到，或者线程被中断，那么await方法将返回。&lt;br /&gt;&#xA;如果等待的线程被中断，await方法将抛出一个InterruptedException异常。在你希望出现这种情况时线程继续等待，可以使用awaitUninterruptibly方法代替await。&#xA;##读/写锁&#xA;java.util.concurrent.locks包定义了两个锁类，除了前面的ReentrantLock类，还有ReentrantReadWriteLock类。如果很多线程从一个数据结构读取数据而很少线程修改其中数据的话，后者是十分有用的。在这种情况下，允许对读者线程共享访问是合适的。当然，写者线程依然必须是互斥访问的。&lt;br /&gt;&#xA;下面是使用读/写锁的必要步骤：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;构造一个ReentrantReadWriteLock对象：&#xA;&lt;pre&gt;&lt;code&gt;private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;抽取读锁和写锁：&#xA;&lt;pre&gt;&lt;code&gt;private Lock readLock = rwl.readLock();&#xA;private Lock writeLock = rwl.writeLock();&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;对所有的访问者加读锁。&lt;/li&gt;&#xA;&lt;li&gt;对所有的修改者加写锁。&#xA;##为什么弃用stop和suspend方法？&#xA;初始的Java版本定义了一个stop方法用来终止一个线程，以及一个suspend方法用来阻塞一个线程直至另一个线程调用resume。stop和suspend方法有一个共同点：都试图控制一个给定线程的行为。&lt;br /&gt;&#xA;从Java1.2开始就弃用了这两个方法。stop方法天生就不安全，而经验证明suspend方法会经常导致死锁。&lt;br /&gt;&#xA;首先来看stop方法，该方法终止所有未结束的方法，包括run方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。例如，假定一个银行转账的线程TransferThread，在从一个账户向另一个账户转账的过程中被终止，钱款已经转出，却没有转入目标账户，现在银行对象就被破坏了，这种破坏会被其他尚未停止的线程观察到。&lt;br /&gt;&#xA;当线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候会导致对象被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。&lt;br /&gt;&#xA;接下来，看看suspend方法有什么问题。与stop方法不同，suspend不会破坏对象。但是如果用suspend挂起一个持有一个锁的线程，那么，该锁在恢复之前是不可用的。如果调用suspend方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等待恢复，而将其挂起的线程等待获得锁。&lt;br /&gt;&#xA;如果想安全地挂起线程，引入一个变量suspendRequested并在run方法的某个安全的地方测试它，安全的地方是指该线程没有封锁其它线程需要的对象的地方。当该线程发现suspendRequested变量已经设置，将会保持等待状态直到它再次获得为止。下面的代码框架实现这一设计：&#xA;&lt;pre&gt;&lt;code&gt;public void run(){&#xA;while(&amp;hellip;){&#xA;    &amp;hellip;&#xA;    if(suspendRequested){&#xA;        suspendLock.lock();&#xA;        try{&#xA;            while(suspendRequested)&#xA;                suspendCondition.await();&#xA;        }finally{&#xA;            suspendLock.unlock();&#xA;        }&#xA;    }&#xA;}&#xA;}&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;public void requestSuspend(){&#xA;    suspendRequested = true;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;public void requestResume(){&#xA;    suspendRequested = false;&#xA;    suspendLock.lock();&#xA;    try{&#xA;        suspendCondition.signalAll();&#xA;    }finally{&#xA;        suspendLock.unlock();&#xA;    }&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;private volatile boolean suspendRequested = false;&#xA;private Lock suspendLock = new ReentrantLock();&#xA;private Condition suspendCondition = suspendLock.newCondition();&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>线程的属性（优先级、守护线程、未捕获异常处理器）</title>
      <link>http://gavin1989.github.io/property-of-thread.html</link>
      <pubDate>2013-02-28 10:45:48 +0800</pubDate>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;线程优先级：每条线程都有一个优先级，默认情况下，主线程的优先级是5（NOR_PRIORITY），子线程继承它父线程的优先级。可以用setPriority方法给一条线程设置优先级（MIN_PRIORITY=1,MAX_PRIORITY=10）。&lt;br /&gt;&#xA;每当线程调度器有机会选择新线程时，它首先会选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，Java线程的优先级被映射到宿主机平台的优先级上，这种映射在常见的操作系统上都不能很好地实现。比如Windows有7个优先级，有几个Java优先级将映射到相同的操作系统优先级。又比如在Sun公司为Linux提供的Java虚拟机里，所有的线程都有相同的优先级（优先级被忽略）。还有，Android中线程优先级是从-20到19.&lt;br /&gt;&#xA;构建程序时，不要将功能的正确性依赖于优先级。如果确实要使用优先级，应该避免初学者常犯的一个错误：如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;守护线程：可以调用t.setDaemon(true)将线程转换为守护线程。守护线程的唯一作用是为其它线程提供服务。比如计时线程。当只剩下守护线程时，虚拟机就退出了。&lt;br /&gt;&#xA;使用守护线程是应该考虑的一个问题：守护线程应该永远不去访问固有资源，比如文件、数据库等，因为它会在任何时候甚至在一个操作的中间发生中断。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;未捕获异常处理器：线程的run方法不能抛出任何被检测的（checked）异常，但是，不被检测的（unchecked）异常会导致线程终止。在这种情况下，线程就会死亡。&lt;br /&gt;&#xA;但是，不需要任何catch子句来处理可以被传播的异常。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。&lt;br /&gt;&#xA;该处理器必须属于一个实现了Thread.UncaughtExceptionHandler接口的类。可以用setUncaughtExceptionHandler方法为任何线程安装一个处理器。也可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。替换处理器的好处就是可以使用日志API发送未捕获的异常的报告到文件。&lt;br /&gt;&#xA;如果不安装默认的处理器，默认的处理器就为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup（它实现了UncaughtExceptionHandler接口）。&lt;br /&gt;&#xA;ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，它的uncaughtException方法做如下操作：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果该线程组有父线程组，那么父线程组的uncaughtException方法被调用。&lt;/li&gt;&#xA;&lt;li&gt;否则，如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用该处理器。&lt;/li&gt;&#xA;&lt;li&gt;否则，如果Throwable是ThreadDeath的一个实例（ThreadDeath对象由stop方法产生，而该方法已过时），什么都不做。&lt;/li&gt;&#xA;&lt;li&gt;否则，线程的名字以及Throwable的栈踪迹被输出到System.err上。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>线程的状态</title>
      <link>http://gavin1989.github.io/2013/02/state-of-thread.html</link>
      <pubDate>2013-02-28 10:29:17 +0800</pubDate>
      <description>&lt;p&gt;线程共有六种状态：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;NEW（新生）：当用new操作符创建一个新线程时，该线程还没有开始运行，此时它的状态是NEW。&lt;/li&gt;&#xA;&lt;li&gt;RUNNABLE（可运行的）：当线程调用start方法后，该线程即处于RUNNABLE状态。之所以是RUNNABLE，是因为此时线程可能在运行，也可能没有运行，这取决于操作系统给线程提供的时间。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另外的线程运行机会。当选择下一个线程时，操作系统会考虑程序的优先级（协调式调度系统中，优先级没用）。&lt;/li&gt;&#xA;&lt;li&gt;BLOCKED（被阻塞的）。&lt;/li&gt;&#xA;&lt;li&gt;WATING（等待）。&lt;/li&gt;&#xA;&lt;li&gt;TIMED WATING（计时等待）：当线程处于被阻塞或者等待状态时，它暂时不活动，不运行任何代码并且消耗最少的资源。直到线程调度器重新激活它：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;当一个线程试图获取一个内部的对象锁（不是java.util.concurrent库中的锁），而该锁被其它线程持有，则该线程进入阻塞状态（BLOCKED）。当其它线程释放该锁，并且线程调度器允许它持有该锁时，该线程将变成非阻塞状态（RUNNABLE）。&lt;/li&gt;&#xA;&lt;li&gt;当线程等待另一个线程通知调度器一个条件时，它进入等待状态（WATING）。在调用Object.wait方法、Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。&lt;/li&gt;&#xA;&lt;li&gt;有几种方法有一个超时参数，调用它们导致线程进入计时等待状态（TIMED WATING）。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Tread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.await的计时板。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;li&gt;TERMINATED（已终止）：线程在下列两种情况下将被终止：&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;因为run方法正常退出而自然死亡。&lt;/li&gt;&#xA;&lt;li&gt;因为一个没有捕获的异常终止了run方法而意外死亡。&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>中断线程</title>
      <link>http://gavin1989.github.io/2013/02/interrupt-thread.html</link>
      <pubDate>2013-02-28 10:26:32 +0800</pubDate>
      <description>&lt;p&gt;&lt;em&gt;本文的内容全部来自Core Java&lt;/em&gt;&lt;br /&gt;&#xA;当线程的run方法执行完最后一条语句并return，或者出现了在方法中未捕获的异常时，线程将终止。&lt;br /&gt;&#xA;interrupt()方法只是请求终止线程，当调用此方法时，线程的中断状态将被置位。每个线程都应该不时地检查这个标志，以判断线程是否被中断。&lt;br /&gt;&#xA;当在一个被阻塞的线程（调用sleep或者wait）上调用interrupted方法时，阻塞调用将会被InterruptedException中断。&lt;br /&gt;&#xA;没有任何一个语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是为了引起它的注意，被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后继续运行，而不是中断。更是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种情况下线程的run方法具有如下形式：&#xA;&lt;pre&gt;&lt;code&gt;public void run(){&#xA;    try{&#xA;        while(!Thread.currentThread().isInterrupted()&#xA;                &amp;amp;&amp;amp; more work to do){&#xA;            do more work&#xA;        }&#xA;    }catch(InterruptedException e){&#xA;        // thread was interrupted during sleep or wait&#xA;    }finally{&#xA;        cleanup,if required&#xA;    }&#xA;    //exiting the run method terminates the thread&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;如果在每次迭代之后都调用sleep方法（或者其它的可中断方法），isInterrupted检测就没有用处也没有必要。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，它将清除这一状态并抛出InterruptedException。因此，如果你的循环调用sleep，不要检测中断状态，而是如下所示捕获&#xA;InterruptedException：&#xA;&lt;pre&gt;&lt;code&gt;public void run(){&#xA;    try{&#xA;        while(more work to do){&#xA;            do more work&#xA;            Thread.sleep(delay);&#xA;        }&#xA;    }catch (InterruptedException e){&#xA;        //thread was interrupted during sleep or wait&#xA;    }finally{&#xA;        cleanup,if required&#xA;    }&#xA;    //exiting the run method terminates the thread&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;有时候InterruptedException被抑制在很低的层次上，比如：&#xA;&lt;pre&gt;&lt;code&gt;void mySubTask(){&#xA;    &amp;hellip;&#xA;    try{&#xA;        sleep(dalay);&#xA;    }catch(InterruptedException e){&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;}&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;}&lt;/code&gt;&lt;/pre&gt;&#xA;这时候有一种更好的解决办法：&#xA;&lt;pre&gt;&lt;code&gt;void mySubTask(){&#xA;    &amp;hellip;&#xA;    try{&#xA;        sleep(dalay);&#xA;    }catch(InterruptedException e){&#xA;        Thread.currentThread().interrupt();&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;当然，最好的解决办法是：&#xA;&lt;pre&gt;&lt;code&gt;void mySubTask() throws InterruptedException{&#xA;    &amp;hellip;&#xA;    sleep(dalay);&#xA;    &amp;hellip;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>java.lang.Thread</title>
      <link>http://gavin1989.github.io/2013/02/java-lang-thread.html</link>
      <pubDate>2013-02-28 10:14:07 +0800</pubDate>
      <description>&lt;p&gt;线程是执行并发任务的最小单元。它有单独的用于方法调用、参数和本地变量的堆栈。每一个已启动的虚拟机实例至少有一条主线程在运行；通常情况下，会有另外几条线程去进行一些事务操作。有时候为了特殊的目的，应用程序也会添加一条子线程。&lt;br /&gt;&#xA;同一个VM中的线程通过使用共享对象和监控跟它们相关的一些对象来相互影响和同步。子线程之间的同步也可以使用同步方法和Object类中的一些API（notify()、notifyAll()、wait()&amp;hellip;）。&lt;br /&gt;&#xA;程序代码中，执行线程的最基本方法有两种。一是提供一个新的继承自Thread的类，并且重写它的run()方法。另一种方法是，在创建线程的时候提供一个Runnable接口的实现。&lt;br /&gt;&#xA;在上述两种情况下，实际执行Thread的方法必须是start()方法。&lt;br /&gt;&#xA;每条线程都有一个数字表示的优先级（最小为1，最大为10，主线程默认是5，子线程默认继承父线程的优先级），优先级基本上决定了此线程能分配到的CPU处理时间的总额。优先级可以使用setPriortity()方法来设置（最大不超过所属ThreadGroup的优先级）。一条线程也可以是Daemon Thread，这使得它可以在后台运行。后者还会影响VM的终止行为：只要有非Daemon Thread运行，虚拟机就不会停止。&lt;br /&gt;&#xA;线程的状态（同时只能有下列枚举中的一种状态）：&#xA;&lt;pre&gt;&lt;code&gt;public enum State{&#xA;    NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;线程的id = ++Thread.count，所以它是独一无二的。&lt;br /&gt;&#xA;线程的name，如果未指定，是&amp;rdquo;Thread-&amp;ldquo;+id。&lt;br /&gt;&#xA;UncaughtExceptionHandler类可以捕获当前线程抛出的未经捕获的异常。&lt;br /&gt;&#xA;在创建线程时，如果不指定ThreadGroup，则新线程归属于创建者线程所在的ThreadGroup。&lt;br /&gt;&#xA;主要方法：&lt;br /&gt;&#xA;public void interrupt()：给这条线程发送一个中断请求。如果调用者是currentThread()，方法checkAccess()就会被调用（如果有SecurityManager的话）。这可能会导致一个SecurityException被抛出，更进一步的行为取决于线程当前的状态：&lt;br /&gt;&#xA;如果线程阻塞于下面情况：1）Object的某个wait()方法；2）线程的join()方法；3）线程的sleep()方法。线程将会被唤醒，它们的中断状态将会被清除，并且它们会接收到一个InterruptedException。&lt;br /&gt;&#xA;如果线程阻塞于java.nio.channels.InterruptiableChannel的I/O操作，将会设置它们的中断状态为true，并且接收到一个java.nio.channels.ClosedByInterruptException。同时，这个通道将被关闭。&lt;br /&gt;&#xA;如果线程阻塞于java.nio.channels.Selector，将会设置它们的中断状态为true并且立即返回。在这种情况下不会抛出任何异常。&lt;br /&gt;&#xA;public static boolean interrupted()：返回一个表示currentThread()是否有一个中断请求的布尔值。它会清除这条线程的中断标记，这时候它会有一个副作用（也就是，如果连续调用两次此方法，如果第一次返回true，则第二次会返回false）。&lt;br /&gt;&#xA;public final boolean isAlive()：返回一个表示线程生命状态的布尔值。如果接收者已经开始(started)并且仍然在运行(还没有死亡)，则返回true。当接收者还没有开始，或者它已经开始，而且已经执行结束并且死亡，则返回false。&lt;br /&gt;&#xA;public final boolean isDaemon()：返回一个表示线程是否Daemon Thread的布尔值。Daemon Thread的运行取决于非Daemon Thread（即User Thread）的运行状态。当最后一条User Thread结束的时候，无论是否有Daemon Thread在运行，整个程序都会结束。&lt;br /&gt;&#xA;public boolean isInterrupted()：返回一个表示接收者是否有一个中断请求的布尔值。&lt;br /&gt;&#xA;public final void join()：阻塞current Thread直到接收者执行完毕并且死亡。&lt;br /&gt;&#xA;&lt;pre&gt;&lt;code&gt;public final void join() throws InterruptedException {&#xA;    VMThread t = vmThread;&#xA;    if (t == null) {&#xA;        return;&#xA;    }&#xA;    synchronized (t) {&#xA;        while (isAlive()) {&#xA;            t.wait();&#xA;        }&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&#xA;public final void join(long millis)：阻塞current Thread直到下列两种情况满足至少一种：1）接收者执行完毕并且死亡；2）指定的时间终止。&lt;br /&gt;&#xA;public final void join(long millis, int nanos)：阻塞current Thread直到下列两种情况满足至少一种：1）接收者执行完毕并且死亡；2）指定的时间终止。参数nanos：纳秒级别的精确度。&lt;br /&gt;&#xA;public void run()：调用接收者的Runnable对象的run()方法，如果没有设置Runnable对象，则不做任何事。不要直接调用Thread或者Runnable的run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。&lt;br /&gt;&#xA;public void setContextClassLoader(ClassLoader cl)：设置接收者的context ClassLoader。&lt;br /&gt;&#xA;public final void setDaemon(boolean isDaemon)：设置接收者是否为Daemon Thread，这个方法必须在start()方法之前调用。&lt;br /&gt;&#xA;public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler handler)：设置默认的未捕获异常处理器，这个处理器将会在有未处理的异常导致线程死亡时调用。&lt;br /&gt;&#xA;public final void setName(String threadName)：设置线程的名字。&lt;br /&gt;&#xA;public final void setPriority(int priority)：设置线程的优先级。注意：最终的优先级也许不是我们传入的值，因为它是依赖于接收者所在的ThreadGroup的。线程的优先级不能设置的比它所在的ThreadGroup的maxPriority()还高。&lt;br /&gt;&#xA;public void setUncaughtExceptionHandler(UncaughtExceptionHandler handler)：设置未捕获异常处理器，这个处理器将会在有未处理的异常导致线程死亡时调用。&lt;br /&gt;&#xA;public static void sleep(long time)：使发送这条消息的线程睡眠指定的时间间隔（给定的毫秒）。这个方法的精确度无法保证，线程的实际睡眠时间可能多于或少于指定的时间。&lt;br /&gt;&#xA;public static void sleep(long millis, int nanos)：使发送这条消息的线程睡眠指定的时间间隔（给定的毫秒和纳秒）。这个方法的精确度无法保证，线程的实际睡眠时间可能多于或少于指定的时间。&lt;br /&gt;&#xA;public synchronized void start()：启动一条新线程，接收者线程将会调用它自己的run()方法。&lt;br /&gt;&#xA;public String toString()：返回一个关于线程的简洁的、人容易理解的描述。包括这个线程的名字、优先级和ThreadGroup的名字。&lt;br /&gt;&#xA;public static void yield()：使用此方法将调用线程的执行时间给予另外一条准备运行的线程。实际情况依赖于实现（如果有其它的可运行（RUNNABLE）线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度）。注意，这是一个静态方法。&lt;br /&gt;&#xA;public static boolean holdsLock(Object object)：表示current Thread是否有一个在指定对象上的监控锁。&lt;br /&gt;&#xA;public static int activeCount()：返回正在运行的线程所在的ThreadGroup以及它的子Group中处于活动状态的线程数量。&lt;br /&gt;&#xA;public final void checkAccess():用于检查SecurityManager是否允许操作。如果没有安装SecurityManager，则不进行任何操作。如果安装了SecurityManager的话，会调用此SecurityManager的checkAccess()方法。当SecurityManager已安装，并且不允许访问此线程时，抛出SecurityException。&lt;br /&gt;&#xA;public static Thread currentThread()：返回调用者的线程，即当前线程。&lt;br /&gt;&#xA;public static void dumpStack()：将此线程当前堆栈的标准错误流打印到一个文本。&lt;br /&gt;&#xA;public static int enumerate(Thread[] threads)：将当前线程所在的ThreadGroup以及它的子ThreadGroup中的所有线程复制到传入的线程数组中。如果传入的这个线程数组太小，额外的线程将不会被复制进去。返回值是拷贝的线程数目。&lt;br /&gt;&#xA;public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces()：返回所有当前存活的线程的堆栈轨迹。&lt;br /&gt;&#xA;public ClassLoader getContextClassLoader()：返回此线程的上下文类加载器。如果满足以下条件，一个RuntimePermission(&amp;ldquo;getClassLoader&amp;rdquo;)的安全检查将在第一时间被执行：1）当前有一个SecurityManager；2）调用者的类加载器不为空；3）调用者的类加载器与被请求的上下文类加载器不一样，并且两者不是一个原型。&lt;br /&gt;&#xA;public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()：返回默认的未捕获异常处理器。&lt;br /&gt;&#xA;public long getId()：返回当前线程的ID，这个ID是在线程创建的时候指定的lang型数值，这个值是独一无二的，并且在线程的生命周期中不能更改。如果线程终止，这个值可能被重用。&lt;br /&gt;&#xA;public final String getName()：返回线程的名字。&lt;br /&gt;&#xA;public final int getPriority()：返回线程的优先级。&lt;br /&gt;&#xA;public StackTraceElement[] getStackTrace()：返回描述此线程当前执行状态的堆栈轨迹。返回结果之前会先检查RuntimePermission(&amp;ldquo;getStackTrace&amp;rdquo;)。&lt;br /&gt;&#xA;public State getState()：返回线程当前的状态，这个方法经常被用于监控的目的。&lt;br /&gt;&#xA;public final ThreadGroup getThreadGroup()：返回此线程归属的ThreadGroup。&lt;br /&gt;&#xA;public UncaughtExceptionHandler getUncaughtExceptionHandler()：返回此线程的未捕获异常处理器。如果没有明确指定，则返回ThreadGroup的处理器（其实是ThreadGroup，因为ThreadGroup实现了UncaughtExceptionHandler接口）。如果此线程已经终止，则返回null。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>java.lang.Void类</title>
      <link>http://gavin1989.github.io/2013/02/java-lang-void.html</link>
      <pubDate>2013-02-28 10:06:39 +0800</pubDate>
      <description>&lt;p&gt;java.lang.Void类是基本类型（primitive type）void的包装类型（wrapped type），final修饰符修饰，不可修改。&lt;br /&gt;&#xA;唯一属性：&#xA;&lt;pre&gt;&lt;code&gt;public static final Class&lt;Void&gt; TYPE = Class.getPrimitiveClass(&amp;ldquo;void&amp;rdquo;); &lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&#xA;在Android中，这个值取的是Thread类run()的返回值类型。&lt;br /&gt;&#xA;无参构造函数私有。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android之Handler</title>
      <link>http://gavin1989.github.io/2013/02/android-handler.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Handler：Handler允许你发送并且处理和线程消息队列相关的消息（Message）和可运行对象。每个Handler实例都有一个单独的相关线程和这个线程的消息队列。当你创建一个新的Handler时候，它将和创建者所在线程以及此线程的消息队列绑定。从这一刻起，它将传递消息和可运行对象到消息队列，并在消息和可运行对象被传出消息队列时执行它们。&lt;br /&gt;&#xA;Handler主要有两种用途：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;把要被执行的消息和可运行对象添加到将要执行的任务清单里。&lt;/li&gt;&#xA;&lt;li&gt;把要在另外一条线程上执行的动作列入自己的队列。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;安排消息到任务清单，可以使用以下几种方法：post，postAtTime(Runnable,long)，postDelayed，sendEmptyMessage，sendMessage，sendMessageAtTime以及sendMessageDelayed方法。post版本的方法允许你安排Runnable对象到任务清单，这些Runnable对象将在消息队列接收到后调用它们。sendMessage版本的方法允许你安排一个Message对象到任务清单，这个Message对象包含一个将被Hanlder的handleMessage方法处理的数据包（需要在你的子类中实现handleMessage方法）。&lt;br /&gt;&#xA;你在posting或者sending时，既可以允许消息循环在准备完成后立即处理任务，也可以在执行任务之前指定一个延迟时间。上述post和send系列的最后两个方法可以设置超时、空转和定时行为。&lt;br /&gt;&#xA;当你的应用程序创建一个进程的时候，这个进程的主线程就专门运行一个负责管理顶级程序对象（activities，broadcast receivers等等）和所有由这些对象创建的窗口的消息循环。你可以创建自己的线程，并且通过一个Handler和应用的主线程沟通。这样做跟之前调用post或者sendMessage一样，只不过是在你的子线程中调用的。给定的Runnable对象或者Message将被添加到Hanlder的消息队列，并且在适当的时候处理它们。&lt;br /&gt;&#xA;Hanlder默认的构造方法，将这个Handler跟当前线程中的队列关联了起来：&#xA;&lt;pre&gt;Handler() {&#xA;    mLooper = Looper.myLooper();&#xA;    if (mLooper == null) {&#xA;        throw newRuntimeException(&amp;ldquo;Can&amp;rsquo;t create handler inside thread that has not called Looper.prepare()&amp;rdquo;);&#xA;    }&#xA;    mQueue = mLooper.mQueue;&#xA;    mCallback = null;&#xA;}&lt;/pre&gt;&#xA;Handler必须要有一个消息队列，不然它没法接受消息。在线程初始化Handler之前，必须调用Looper.prepare()，详细内容请参考&lt;a href=&#34;http://my.oschina.net/u/272863/blog/93721&#34;&gt;《Android之Looper》。 &lt;/a&gt;&lt;br /&gt;&#xA;初始化Handler时，还可以指定Looper和Callback，前者可以使消息循环在Looper相关的线程中运行，后者可以使你避免重写Handler。&lt;br /&gt;&#xA;Handler的obtainMessage系列方法都是从全局的消息池中拿Message，如果池中没有，就new一个返回。&lt;br /&gt;&#xA;post系列方法，都是封装的对应的send系列方法（将Runnable对象（msg.callback）和一个Object对象（即msg.object，如果有的话）通过getPostMessage方法拿到一个Message，然后send）。&lt;br /&gt;&#xA;&lt;pre&gt;private final Message getPostMessage(Runnable r, Object token) {&#xA;    Message m = Message.obtain();&#xA;    m.obj = token;&#xA;    m.callback = r;&#xA;    return m;&#xA;}&lt;/pre&gt;&#xA;send系列方法，包装的都是sendMessageAtTime方法（sendMessageAtFrontOfQueue方法也是它的一个变种）。在sendMessageAtTime方法中，第一个参数是将被传递的Message对象，第二个是传递时的时间（可以猜想delayed系列方法都是当前时间加上延迟时间，事实证明这种猜想是正确的）。&lt;br /&gt;&#xA;&lt;pre&gt;public boolean sendMessageAtTime(Message msg, long uptimeMillis){&#xA;    boolean sent = false;&#xA;    MessageQueue queue = mQueue;&#xA;    if (queue != null) {&#xA;        msg.target = this;&#xA;        sent = queue.enqueueMessage(msg, uptimeMillis);&#xA;    } else {&#xA;        RuntimeException e = new RuntimeException(&#xA;                this + &amp;ldquo; sendMessageAtTime() called with no mQueue&amp;rdquo;);&#xA;        Log.w(&amp;ldquo;Looper&amp;rdquo;, e.getMessage(), e);&#xA;    }&#xA;    return sent;&#xA;}&lt;/pre&gt;&#xA;在这个方法中，将Message排入消息队列（队列中按照uptimeMillis排序，而sendMessageAtFrontOfQueue方法中将它设为0，所以sendMessageAtFrontOfQueue方法传递的Message将在Looper的loop方法循环的下一次循环中立即执行）。enqueueMessage方法的排序部分如下：&#xA;&lt;pre&gt;synchronized (this) {&#xA;    if (mQuiting) {&#xA;        RuntimeException e = new RuntimeException(&#xA;                msg.target + &amp;ldquo; sending message to a Handler on a dead thread&amp;rdquo;);&#xA;        Log.w(&amp;ldquo;MessageQueue&amp;rdquo;, e.getMessage(), e);&#xA;        return false;&#xA;    } else if (msg.target == null) {&#xA;        mQuiting = true;&#xA;    }&#xA;    msg.when = when;&#xA;    //Log.d(&amp;ldquo;MessageQueue&amp;rdquo;, &amp;ldquo;Enqueing: &amp;ldquo; + msg);&#xA;    Message p = mMessages;&#xA;    if (p == null || when == 0 || when &amp;lt; p.when) {&#xA;        msg.next = p;&#xA;        mMessages = msg;&#xA;        this.notify();&#xA;    } else {&#xA;        Message prev = null;&#xA;        while (p != null &amp;amp;&amp;amp; p.when &amp;lt;= when) {&#xA;        prev = p;&#xA;        p = p.next;&#xA;    }&#xA;    msg.next = prev.next;&#xA;    prev.next = msg;&#xA;    this.notify();&#xA;}&lt;/pre&gt;&#xA;将Message排入消息队列后的事情，是由Looper来完成的，详见&lt;a href=&#34;http://my.oschina.net/u/272863/blog/93721&#34;&gt;《Android之Looper》&lt;/a&gt;中的loop方法。在Looper的loop方法中，调用了msg.target（即Handler，见sendMessageAtTime方法）的dispatchMessage方法。&#xA;&lt;pre&gt;public void dispatchMessage(Message msg) {&#xA;    if (msg.callback != null) {&#xA;        handleCallback(msg);&#xA;    } else {&#xA;        if (mCallback != null) {&#xA;            if (mCallback.handleMessage(msg)) {&#xA;                return;&#xA;            }&#xA;        }&#xA;        handleMessage(msg);&#xA;    }&#xA;}&lt;/pre&gt;&#xA;第一个判断，msg.callback即为post系列方法传递到的Runnable对象。&#xA;&lt;pre&gt;private final void handleCallback(Message message) {&#xA;    message.callback.run();&#xA;}&lt;/pre&gt;&#xA;第二个mCallback.handleMessage方法，可以让你避免在自己的Handler子类中重写handleMessage方法。&lt;br /&gt;&#xA;还有remove系列方法，就是根据条件从消息队列中移除相关的Message。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android中view的Touch事件传递顺序</title>
      <link>http://gavin1989.github.io/2013/02/how-are-android-touch-events-delivered.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看一下ViewGroup的dispatchTouchEvent的关键源码：&#xA;&lt;pre&gt;public boolean dispatchTouchEvent(MotionEvent ev) {&#xA;    &amp;hellip;&#xA;    if (action == MotionEvent.ACTION_DOWN) {&#xA;        &amp;hellip;&#xA;        if (disallowIntercept || !onInterceptTouchEvent(ev)) {&#xA;            final View[] children = mChildren;&#xA;            final int count = mChildrenCount;&#xA;            for (int i = count - 1; i &amp;gt;= 0; i&amp;ndash;) {&#xA;                final View child = children[i];&#xA;                if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE&#xA;                        || child.getAnimation() != null) {&#xA;                    &amp;hellip;&#xA;                    if (child.dispatchTouchEvent(ev))  {&#xA;                        // Event handled, we have a target now.&#xA;                        mMotionTarget = child;&#xA;                        return true;&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    &amp;hellip;&#xA;    final View target = mMotionTarget;&#xA;    if (target == null) {&#xA;        &amp;hellip;&#xA;        return super.dispatchTouchEvent(ev);&#xA;    }&#xA;    if (!disallowIntercept &amp;amp;&amp;amp; onInterceptTouchEvent(ev)) {&#xA;        &amp;hellip;&#xA;        if (!target.dispatchTouchEvent(ev)) {&#xA;            // target didn&amp;rsquo;t handle ACTION_CANCEL. not much we can do&#xA;            // but they should have.&#xA;        }&#xA;        // clear the target&#xA;        mMotionTarget = null;&#xA;        // Don&amp;rsquo;t dispatch this event to our own view, because we already&#xA;        // saw it when intercepting; we just want to give the following&#xA;        // event to the normal onTouchEvent().&#xA;        return true;&#xA;    }&#xA;    &amp;hellip;&#xA;    return target.dispatchTouchEvent(ev);&#xA;}&lt;/pre&gt;&#xA;根据以上代码可知，如果onInterceptTouchEvent方法返回true，会直接调用当前ViewGroup的onTouch方法，否则则会依次调用其内包含的子控件的dispatchTouchEvent方法。我写了一个测试用例，ViewGroup的onInterceptTouchEvent方法与所有View的onTouch方法都打了Log：&#xA;&lt;pre&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;utf-8&amp;rdquo;?&amp;gt;&#xA;&amp;lt;org.gavin.test.view.MyScrollView xmlns:android=&amp;ldquo;http://schemas.android.com/apk/res/android&amp;rdquo;&#xA;    android:layout_width=&amp;ldquo;fill_parent&amp;rdquo;&#xA;    android:layout_height=&amp;ldquo;fill_parent&amp;rdquo; &amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;amp;lt;org.gavin.test.view.MyLinearLayout&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;    &amp;amp;lt;org.gavin.test.view.MyImageView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@drawable/ic_launcher&amp;quot;&amp;gt;&#xA;    &amp;amp;lt;/org.gavin.test.view.MyImageView&amp;gt;&#xA;&amp;amp;lt;/org.gavin.test.view.MyLinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;/org.gavin.test.view.MyScrollView&amp;gt;&lt;/pre&gt;&#xA;Log信息：&#xA;&lt;pre&gt;I/MyScrollView(26001)::onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26001): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyImageView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyScrollView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;如果MyLinearLayout的onInterceptTouchEvent方法返回true：&#xA;&lt;pre&gt;11-04 14:05:08.389: I/MyScrollView(26297): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.389: I/MyLinearLayout(26297):onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.397: I/MyLinearLayout(26297): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.397: I/MyScrollView(26297): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;OK，再看这段代码：&#xA;&lt;pre&gt;if (child.dispatchTouchEvent(ev))  {&#xA;    // Event handled, we have a target now.&#xA;    mMotionTarget = child;&#xA;    return true;&#xA;}&lt;/pre&gt;&#xA;从这段代码可以看出，如果某个子控件的dispatchTouchEvent方法返回true，则中断以后的消息传递。并在下一个非ACTION_DOWN事件直接调用此子控件的dispatchTouchEvent方法。一个View的dispatchTouchEvent返回true，主要可能是onTouch方法返回true。如果我们把MyImageView的onTouchEvent返回值改为true：&#xA;&lt;pre&gt;I/MyScrollView(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyImageView(26393): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>