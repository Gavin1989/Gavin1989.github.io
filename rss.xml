<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Gavin Droider</title>
    <link>http://gavin1989.github.io</link>
    <pubDate>2013-05-11 12:25:02 +0800</pubDate>
    <item>
      <title>Android之Handler</title>
      <link>http://gavin1989.github.io/2013/02/android-handler.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Handler：Handler允许你发送并且处理和线程消息队列相关的消息（Message）和可运行对象。每个Handler实例都有一个单独的相关线程和这个线程的消息队列。当你创建一个新的Handler时候，它将和创建者所在线程以及此线程的消息队列绑定。从这一刻起，它将传递消息和可运行对象到消息队列，并在消息和可运行对象被传出消息队列时执行它们。&lt;br /&gt;&#xA;Handler主要有两种用途：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;把要被执行的消息和可运行对象添加到将要执行的任务清单里。&lt;/li&gt;&#xA;&lt;li&gt;把要在另外一条线程上执行的动作列入自己的队列。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;安排消息到任务清单，可以使用以下几种方法：post，postAtTime(Runnable,long)，postDelayed，sendEmptyMessage，sendMessage，sendMessageAtTime以及sendMessageDelayed方法。post版本的方法允许你安排Runnable对象到任务清单，这些Runnable对象将在消息队列接收到后调用它们。sendMessage版本的方法允许你安排一个Message对象到任务清单，这个Message对象包含一个将被Hanlder的handleMessage方法处理的数据包（需要在你的子类中实现handleMessage方法）。&lt;br /&gt;&#xA;你在posting或者sending时，既可以允许消息循环在准备完成后立即处理任务，也可以在执行任务之前指定一个延迟时间。上述post和send系列的最后两个方法可以设置超时、空转和定时行为。&lt;br /&gt;&#xA;当你的应用程序创建一个进程的时候，这个进程的主线程就专门运行一个负责管理顶级程序对象（activities，broadcast receivers等等）和所有由这些对象创建的窗口的消息循环。你可以创建自己的线程，并且通过一个Handler和应用的主线程沟通。这样做跟之前调用post或者sendMessage一样，只不过是在你的子线程中调用的。给定的Runnable对象或者Message将被添加到Hanlder的消息队列，并且在适当的时候处理它们。&lt;br /&gt;&#xA;Hanlder默认的构造方法，将这个Handler跟当前线程中的队列关联了起来：&#xA;&lt;pre&gt;Handler() {&#xA;    mLooper = Looper.myLooper();&#xA;    if (mLooper == null) {&#xA;        throw newRuntimeException(&amp;ldquo;Can&amp;rsquo;t create handler inside thread that has not called Looper.prepare()&amp;rdquo;);&#xA;    }&#xA;    mQueue = mLooper.mQueue;&#xA;    mCallback = null;&#xA;}&lt;/pre&gt;&#xA;Handler必须要有一个消息队列，不然它没法接受消息。在线程初始化Handler之前，必须调用Looper.prepare()，详细内容请参考&lt;a href=&#34;http://my.oschina.net/u/272863/blog/93721&#34;&gt;《Android之Looper》。 &lt;/a&gt;&lt;br /&gt;&#xA;初始化Handler时，还可以指定Looper和Callback，前者可以使消息循环在Looper相关的线程中运行，后者可以使你避免重写Handler。&lt;br /&gt;&#xA;Handler的obtainMessage系列方法都是从全局的消息池中拿Message，如果池中没有，就new一个返回。&lt;br /&gt;&#xA;post系列方法，都是封装的对应的send系列方法（将Runnable对象（msg.callback）和一个Object对象（即msg.object，如果有的话）通过getPostMessage方法拿到一个Message，然后send）。&lt;br /&gt;&#xA;&lt;pre&gt;private final Message getPostMessage(Runnable r, Object token) {&#xA;    Message m = Message.obtain();&#xA;    m.obj = token;&#xA;    m.callback = r;&#xA;    return m;&#xA;}&lt;/pre&gt;&#xA;send系列方法，包装的都是sendMessageAtTime方法（sendMessageAtFrontOfQueue方法也是它的一个变种）。在sendMessageAtTime方法中，第一个参数是将被传递的Message对象，第二个是传递时的时间（可以猜想delayed系列方法都是当前时间加上延迟时间，事实证明这种猜想是正确的）。&lt;br /&gt;&#xA;&lt;pre&gt;public boolean sendMessageAtTime(Message msg, long uptimeMillis){&#xA;    boolean sent = false;&#xA;    MessageQueue queue = mQueue;&#xA;    if (queue != null) {&#xA;        msg.target = this;&#xA;        sent = queue.enqueueMessage(msg, uptimeMillis);&#xA;    } else {&#xA;        RuntimeException e = new RuntimeException(&#xA;                this + &amp;ldquo; sendMessageAtTime() called with no mQueue&amp;rdquo;);&#xA;        Log.w(&amp;ldquo;Looper&amp;rdquo;, e.getMessage(), e);&#xA;    }&#xA;    return sent;&#xA;}&lt;/pre&gt;&#xA;在这个方法中，将Message排入消息队列（队列中按照uptimeMillis排序，而sendMessageAtFrontOfQueue方法中将它设为0，所以sendMessageAtFrontOfQueue方法传递的Message将在Looper的loop方法循环的下一次循环中立即执行）。enqueueMessage方法的排序部分如下：&#xA;&lt;pre&gt;synchronized (this) {&#xA;    if (mQuiting) {&#xA;        RuntimeException e = new RuntimeException(&#xA;                msg.target + &amp;ldquo; sending message to a Handler on a dead thread&amp;rdquo;);&#xA;        Log.w(&amp;ldquo;MessageQueue&amp;rdquo;, e.getMessage(), e);&#xA;        return false;&#xA;    } else if (msg.target == null) {&#xA;        mQuiting = true;&#xA;    }&#xA;    msg.when = when;&#xA;    //Log.d(&amp;ldquo;MessageQueue&amp;rdquo;, &amp;ldquo;Enqueing: &amp;ldquo; + msg);&#xA;    Message p = mMessages;&#xA;    if (p == null || when == 0 || when &amp;lt; p.when) {&#xA;        msg.next = p;&#xA;        mMessages = msg;&#xA;        this.notify();&#xA;    } else {&#xA;        Message prev = null;&#xA;        while (p != null &amp;amp;&amp;amp; p.when &amp;lt;= when) {&#xA;        prev = p;&#xA;        p = p.next;&#xA;    }&#xA;    msg.next = prev.next;&#xA;    prev.next = msg;&#xA;    this.notify();&#xA;}&lt;/pre&gt;&#xA;将Message排入消息队列后的事情，是由Looper来完成的，详见&lt;a href=&#34;http://my.oschina.net/u/272863/blog/93721&#34;&gt;《Android之Looper》&lt;/a&gt;中的loop方法。在Looper的loop方法中，调用了msg.target（即Handler，见sendMessageAtTime方法）的dispatchMessage方法。&#xA;&lt;pre&gt;public void dispatchMessage(Message msg) {&#xA;    if (msg.callback != null) {&#xA;        handleCallback(msg);&#xA;    } else {&#xA;        if (mCallback != null) {&#xA;            if (mCallback.handleMessage(msg)) {&#xA;                return;&#xA;            }&#xA;        }&#xA;        handleMessage(msg);&#xA;    }&#xA;}&lt;/pre&gt;&#xA;第一个判断，msg.callback即为post系列方法传递到的Runnable对象。&#xA;&lt;pre&gt;private final void handleCallback(Message message) {&#xA;    message.callback.run();&#xA;}&lt;/pre&gt;&#xA;第二个mCallback.handleMessage方法，可以让你避免在自己的Handler子类中重写handleMessage方法。&lt;br /&gt;&#xA;还有remove系列方法，就是根据条件从消息队列中移除相关的Message。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Android中view的Touch事件传递顺序</title>
      <link>http://gavin1989.github.io/2013/02/how-are-android-touch-events-delivered.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看一下ViewGroup的dispatchTouchEvent的关键源码：&#xA;&lt;pre&gt;public boolean dispatchTouchEvent(MotionEvent ev) {&#xA;    &amp;hellip;&#xA;    if (action == MotionEvent.ACTION_DOWN) {&#xA;        &amp;hellip;&#xA;        if (disallowIntercept || !onInterceptTouchEvent(ev)) {&#xA;            final View[] children = mChildren;&#xA;            final int count = mChildrenCount;&#xA;            for (int i = count - 1; i &amp;gt;= 0; i&amp;ndash;) {&#xA;                final View child = children[i];&#xA;                if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE&#xA;                        || child.getAnimation() != null) {&#xA;                    &amp;hellip;&#xA;                    if (child.dispatchTouchEvent(ev))  {&#xA;                        // Event handled, we have a target now.&#xA;                        mMotionTarget = child;&#xA;                        return true;&#xA;                    }&#xA;                }&#xA;            }&#xA;        }&#xA;    }&#xA;    &amp;hellip;&#xA;    final View target = mMotionTarget;&#xA;    if (target == null) {&#xA;        &amp;hellip;&#xA;        return super.dispatchTouchEvent(ev);&#xA;    }&#xA;    if (!disallowIntercept &amp;amp;&amp;amp; onInterceptTouchEvent(ev)) {&#xA;        &amp;hellip;&#xA;        if (!target.dispatchTouchEvent(ev)) {&#xA;            // target didn&amp;rsquo;t handle ACTION_CANCEL. not much we can do&#xA;            // but they should have.&#xA;        }&#xA;        // clear the target&#xA;        mMotionTarget = null;&#xA;        // Don&amp;rsquo;t dispatch this event to our own view, because we already&#xA;        // saw it when intercepting; we just want to give the following&#xA;        // event to the normal onTouchEvent().&#xA;        return true;&#xA;    }&#xA;    &amp;hellip;&#xA;    return target.dispatchTouchEvent(ev);&#xA;}&lt;/pre&gt;&#xA;根据以上代码可知，如果onInterceptTouchEvent方法返回true，会直接调用当前ViewGroup的onTouch方法，否则则会依次调用其内包含的子控件的dispatchTouchEvent方法。我写了一个测试用例，ViewGroup的onInterceptTouchEvent方法与所有View的onTouch方法都打了Log：&#xA;&lt;pre&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;utf-8&amp;rdquo;?&amp;gt;&#xA;&amp;lt;org.gavin.test.view.MyScrollView xmlns:android=&amp;ldquo;http://schemas.android.com/apk/res/android&amp;rdquo;&#xA;    android:layout_width=&amp;ldquo;fill_parent&amp;rdquo;&#xA;    android:layout_height=&amp;ldquo;fill_parent&amp;rdquo; &amp;gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;amp;lt;org.gavin.test.view.MyLinearLayout&#xA;    android:layout_width=&amp;quot;fill_parent&amp;quot;&#xA;    android:layout_height=&amp;quot;fill_parent&amp;quot;&#xA;    android:orientation=&amp;quot;vertical&amp;quot;&amp;gt;&#xA;    &amp;amp;lt;org.gavin.test.view.MyImageView&#xA;        android:layout_width=&amp;quot;wrap_content&amp;quot;&#xA;        android:layout_height=&amp;quot;wrap_content&amp;quot;&#xA;        android:src=&amp;quot;@drawable/ic_launcher&amp;quot;&amp;gt;&#xA;    &amp;amp;lt;/org.gavin.test.view.MyImageView&amp;gt;&#xA;&amp;amp;lt;/org.gavin.test.view.MyLinearLayout&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&amp;lt;/org.gavin.test.view.MyScrollView&amp;gt;&lt;/pre&gt;&#xA;Log信息：&#xA;&lt;pre&gt;I/MyScrollView(26001)::onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26001): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyImageView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26001): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyScrollView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;如果MyLinearLayout的onInterceptTouchEvent方法返回true：&#xA;&lt;pre&gt;11-04 14:05:08.389: I/MyScrollView(26297): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.389: I/MyLinearLayout(26297):onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.397: I/MyLinearLayout(26297): onTouchEvent:MotionEvent{&amp;hellip;}&#xA;11-04 14:05:08.397: I/MyScrollView(26297): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&#xA;OK，再看这段代码：&#xA;&lt;pre&gt;if (child.dispatchTouchEvent(ev))  {&#xA;    // Event handled, we have a target now.&#xA;    mMotionTarget = child;&#xA;    return true;&#xA;}&lt;/pre&gt;&#xA;从这段代码可以看出，如果某个子控件的dispatchTouchEvent方法返回true，则中断以后的消息传递。并在下一个非ACTION_DOWN事件直接调用此子控件的dispatchTouchEvent方法。一个View的dispatchTouchEvent返回true，主要可能是onTouch方法返回true。如果我们把MyImageView的onTouchEvent返回值改为true：&#xA;&lt;pre&gt;I/MyScrollView(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyLinearLayout(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&#xA;I/MyImageView(26393): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>