<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Gavin Droider</title>
    <link>http://gavin1989.github.io</link>
    <pubDate>2013-05-10 03:52:25 +0800</pubDate>
    <item>
      <title>Android中view的Touch事件传递顺序</title>
      <link>http://gavin1989.github.io/Android/Android%E4%B8%ADview%E7%9A%84Touch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>2013-02-27 04:05:08 +0800</pubDate>
      <description>&lt;p&gt;先看一下ViewGroup的dispatchTouchEvent的关键源码：
&lt;pre&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
        &amp;hellip;
        if (action == MotionEvent.ACTION_DOWN) {
        &amp;hellip;
            if (disallowIntercept || !onInterceptTouchEvent(ev)) {
                final View[] children = mChildren;
                final int count = mChildrenCount;
                for (int i = count - 1; i &amp;gt;= 0; i&amp;ndash;) {
                    final View child = children[i];
                    if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE
                            || child.getAnimation() != null) {
                        &amp;hellip;
                        if (child.dispatchTouchEvent(ev))  {
                            // Event handled, we have a target now.
                            mMotionTarget = child;
                            return true;
                        }
                    }
                }
            }
        }
        &amp;hellip;
        final View target = mMotionTarget;
        if (target == null) {
            &amp;hellip;
            return super.dispatchTouchEvent(ev);
        }
        if (!disallowIntercept &amp;amp;&amp;amp; onInterceptTouchEvent(ev)) {
            &amp;hellip;
            if (!target.dispatchTouchEvent(ev)) {
                // target didn&amp;rsquo;t handle ACTION_CANCEL. not much we can do
                // but they should have.
            }
            // clear the target
            mMotionTarget = null;
            // Don&amp;rsquo;t dispatch this event to our own view, because we already
            // saw it when intercepting; we just want to give the following
            // event to the normal onTouchEvent().
            return true;
        }
        &amp;hellip;
        return target.dispatchTouchEvent(ev);
    }&lt;/pre&gt;
根据以上代码可知，如果onInterceptTouchEvent方法返回true，会直接调用当前ViewGroup的onTouch方法，否则则会依次调用其内包含的子控件的dispatchTouchEvent方法。我写了一个测试用例，ViewGroup的onInterceptTouchEvent方法与所有View的onTouch方法都打了Log：
&lt;pre&gt;    &amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;utf-8&amp;rdquo;?&amp;gt;
    &amp;lt;org.gavin.test.view.MyScrollView xmlns:android=&amp;ldquo;http://schemas.android.com/apk/res/android&amp;rdquo;
        android:layout_width=&amp;ldquo;fill_parent&amp;rdquo;
        android:layout_height=&amp;ldquo;fill_parent&amp;rdquo; &amp;gt;
        &amp;lt;org.gavin.test.view.MyLinearLayout
            android:layout_width=&amp;ldquo;fill_parent&amp;rdquo;
        android:layout_height=&amp;ldquo;fill_parent&amp;rdquo;
        android:orientation=&amp;ldquo;vertical&amp;rdquo;&amp;gt;
        &amp;lt;org.gavin.test.view.MyImageView
            android:layout_width=&amp;ldquo;wrap_content&amp;rdquo;
            android:layout_height=&amp;ldquo;wrap_content&amp;rdquo;
            android:src=&amp;ldquo;@drawable/ic_launcher&amp;rdquo;&amp;gt;
            &lt;/org.gavin.test.view.MyImageView&gt;
        &amp;lt;/org.gavin.test.view.MyLinearLayout&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;lt;/org.gavin.test.view.MyScrollView&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log信息：
&lt;pre&gt;
I/MyScrollView(26001): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&lt;br /&gt;
I/MyLinearLayout(26001): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&lt;br /&gt;
I/MyImageView(26001): onTouchEvent:MotionEvent{&amp;hellip;}
I/MyLinearLayout(26001): onTouchEvent:MotionEvent{&amp;hellip;}
I/MyScrollView(26001): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;
如果MyLinearLayout的onInterceptTouchEvent方法返回true：
&lt;pre&gt;11-04 14:05:08.389: I/MyScrollView(26297): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&lt;br /&gt;
11-04 14:05:08.389: I/MyLinearLayout(26297): onInterceptTouchEvent:MotionEvent{&amp;hellip;}&lt;br /&gt;
11-04 14:05:08.397: I/MyLinearLayout(26297): onTouchEvent:MotionEvent{&amp;hellip;}&lt;br /&gt;
11-04 14:05:08.397: I/MyScrollView(26297): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;
OK，再看这段代码：
&lt;pre&gt;    if (child.dispatchTouchEvent(ev))  {
        // Event handled, we have a target now.
        mMotionTarget = child;
        return true;
    }&lt;/pre&gt;
从这段代码可以看出，如果某个子控件的dispatchTouchEvent方法返回true，则中断以后的消息传递。并在下一个非ACTION_DOWN事件直接调用此子控件的dispatchTouchEvent方法。一个View的dispatchTouchEvent返回true，主要可能是onTouch方法返回true。如果我们把MyImageView的onTouchEvent返回值改为true：
&lt;pre&gt;MyScrollView(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}
MyLinearLayout(26393): onInterceptTouchEvent:MotionEvent{&amp;hellip;}
MyImageView(26393): onTouchEvent:MotionEvent{&amp;hellip;}&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://gavin1989.github.io/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;

&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;

&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;
&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;
&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;
&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;

&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor post 文章标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;gor compile #编译
gor http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;

&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;

&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;

&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;申请github帐户&lt;/li&gt;
&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;
&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;
&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git
git add -A
git commit -m &amp;quot;...&amp;quot;
git pull
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;

&lt;h1&gt;祝你使用愉快&lt;/h1&gt;
</description>
    </item>
  </channel>
</rss>