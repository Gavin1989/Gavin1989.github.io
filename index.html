<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>首页</title>
  
    <meta name="author" content="Gao Xu">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">
 

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Gavin Droider</a>
          <ul class="nav">
            
              


  <li><a href="/archive">Archive</a></li>


            
              


  <li><a href="/tags">Tags</a></li>


            
              


  <li><a href="/categories">Categories</a></li>


            
              


  <li><a href="/pages">Pages</a></li>


            
              


  <li><a href="/about">About Me</a></li>


            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>首页 </h1>
</div>

<div class="row">
  <div class="span12">
    
<h2>Gor已经为了编译成功了</h2>
<p>
  这段文字位于pages/index.html ,使用以下命令获取帮助或访问gor官网
</p>
<pre><code>$ gor help</code></pre>


<h2>最近更新</h2>


<div class="post">
  <h3 class="title"><a href="/2013/02/android-intentservice.html">android之intentservice</a> <span class="date">2013-02-28 14:10:33</span></h3>

  <p>IntentService是一种用于处理异步请求（表现为Intent）的服务基类。客户通过调用Context.startService(Intent)发送请求；根据需要启动服务，依次使用工作者线程处理每一个Intent，并且在工作完成后终止自身。<br />
这种“工作队列处理器”模式通常被用来从一个应用程序的主线程卸载任务。IntentService类的存在是为了简化这种模式，并且照顾了技术性的部分。要使用它，需要继承IntentService类并且实现onHandleIntent(Intent)方法。IntentService将会接收到这些Intent，运行一条工作者线程，并且在适当的时候停止服务。<br />
所有的请求都是在一个单一的工作者线程中处理的，尽管处理过程可能需要很长时间（不会阻塞应用程序的主线程），但是每次只能有一个请求会被处理。<br />
首先，看它提供的一个构造方法：
<pre>public IntentService(String name) {
    super();
    mName = name;
}</pre>
参数name被用于命名即将用到的工作者线程，它的重要性仅用于调试。这里需要注意的一点是，Service的实例化是系统来完成的，并且系统是用无参的构造方法来实例化Service的。所以，你的子类必须是无参的，然后在无参构造方法里调用super(&ldquo;name&rdquo;)。<br />
再看onCreate方法：
<pre>@Override
public void onCreate() {
    super.onCreate();
    HandlerThread thread = new HandlerThread(&ldquo;IntentService[&rdquo; + mName + &ldquo;]&rdquo;);
    thread.start();</p>

<pre><code>mServiceLooper = thread.getLooper();
mServiceHandler = new ServiceHandler(mServiceLooper);
</code></pre>

<p>}</pre>
其中的ServiceHandler是IntentService类的内部类：
<pre>private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }</p>


  <div class="more">
    <a href="/2013/02/android-intentservice.html" class="btn">read more..</a>
  </div>
</div>

<div class="post">
  <h3 class="title"><a href="/2013/02/android-handler.html">Android之Handler</a> <span class="date">2013-02-28</span></h3>

  <p>Handler：Handler允许你发送并且处理和线程消息队列相关的消息（Message）和可运行对象。每个Handler实例都有一个单独的相关线程和这个线程的消息队列。当你创建一个新的Handler时候，它将和创建者所在线程以及此线程的消息队列绑定。从这一刻起，它将传递消息和可运行对象到消息队列，并在消息和可运行对象被传出消息队列时执行它们。<br />
Handler主要有两种用途：</p>

<ol>
<li>把要被执行的消息和可运行对象添加到将要执行的任务清单里。</li>
<li>把要在另外一条线程上执行的动作列入自己的队列。</li>
</ol>

<p>安排消息到任务清单，可以使用以下几种方法：post，postAtTime(Runnable,long)，postDelayed，sendEmptyMessage，sendMessage，sendMessageAtTime以及sendMessageDelayed方法。post版本的方法允许你安排Runnable对象到任务清单，这些Runnable对象将在消息队列接收到后调用它们。sendMessage版本的方法允许你安排一个Message对象到任务清单，这个Message对象包含一个将被Hanlder的handleMessage方法处理的数据包（需要在你的子类中实现handleMessage方法）。<br />
你在posting或者sending时，既可以允许消息循环在准备完成后立即处理任务，也可以在执行任务之前指定一个延迟时间。上述post和send系列的最后两个方法可以设置超时、空转和定时行为。<br />
当你的应用程序创建一个进程的时候，这个进程的主线程就专门运行一个负责管理顶级程序对象（activities，broadcast receivers等等）和所有由这些对象创建的窗口的消息循环。你可以创建自己的线程，并且通过一个Handler和应用的主线程沟通。这样做跟之前调用post或者sendMessage一样，只不过是在你的子线程中调用的。给定的Runnable对象或者Message将被添加到Hanlder的消息队列，并且在适当的时候处理它们。<br />
Hanlder默认的构造方法，将这个Handler跟当前线程中的队列关联了起来：
<pre>Handler() {
    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw newRuntimeException(&ldquo;Can&rsquo;t create handler inside thread that has not called Looper.prepare()&rdquo;);
    }
    mQueue = mLooper.mQueue;
    mCallback = null;
}</pre>
Handler必须要有一个消息队列，不然它没法接受消息。在线程初始化Handler之前，必须调用Looper.prepare()，详细内容请参考<a href="http://my.oschina.net/u/272863/blog/93721">《Android之Looper》。 </a><br />
初始化Handler时，还可以指定Looper和Callback，前者可以使消息循环在Looper相关的线程中运行，后者可以使你避免重写Handler。<br />
Handler的obtainMessage系列方法都是从全局的消息池中拿Message，如果池中没有，就new一个返回。<br />
post系列方法，都是封装的对应的send系列方法（将Runnable对象（msg.callback）和一个Object对象（即msg.object，如果有的话）通过getPostMessage方法拿到一个Message，然后send）。<br />
<pre>private final Message getPostMessage(Runnable r, Object token) {
    Message m = Message.obtain();
    m.obj = token;
    m.callback = r;
    return m;
}</pre>
send系列方法，包装的都是sendMessageAtTime方法（sendMessageAtFrontOfQueue方法也是它的一个变种）。在sendMessageAtTime方法中，第一个参数是将被传递的Message对象，第二个是传递时的时间（可以猜想delayed系列方法都是当前时间加上延迟时间，事实证明这种猜想是正确的）。<br />
<pre>public boolean sendMessageAtTime(Message msg, long uptimeMillis){
    boolean sent = false;
    MessageQueue queue = mQueue;
    if (queue != null) {
        msg.target = this;
        sent = queue.enqueueMessage(msg, uptimeMillis);
    } else {
        RuntimeException e = new RuntimeException(
                this + &ldquo; sendMessageAtTime() called with no mQueue&rdquo;);
        Log.w(&ldquo;Looper&rdquo;, e.getMessage(), e);
    }
    return sent;
}</pre>
在这个方法中，将Message排入消息队列（队列中按照uptimeMillis排序，而sendMessageAtFrontOfQueue方法中将它设为0，所以sendMessageAtFrontOfQueue方法传递的Message将在Looper的loop方法循环的下一次循环中立即执行）。enqueueMessage方法的排序部分如下：
<pre>synchronized (this) {
    if (mQuiting) {
        RuntimeException e = new RuntimeException(
                msg.target + &ldquo; sending message to a Handler on a dead thread&rdquo;);
        Log.w(&ldquo;MessageQueue&rdquo;, e.getMessage(), e);
        return false;
    } else if (msg.target == null) {
        mQuiting = true;
    }
    msg.when = when;
    //Log.d(&ldquo;MessageQueue&rdquo;, &ldquo;Enqueing: &ldquo; + msg);
    Message p = mMessages;
    if (p == null || when == 0 || when &lt; p.when) {
        msg.next = p;
        mMessages = msg;
        this.notify();
    } else {
        Message prev = null;
        while (p != null &amp;&amp; p.when &lt;= when) {
        prev = p;
        p = p.next;
    }
    msg.next = prev.next;
    prev.next = msg;
    this.notify();
}</pre>
将Message排入消息队列后的事情，是由Looper来完成的，详见<a href="http://my.oschina.net/u/272863/blog/93721">《Android之Looper》</a>中的loop方法。在Looper的loop方法中，调用了msg.target（即Handler，见sendMessageAtTime方法）的dispatchMessage方法。
<pre>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}</pre>
第一个判断，msg.callback即为post系列方法传递到的Runnable对象。
<pre>private final void handleCallback(Message message) {
    message.callback.run();
}</pre>
第二个mCallback.handleMessage方法，可以让你避免在自己的Handler子类中重写handleMessage方法。<br />
还有remove系列方法，就是根据条件从消息队列中移除相关的Message。</p>


  <div class="more">
    <a href="/2013/02/android-handler.html" class="btn">read more..</a>
  </div>
</div>

<div class="post">
  <h3 class="title"><a href="/2013/02/how-are-android-touch-events-delivered.html">Android中view的Touch事件传递顺序</a> <span class="date">2013-02-27</span></h3>

  <p>先看一下ViewGroup的dispatchTouchEvent的关键源码：
<pre>public boolean dispatchTouchEvent(MotionEvent ev) {
    &hellip;
    if (action == MotionEvent.ACTION_DOWN) {
        &hellip;
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {
            final View[] children = mChildren;
            final int count = mChildrenCount;
            for (int i = count - 1; i &gt;= 0; i&ndash;) {
                final View child = children[i];
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
                        || child.getAnimation() != null) {
                    &hellip;
                    if (child.dispatchTouchEvent(ev))  {
                        // Event handled, we have a target now.
                        mMotionTarget = child;
                        return true;
                    }
                }
            }
        }
    }
    &hellip;
    final View target = mMotionTarget;
    if (target == null) {
        &hellip;
        return super.dispatchTouchEvent(ev);
    }
    if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {
        &hellip;
        if (!target.dispatchTouchEvent(ev)) {
            // target didn&rsquo;t handle ACTION_CANCEL. not much we can do
            // but they should have.
        }
        // clear the target
        mMotionTarget = null;
        // Don&rsquo;t dispatch this event to our own view, because we already
        // saw it when intercepting; we just want to give the following
        // event to the normal onTouchEvent().
        return true;
    }
    &hellip;
    return target.dispatchTouchEvent(ev);
}</pre>
根据以上代码可知，如果onInterceptTouchEvent方法返回true，会直接调用当前ViewGroup的onTouch方法，否则则会依次调用其内包含的子控件的dispatchTouchEvent方法。我写了一个测试用例，ViewGroup的onInterceptTouchEvent方法与所有View的onTouch方法都打了Log：
<pre>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?&gt;
&lt;org.gavin.test.view.MyScrollView xmlns:android=&ldquo;http://schemas.android.com/apk/res/android&rdquo;
    android:layout_width=&ldquo;fill_parent&rdquo;
    android:layout_height=&ldquo;fill_parent&rdquo; &gt;</p>


  <div class="more">
    <a href="/2013/02/how-are-android-touch-events-delivered.html" class="btn">read more..</a>
  </div>
</div>

  </div>
</div>

      </div>

      <footer>
        <p>&copy; Gao Xu 2013 
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
		  and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

    
<script>
    var _gaq=[['_setAccount','UA-123-12'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
  </body>
</html>
